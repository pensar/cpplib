<DOCUMENT filename="algorithm_util.hpp">
 #ifndef ALGORITHM_UTIL_H_INCLUDED #define ALGORITHM_UTIL_H_INCLUDED #include<map> #include<string> namespace pensar_digital { namespace cpplib { template< typename T, typename Alloc = std::allocator<T>, template<typename, typename> class Container, typename Predicate > Container<T, Alloc>& erase_if(Container<T, Alloc>& c, Predicate p) { c.erase (std::remove_if (c.begin (), c.end (), p), c.end ()); return c; } template< typename Key, typename T, typename Compare = std::less<Key>, typename Alloc = std::allocator<std::pair<const Key, T> >, template<typename, typename, typename, typename> class MapClass, typename Predicate > void erase_if(MapClass<Key, T, Compare, Alloc>& map, Predicate p) { typedef typename MapClass<Key, T, Compare, Alloc>::iterator iterator; for (iterator it = map.begin (); it != map.end (); ++it) { if (p (*it)) map.erase (it); } } template<typename In, typename Out, typename Pred> Out copy_if(In first, In last, Out res, Pred Pr) { while (first != last) { if (Pr(*first)) *res++ = *first; ++first; } return res; } } } #endif </DOCUMENT>
<DOCUMENT filename="array.hpp">
 #ifndef ARRAY_HPP #define ARRAY_HPP #include "concept.hpp" #include "cs.hpp" namespace pensar_digital { namespace cpplib { using S = std::basic_string<C>; template <typename T> class Array { private: T* marray; size_t msize; public: typedef T value_type; Array(size_t size) : msize(size) { marray = new T[size]; } ~Array() { delete[] marray; } constexpr T& operator[] (const size_t index) const { return marray[index]; } constexpr T& at(const size_t index) const { return marray[index]; } [[nodiscard]] constexpr T* data() const noexcept { return marray; } [[nodiscard]] constexpr size_t size() const noexcept { return msize; } }; template <size_t Size = 1, typename T = size_t> requires StdLayoutTriviallyCopyable<T> class CArray { public: T _array[Size]; size_t _data_size; using value_type = T; const size_t SIZE = Size; template <bool safe = true> constexpr T& operator[] (const size_t index) const { if (index >= Size) { S msg = W("Array::operator[]: size is bigger than max (") + Size + W(")"); log_and_throw(msg); } return _array[index]; } template <> constexpr T& operator[]<false> (const size_t index) const { return _array[index]; } constexpr T* data() const noexcept { return _array; } constexpr size_t size() const noexcept { return Size; } }; static_assert(StdLayoutTriviallyCopyable<pensar_digital::cpplib::CArray<10>>); } } #endif </DOCUMENT>
<DOCUMENT filename="bool.hpp">
#ifndef BOOL_HPP #define BOOL_HPP #include "concept.hpp" #include <cstdint> namespace pensar_digital { namespace cpplib { struct Bool { static const int_fast8_t UNKNOWN = -1; static const int_fast8_t F = 0; static const int_fast8_t T = 1; int_fast8_t mvalue = UNKNOWN; Bool() = default; Bool(const Bool&) = default; Bool(Bool&&) = default; Bool& operator=(const Bool&) = default; Bool& operator=(Bool&&) = default; ~Bool() = default; constexpr Bool(int_fast8_t value) : mvalue(value) {} constexpr Bool(bool value) : mvalue(value ? T : F) {} constexpr operator bool() const { return mvalue == T; } constexpr operator int_fast8_t() const { return mvalue; } constexpr bool operator==(const Bool& other) const { return mvalue == other.mvalue; } }; static_assert(std::is_trivially_copyable<Bool>::value, "Bool must be trivially copyable."); } } #endif </DOCUMENT>
<DOCUMENT filename="bytes_util.hpp">
 #ifndef BYTES_UTIL_HPP_INCLUDED #define BYTES_UTIL_HPP_INCLUDED #include "constant.hpp" #include "concept.hpp" #include <span> #include <string> #include <vector> #include <cstddef> #include <bit> namespace pensar_digital { namespace cpplib { extern void string_to_bytes (const std::string& s, ByteSpan& v); extern void string_to_bytes (const std::wstring& s, ByteSpan& v); extern void bytes_to_string (const ByteSpan& bytes, std::string& s); extern void bytes_to_wstring (ByteSpan& bytes, std::wstring s); extern void add_bytes (const ByteSpan& bytes, ByteSpan& dest); extern void add_string_to_bytes (const std::string& s, ByteSpan& bytes); template <typename T> void add_number_to_bytes(const T n, ByteSpan& bytes) { const std::byte* p = reinterpret_cast<const std::byte*>(&n); constexpr size_t size = sizeof(T); ByteSpan number_bytes(p, p + size); add_bytes(number_bytes, bytes); } extern void int16_t_to_bytes (const int16_t i, ByteSpan& bytes); extern void int32_t_to_bytes (const int32_t i, ByteSpan& bytes); extern void int64_t_to_bytes (const int64_t i, ByteSpan& bytes); extern void int_to_bytes (const int i, ByteSpan& bytes); extern void uint16_t_to_bytes (const uint16_t i, ByteSpan& bytes); extern void uint32_t_to_bytes (const uint32_t i, ByteSpan& bytes); extern void uint64_t_to_bytes (const uint64_t i, ByteSpan& bytes); extern void uint_to_bytes (const unsigned int i, ByteSpan& bytes); extern void float_to_bytes (const float f, ByteSpan& bytes); extern void double_to_bytes (const double d, ByteSpan& bytes); extern void bool_to_bytes (const bool b, ByteSpan& bytes); extern void long_to_bytes (const long l, ByteSpan& bytes); extern void ulong_to_bytes (const unsigned long l, ByteSpan& bytes); extern void long_long_to_bytes (const long long ll, ByteSpan& bytes); extern void ulong_long_to_bytes (const unsigned long long ll, ByteSpan& bytes); template <TriviallyCopyable T> T bytes_to_type(const ByteSpan& bytes) { T t; std::memcpy(&t, bytes.data(), sizeof(T)); return t; } } } #endif </DOCUMENT>
<DOCUMENT filename="byte_array.hpp">
#ifndef BYTE_ARRAY_HPP #define BYTE_ARRAY_HPP #include "constant.hpp" #include <memory> namespace pensar_digital { namespace cpplib { class ByteArray; using ByteArrayPtr = std::unique_ptr<ByteArray>; class ByteArray { private: Byte* mdata; size_t msize; public: ByteArray(const size_t size = 0) : mdata(new Byte[size]), msize(size) {} ByteArray(const ByteArray& other) : mdata(new Byte[other.msize]), msize(other.msize) { for (size_t i = 0; i < msize; ++i) mdata[i] = other.mdata[i]; } ByteArray(ByteArray&& other) noexcept : mdata(other.mdata), msize(other.msize) { other.mdata = nullptr; other.msize = 0; } ~ByteArray() { delete[] mdata; } Byte& operator[] (const size_t index) { return mdata[index]; } const Byte& operator[] (const size_t index) const { return mdata[index]; } ByteArray& operator= (const ByteArray& other) { if (this != &other) { delete[] mdata; mdata = new Byte[other.msize]; msize = other.msize; memcpy(mdata, other.mdata, msize); } return *this; } ByteArray& operator= (ByteArray&& other) noexcept { if (this != &other) { delete[] mdata; mdata = other.mdata; msize = other.msize; other.mdata = nullptr; other.msize = 0; } return *this; } ByteArray& copy (const ByteArray& ba, const size_t offset = 0) { if ((ba.size () + offset) > msize) { delete[] mdata; msize = ba.size() + offset; mdata = new Byte[msize]; } memcpy(mdata + offset, ba.data (), size); return *this; } ByteArray& append (const ByteArray& ba) { i Byte* new_data = new Byte[msize + ba.size()]; memcpy(new_data, mdata, msize); memcpy(new_data + msize, ba.data(), ba.size()); delete[] mdata; mdata = new_data; msize += ba.size(); return *this; } size_t size() const { return msize; } Byte* data() { return mdata; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="byte_order.hpp">
 #ifndef BYTE_ORDER_HPP #define BYTE_ORDER_HPP #include <span> #include <bit> namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; enum Invariance : bool { DATA_INVARIANCE = false, ADDRESS_INVARIANCE = true}; typedef int_fast8_t Word; constexpr Word WORD_SIZE = sizeof (Word); template <typename T> inline void swap (T& a, T& b) noexcept { T tmp = std::move (a); a = std::move (b); b = std::move (tmp); } struct ByteOrder { std::endian mendian = std::endian::native ; Invariance minvariance = ADDRESS_INVARIANCE ; Word maddress_size = sizeof (std::byte); ByteOrder (const std::endian endian = std::endian::native, const Invariance invariance = ADDRESS_INVARIANCE, const Word address_size = sizeof (Word)) noexcept : mendian (endian), minvariance (invariance), maddress_size (address_size) {} inline bool is_address_invariant () const noexcept { return minvariance == ADDRESS_INVARIANCE; } inline bool is_data_invariant () const noexcept { return minvariance == DATA_INVARIANCE; } inline bool is_little_endian () const noexcept { return mendian == std::endian::little; } inline bool is_big_endian () const noexcept { return mendian == std::endian::big ; } inline bool is_native_endian () const noexcept { return mendian == std::endian::native; } inline bool equals_invariance (const ByteOrder& other) const noexcept { return minvariance == other.minvariance; } inline bool equals_endian (const ByteOrder& other) const noexcept { return mendian == other.mendian ; } inline bool equals_address_size (const ByteOrder& other) const noexcept { return maddress_size == other.maddress_size; } inline bool only_endian_differs (const ByteOrder& other) const noexcept { return ((!equals_endian(other)) && (equals_invariance (other) && equals_address_size (other))); } inline bool equals (const ByteOrder& other) const noexcept { return equals_invariance (other) && equals_endian(other) && equals_address_size (other); } inline bool operator == (const ByteOrder& other) const noexcept { return equals (other); } inline bool operator != (const ByteOrder& other) const noexcept { return !equals (other); } }; inline const ByteOrder little_address_8_byte_order = ByteOrder (std::endian::little, ADDRESS_INVARIANCE, sizeof (std::byte) * 8); inline const ByteOrder big_address_8_byte_order = ByteOrder (std::endian::big , ADDRESS_INVARIANCE, sizeof (std::byte) * 8); inline const ByteOrder native_byte_order = ByteOrder (std::endian::native, ADDRESS_INVARIANCE, sizeof (std::byte) * 8); template < size_t sz = 18> void convert(std::span<std::byte>& data, size_t original_data_size, const ByteOrder& from, const ByteOrder& to) noexcept { if ((from != to) && (data.size() > 1) && from.only_endian_differs(to) && (original_data_size > 1)) { auto e = data.size() - original_data_size; for (std::span<std::byte>::size_type i = 0; i <= e; i += original_data_size) { auto x = original_data_size / 2; for (auto j = 0; j < x; ++j) { pd::swap<std::byte>(data[i + j], data[i - j + original_data_size - 1]); } } } } inline void convert(const std::span<std::byte>& from_data, std::span<std::byte>& to_data, const ByteOrder& from, const ByteOrder& to) noexcept { } } } #endif </DOCUMENT>
<DOCUMENT filename="clone_util.hpp">
#ifndef CLONE_UTIL_HPP #define CLONE_UTIL_HPP #include "factory.hpp" #include <memory> namespace pensar_digital { namespace cpplib { template<class T, typename... Args> static typename NewFactory<T, Args...>::P clone(const T& other, const Args& ... args) { NewFactory<T, Args...> factory; return factory.get(args...); } template <typename T> concept CloneableConcept = requires (T t) { { t.clone() } -> std::convertible_to<typename T::Ptr>; }; } } #endif </DOCUMENT>
<DOCUMENT filename="code_util.hpp">
#ifndef CODE_UTIL_HPP #define CODE_UTIL_HPP #include "cs.hpp" #include "bool.hpp" namespace pensar_digital { namespace cpplib { template <typename T> struct Result { using ErrorMessageType = CS<0, 256>; using ResultType = T; T mresult; Bool mok = Bool::T; ErrorMessageType merror_message = EMPTY; Result() = default; Result(const Result&) = default; Result(Result&&) = default; Result(ResultType rt, Bool ok = Bool::T, ErrorMessageType err = EMPTY) : mresult(rt), mok(ok), merror_message(err) {} Result(ErrorMessageType err, ResultType r = T{}) : mresult(r), mok(Bool::F), merror_message(err) {} Result& operator=(const Result&) = default; Result& operator=(Result&&) = default; ~Result() = default; Result(const ErrorMessageType& error_message) : merror_message(error_message), mok(Bool::F) {} Result(const C* error_message) : merror_message(CS<0, 256>(error_message)), mok(Bool::F) {} operator Bool() const { return mok; } operator T() const { return mresult; } operator ErrorMessageType() const { return merror_message; } bool operator==(const T& other) const { return mresult == other; } bool operator!=(const T& other) const { return !(*this == other); } bool operator<(const T& other) const { return mresult < other; } Result& operator=(const T& other) { mresult = other; return *this; } Result& operator=(const Bool& other) { mok = other; return *this; } Result& operator=(const ErrorMessageType& other) { merror_message = other; mok = Bool::F; return *this; } bool operator!() const { return !mok; } }; static_assert(std::is_trivially_copyable<Result<int>>::value, "Result<int> must be trivially copyable."); } } #endif </DOCUMENT>
<DOCUMENT filename="command.hpp">
#ifndef CPP_COMMAND_HPP #define CPP_COMMAND_HPP #include <iostream> #include <vector> #include <memory> #include <exception> #include <algorithm> #include <type_traits> #include <tuple> #include <concepts> #include "constant.hpp" #include "s.hpp" #include "object.hpp" #include "concept.hpp" #include "generator.hpp" #include "version.hpp" #include "factory.hpp" #include "bool.hpp" #include "memory_buffer.hpp" #include "clone_util.hpp" #include "equal.hpp" namespace pensar_digital { namespace cpplib { template<typename T> concept CommandConcept = requires(T t) { { t.run() } -> std::same_as<void>; }&& Identifiable<T> && CloneableConcept<T>; template<class T> concept DerivedCommandConcept = requires(T t) { { t._run() } -> std::same_as<void>; }&& CloneableConcept<T>; template<typename T> concept UndoableCommandConcept = CommandConcept<T> && requires(T t) { { t.undo() } -> std::same_as<void>; }; template<class T> concept DerivedUndoableCommandConcept = DerivedCommandConcept<T> && UndoableCommandConcept<T>; namespace pd = pensar_digital::cpplib; class Command : public Object { private: struct Data : public pd::Data { Bool mok = Bool::UNKNOWN; Data(const Bool ok = Bool::UNKNOWN) noexcept : mok (ok) {} }; static_assert(StdLayoutTriviallyCopyable<Data>, "Data must be a trivially copyable type"); Data mdata; public: using Ptr = std::shared_ptr<Command>; inline const static Data NULL_DATA = { Bool::UNKNOWN }; using DataType = Data; using Factory = pd::Factory<Command, Id, typename Command::DataType>; inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("Command"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } using FactoryType = Factory; virtual const pd::Data* data() const noexcept { return &mdata; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)data(); } virtual size_t data_size() const noexcept { return sizeof(mdata); } virtual size_t size() const noexcept { return data_size() + sizeof(ClassInfo) + Object::SIZE; } using G = Generator<Command, Id>; inline static constexpr size_t DATA_SIZE = sizeof(mdata); inline static constexpr size_t SIZE = Object::SIZE + DATA_SIZE + sizeof(ClassInfo) + G::SIZE; protected: inline static G mgenerator = G(); public: Command (const Id aid = NULL_ID, const Data& data = NULL_DATA) : Object(aid == NULL_ID ? mgenerator.get_id() : aid), mdata(data) {} Command (Command&&) = default; Command (const Command&) = default; Command (MemoryBuffer& mb) : Object (mb) { assign_without_object (mb); } Command& operator= (Command&&) = default; Command& operator= (const Command&) = default; virtual ~Command () = default; virtual bool initialize (const Id id, const Data& data) noexcept { this->set_id(id == NULL_ID ? mgenerator.get_id() : id); mdata = data; return true; } virtual bool equals(const Object& o) const noexcept { const Command* pother = dynamic_cast<const Command*>(&o); if (pother == nullptr) return false; return equal<Command> (*this, *pother); } virtual Command& assign_without_object(MemoryBuffer& mb) noexcept { INFO.test_class_name_and_version (mb); mb.read_known_size((BytePtr)&mdata, DATA_SIZE); mgenerator = G(mb); return *this; } virtual Command& assign(MemoryBuffer& mb) noexcept { Object::assign(mb); return assign_without_object(mb); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append (*Object::bytes()); mb->append (INFO.bytes()); mb->write((BytePtr(&mdata)), DATA_SIZE); mb->append (*(mgenerator.bytes())); return mb; } virtual std::ostream& child_binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { return os; } virtual std::istream& child_binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { return is; } inline virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write (os, byte_order); INFO.binary_write(os, byte_order); os.write((char*)&mdata, DATA_SIZE); mgenerator.binary_write(os, byte_order); child_binary_write(os, byte_order); return os; } inline virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read(is, byte_order); INFO.test_class_name_and_version(is, byte_order); is.read((char*)&mdata, DATA_SIZE); mgenerator.binary_read(is, byte_order); child_binary_read(is, byte_order); return is; } protected: inline virtual void _run() {} inline virtual void _undo() const {} public: using Ptr = std::shared_ptr<Command>; inline Ptr clone() const noexcept { return pd::clone<Command>(*this, id()); } virtual void run () { _run(); mdata.mok = true; } void undo() const { if (mdata.mok) { _undo(); } } bool ok() const { return mdata.mok; } /* inline static typename FactoryType::P get(const Id aid = NULL_ID, const Data& data = NULL_DATA) noexcept { return mfactory.get(aid, data); } */ }; class NullCommand : public Command { public: using Ptr = std::shared_ptr<NullCommand>; NullCommand () : Command(NULL_ID) { } NullCommand (MemoryBuffer& mb) : Command (mb) { } ~NullCommand() = default; void _run() { } void _undo() const { } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("NullCommand"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } Ptr clone() const noexcept { return pd::clone<NullCommand>(*this); } }; inline static const NullCommand NULL_CMD = NullCommand(); static_assert (Identifiable<NullCommand>); static_assert (CommandConcept<NullCommand>); static_assert (DerivedCommandConcept<NullCommand>); static_assert (UndoableCommandConcept<NullCommand>); static_assert (DerivedUndoableCommandConcept<NullCommand>); class CompositeCommand : public Command { public: inline static const size_t MAX_COMMANDS = 10; using Ptr = std::shared_ptr<CompositeCommand>; private: struct Data : public pd::Data { using CommandArray = std::array<Command*, MAX_COMMANDS>; CommandArray mcommands; size_t mindex = 0; void add(Command* cmd) { if (mindex >= MAX_COMMANDS) { log_and_throw("CompositeCommand::Data::add(Command* cmd) : Maximum number of commands reached."); } mcommands[mindex++] = cmd; } void free_commands() { for (size_t i = 0; i < mindex; ++i) { delete mcommands[i]; } } }; static_assert(StdLayoutTriviallyCopyable<Data>, "Data must be a standard layout and trivially copyable type"); Data mdata; public: inline const static Data NULL_DATA = { {}, 0 }; using DataType = Data; using Factory = pd::Factory<CompositeCommand, Id>; using Int = int_fast8_t; inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("CompositeCommand"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } using FactoryType = Factory; virtual const pd::Data* data() const noexcept { return &mdata; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)data(); } inline static constexpr size_t DATA_SIZE = sizeof(mdata); virtual size_t data_size() const noexcept { return sizeof(mdata); } virtual size_t size() const noexcept { size_t size = sizeof(mdata.mindex) + sizeof(ClassInfo); for (Int i = 0; i < mdata.mindex; ++i) { size += mdata.mcommands[i]->size(); } return size; } public: CompositeCommand(const Id aid = NULL_ID) : Command(aid), mdata (NULL_DATA) { } CompositeCommand (MemoryBuffer& mb) : Command(mb) { assign_without_parent(mb); } ~CompositeCommand() { mdata.free_commands(); } private: inline static Factory mfactory = { 3, 10, NULL_ID }; public: Command& assign_without_parent(MemoryBuffer& mb) noexcept { for (Int i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->assign(mb); } return *this; } virtual Command& assign(MemoryBuffer& mb) noexcept { Command::assign(mb); return assign_without_parent (mb); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size ()); mb->append(Command::bytes()); mb->append(INFO.bytes()); mb->append((BytePtr)(&mdata.mindex), sizeof(mdata.mindex)); for (Int i = 0; i < mdata.mindex; ++i) { mb->append(mdata.mcommands[i]->bytes()); }; return mb; } virtual bool initialize (const Id id) noexcept { this->set_id (id == NULL_ID ? this->mgenerator.get_id() : id); return true; } inline static typename FactoryType::P get (const Id aid = NULL_ID) noexcept { return mfactory.get (aid); } void _run() { for (Int i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->run(); } } void _undo() const { for (Int i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->undo(); } } void add (Command* cmd) { mdata.add (cmd); } Ptr clone () const noexcept { Ptr pcc = std::make_shared<CompositeCommand>(id()); pcc->mdata.mindex = mdata.mindex; for (size_t i = 0; i < mdata.mindex; ++i) { pcc->add((Command*)mdata.mcommands[i]->clone().get ()); } return pcc; } virtual bool equals(const Object& o) const noexcept { const CompositeCommand* pother = dynamic_cast<const CompositeCommand*>(&o); if (pother == nullptr) return false; if (o.id () != id ()) return false; for (size_t i = 0; i < mdata.mindex; ++i) { if (!mdata.mcommands[i]->equals(*pother->mdata.mcommands[i])) return false; } return true; } inline virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read(is, byte_order); info_ptr()->test_class_name_and_version (is, byte_order); is.read((char*)(&mdata), DATA_SIZE); for (size_t i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i] = new Command (); mdata.mcommands[i]->binary_read(is, byte_order); } return is; } inline virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); info_ptr()->binary_write(os, byte_order); for (size_t i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->binary_write(os, byte_order); } return os; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="concept.hpp">
#ifndef CONCEPT #define CONCEPT #include "constant.hpp" #include "factory.hpp" #include <concepts> #include <iostream> #include <memory> #include <type_traits> #include <span> #include <cstddef> namespace pensar_digital { namespace cpplib { template <typename T, typename... Args> concept Checkable = requires (T t, Args&& ... args) { {t.ok(args ...)} -> std::convertible_to<bool>; }; template <typename T> concept Hashable = requires (T t) { {t.hash()} -> std::convertible_to<Hash>; }; template <typename T> concept RangeCheckable = requires (T t) { {t >= t} -> std::convertible_to<bool>; {t <= t} -> std::convertible_to<bool>; }; template <typename T> concept DefaultConstructible = requires { {T()} noexcept; }; template <typename T, typename... Args> concept Initializable = requires (T t, Args... args) { {T(std::forward<Args>(args) ...)} noexcept; {t.initialize(std::forward<Args>(args) ...)} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Factorable = requires { typename T::Factory; std::derived_from<typename T::Factory, NewFactory<T>>; }; template <class T, typename... Args> concept FactoryConstructible = Initializable<T, Args...>&& requires (Args... args) { {T::get(args ...)} noexcept -> std::convertible_to<typename T::Factory::P>; } && Factorable<T>; template <typename T, typename... Args> concept AFactory = requires (T t, Args... args) { {t.get(args ...)} noexcept -> std::convertible_to<std::shared_ptr<T>>; }; template <typename T> concept Container = requires (T t, size_t i) { typename T::value_type; { t.at(i) } -> std::convertible_to<typename T::value_type&>; { t[i] } -> std::convertible_to<typename T::value_type&>; { t.size() } -> std::convertible_to<size_t>; }; template <typename T, typename V> concept ContainerV = Container<T> && std::is_same<typename T::value_type, V>::value; template <typename T> concept Interfaceable = requires { typename T::I; typename T::I_RO; }; template <typename T> concept Negatable = requires (T t) { {!t} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Andable = requires (T t) { {t && t} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Orable = requires (T t) { {t || t} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Xorable = requires (T t) { {t ^ t} noexcept -> std::convertible_to<bool>; }; template<typename T> concept NarrowOutputStreamable = requires(T a, std::ostream & os) { { os << a } -> std::same_as<std::ostream&>; }; template<typename T> concept WideOutputStreamable = requires(T a, std::wostream & os) { { os << a } -> std::same_as<std::wostream&>; }; template<typename T> concept OutputStreamable = NarrowOutputStreamable<T> || WideOutputStreamable<T>; template<typename T> concept NarrowInputStreamable = requires(T a, std::istream & is) { { is >> a } -> std::same_as<std::istream&>; }; template<typename T> concept WideInputStreamable = requires(T a, std::wistream & is) { { is >> a } -> std::same_as<std::wistream&>; }; template<typename T> concept InputStreamable = NarrowInputStreamable<T> || WideInputStreamable<T>; template<typename T> concept Streamable = OutputStreamable<T> && InputStreamable<T>; template <typename T> concept CharCastable = requires(T * t) { { reinterpret_cast<char*>(*t) } -> std::same_as<char*>; }; template <typename T> concept ByteCastable = requires(T * t) { { reinterpret_cast<std::byte*>(*t) } -> std::same_as<std::byte*>; }; template <typename T> concept Sizeofable = requires(T t) { { sizeof(t) } -> std::same_as<size_t>; }; template <typename T> concept Identifiable = requires(T t) { { t.id() } -> std::convertible_to<Id>; }; template <typename T> concept SizeableIdentifiable = Identifiable<T> && Sizeofable<T>; template <typename T> concept Countable = requires(T t) { { t.count() } -> std::convertible_to<size_t>; }; template <typename T> concept Sizeable = requires(T t) { { t.size() } -> std::convertible_to<size_t>; }; template <typename T> concept BinaryStreamable = CharCastable<T> && Sizeofable<T> && Streamable<T>; template <typename T> concept BinaryReadable = requires(T t, std::span<std::byte>& bytes) { { t.read (bytes) } -> std::convertible_to<void>; }; template <typename T, typename Obj> concept ObjectBinaryReadable = requires(T t, Obj* p) { { t.template read<Obj> (p) } -> std::convertible_to<void>; } && BinaryReadable<T>; template <typename T, typename Obj, typename... Args> concept FactoryObjBinaryReadable = requires(T t) { { t.template read<Obj, Args...> () } -> std::convertible_to<typename Obj::Factory::P>; } && ObjectBinaryReadable<T, Obj>&& FactoryConstructible<Obj, Args ...>; template<typename T> concept Pointable = requires(T t) { { t.operator->() } -> std::convertible_to<T*>; { *t } -> std::convertible_to<T&>; }; template<typename T> concept StandardLayout = std::is_standard_layout_v<T>; template<typename T> concept TriviallyCopyable = std::is_trivially_copyable_v<T>; template<typename T> concept StdLayoutTriviallyCopyable = StandardLayout<T> && TriviallyCopyable<T>; template <typename T> concept HasStdLayoutTriviallyCopyableData = requires (T t) { { t.data() } -> std::convertible_to<const Data*>; { t.data_size() } -> std::convertible_to<size_t>; { T::DATA_SIZE } -> std::convertible_to<size_t>; { T::SIZE } -> std::convertible_to<size_t>; }&& TriviallyCopyable<typename T::DataType>&& StdLayoutTriviallyCopyable<typename T::DataType>; template <class T> concept TriviallyPersistable = requires (T t) { {t.data() } -> std::convertible_to<const Data*>; {t.data_size()} -> std::convertible_to<size_t>; } && TriviallyCopyable<typename T::DataType> && Identifiable<T> && Hashable<T>; template<typename T> concept TriviallyDestructible = std::is_trivially_destructible_v<T>; template<typename T> concept TriviallyConstructible = std::is_trivially_constructible_v<T>; template<typename T, typename U> concept TriviallyAssignable = std::is_trivially_assignable_v<T, U>; template<typename T> concept TriviallyCopyAssignable = std::is_trivially_copy_assignable_v<T>; template<typename T> concept TriviallyMoveAssignable = std::is_trivially_move_assignable_v<T>; template<typename T> concept TriviallyMoveConstructible = std::is_trivially_move_constructible_v<T>; template<typename T> concept TriviallyCopyConstructible = std::is_trivially_copy_constructible_v<T>; template<typename T> concept TriviallyMovable = TriviallyMoveConstructible<T> && TriviallyMoveAssignable<T>; } } #endif </DOCUMENT>
<DOCUMENT filename="constant.hpp">
 #ifndef constantesHPP #define constantesHPP #define VISUAL_STUDIO #define _WINSOCKAPI_ #include <cstdint> #include <vector> #include <cstddef> #include <concepts> #include <iostream> #include <fstream> #include <string> #include <sstream> #include <filesystem> #include <algorithm> #include <functional> #include <memory> #include <map> #include <set> #include <list> #include <queue> #include <stack> #include <tuple> #include <variant> #include <optional> #include <any> #include <chrono> #include <thread> #include <mutex> #include <condition_variable> #include <atomic> #include <future> #include <type_traits> #include <typeinfo> #include <random> #include <functional> #include <cctype> #include <span> #include "string_def.hpp" namespace pensar_digital { namespace cpplib { #if defined(_WIN32) || defined(_WIN64) #define WINDOWS #endif struct Data { }; using Id = int_fast64_t; using Hash = int_fast64_t; using FileSize = int_fast64_t; inline const Id NULL_ID = -1; template <typename T> concept unsigned_integral = std::is_integral<T>::value && std::is_unsigned<T>::value; template <unsigned_integral T> constexpr T null_value() { return 0; } template <std::signed_integral T> constexpr T null_value() { return -1; } enum Alignment : int_fast16_t { NULL_ALIGNMENT = -1, BIT8 = 8, BIT16 = 16, BIT32 = 32, BIT64 = 64, BIT128 = 128, BIT256 = 256, BIT512 = 512, BIT1024 = 1024 }; using Byte = std::byte; using Bytes = std::vector<Byte>; using BytePtr = Byte*; using ByteSpan = std::span<Byte>; inline const bool PAD_RIGHT = true; inline const bool PAD_LEFT = false; inline const bool TRIM_ELEMENTS = true; inline const bool INCLUDE_EMPTY_FIELDS = true; inline static const bool ADD_NULL_AT_END = true; inline static const bool DO_NOT_ADD_NULL_AT_END = false; inline static const bool FILL_NULL_BEFORE_COPY = true; inline static const bool DO_NOT_FILL_NULL_BEFORE_COPY = false; inline static const C* CPPLIB_NAMESPACE = W("pensar_digital::cpplib"); using VersionInt = int16_t; } } namespace pd = pensar_digital::cpplib; #endif </DOCUMENT>
<DOCUMENT filename="constraint.hpp">
 #ifndef CONSTRAINT_HPP #define CONSTRAINT_HPP #include "object.hpp" #include "version.hpp" #include "constant.hpp" #include <cstdarg> #include <regex> #include <variant> namespace pensar_digital { namespace cpplib { static const S ONLY_DIGITS_REGEX = W("^[0-9]*$"); static const S AT_LEAST_ONE_DIGIT_REGEX = W("^[0-9]+$"); static const S ONLY_LETTERS_REGEX = W("^[a-zA-Z]*$"); static const S ONLY_LETTERS_AND_DIGITS_REGEX = W("^[a-zA-Z0-9]*$"); static const S ONLY_LETTERS_AND_DIGITS_AND_UNDERSCORES_REGEX = W("^[a-zA-Z0-9_]*$"); template <typename L, typename R, typename ResultType, class D> class Operand : public Object { public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); Operand (const Id aid = NULL_ID) : Object(aid) {} template <typename ... Args> ResultType operator () (L* left, R* right = nullptr, Args&& ... args) const { return static_cast<D*>(this)->::operator () (left, right, args ...); }; virtual ~Operand() {} }; template <typename T, typename ResultType, class D> class UnaryOperand : public Operand<T, T, ResultType, UnaryOperand<T, ResultType, D>> { private: typedef UnaryOperand<T, ResultType, D> UnaryOp; typedef Operand <T, T, ResultType, UnaryOp> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); UnaryOperand (const Id aid = NULL_ID) : Base(aid) {} virtual ~UnaryOperand() {} template <typename ... Args> ResultType operator () (T* ptr, const T* not_used = nullptr, Args&& ... args) const { return static_cast<D*>(this)->::operator () (ptr, args ...); }; }; template <Checkable T> class NotOperand : public UnaryOperand<T, bool, NotOperand<T>> { private: typedef UnaryOperand<T, bool, NotOperand<T>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); NotOperand (const Id aid = NULL_ID) : Base(aid) {} virtual ~NotOperand() {} template <typename ... Args> bool operator () (const T* ptr, Args&& ... args) const noexcept { return !ptr->ok (args ...); }; }; template <typename L, typename R, typename ResultType, class D> class BinaryOperand : public Operand<L, R, ResultType, BinaryOperand<L, R, ResultType, D>> { private: typedef Operand<L, R, ResultType, BinaryOperand<L, R, ResultType, D>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); BinaryOperand (const Id aid = NULL_ID) : Base (aid) {} virtual ~BinaryOperand() {} template <typename ... Args> ResultType operator () (const L* left, const R* right = nullptr, Args&& ... args) const { return static_cast<D*>(this)->operator () (left, right, args ...); }; }; template <Checkable L, Checkable R> class AndOperand : public BinaryOperand<L, R, bool, AndOperand<L, R>> { private: typedef BinaryOperand<L, R, bool, AndOperand<L, R>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); AndOperand (const Id aid = NULL_ID) noexcept : Base (aid) {} virtual ~AndOperand() {} template <typename ... Args> bool operator () (const L& left, const R& right, Args&& ... args) const noexcept { return (left.ok(args ...) && right.ok(args ...)); } }; template <Checkable L, Checkable R> class OrOperand : public BinaryOperand<L, R, bool, OrOperand<L, R>> { private: typedef BinaryOperand<L, R, bool, OrOperand<L, R>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); OrOperand(const Id aid = NULL_ID) noexcept : Base(aid) {} virtual ~OrOperand() {} template <typename ... Args> bool operator () (const L& left = nullptr, const R& right = nullptr, Args&& ... args) const noexcept { return (left.ok(args ...) || right.ok(args ...)); } }; template <Checkable L, Checkable R> class XorOperand : public BinaryOperand<L, R, bool, XorOperand<L, R>> { private: typedef BinaryOperand<L, R, bool, XorOperand<L, R>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); XorOperand(const Id aid = NULL_ID) noexcept : Base(aid) {} virtual ~XorOperand() {} template <typename ... Args> bool operator () (const L& left = nullptr, const R& right = nullptr, Args&& ... args) const noexcept { return (left.ok(args ...) ^ right.ok(args ...)); } }; template <class D> class Constraint : public Object { private: S name; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); Constraint(const Id aid = NULL_ID, const S& aname = "") : Object(aid), name(aname) {} virtual ~Constraint () {} inline const S& get_name () const noexcept { return name; } inline void set_name (const S& aname) { name = aname; } virtual bool initialize(const Id& aid = NULL_ID, const S& aname = "") noexcept { Object::set_id(aid); name = aname; return true; } template <typename... Args> bool ok (Args&& ... args) const noexcept { static_assert (Checkable<D, Args>); return static_cast<D*>(this)->::ok (std::forward<Args>(args)...); }; template <typename... Args> bool Or (const Constraint<D>& other, Args& ... args) const noexcept { return ok (args ...) || other.ok (args ...); }; template <typename... Args> bool And (const Constraint<D>& other, Args& ... args) const noexcept { return ok(args ...) && other.ok(args ...); }; template <typename... Args> bool Xor (const Constraint<D>& other, Args& ... args) const noexcept { return ok(args ...) ^ other.ok(args ...); }; template <typename... Args> bool Not (Args& ... args) const noexcept { return !ok(args ...); }; }; template <Checkable L, Checkable R> class CompositeConstraint : public Constraint <CompositeConstraint<L, R>> { public: typedef std::variant <AndOperand <L, R>, OrOperand <L, R>, XorOperand <L, R>> OpType; typedef enum { AND, OR, XOR } OpIndex; private: typedef CompositeConstraint<L, R> C; typedef Constraint <C> Base; typedef std::shared_ptr<Base > BasePtr; typedef std::shared_ptr<L > LeftPtr; typedef std::shared_ptr<R > RightPtr; const L& left; const R& right; OpType op; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); CompositeConstraint (const L& aleft, const R& aright, const OpType aop, const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), left(aleft), right(aright), op (aop) { } virtual ~CompositeConstraint() {} template <typename ...Args> bool ok (Args&& ...args) const noexcept { switch (op.index ()) { case AND: return std::get<AND>(op) (left, right, args ...); case OR: return std::get<OR>(op) (left, right, args ...); case XOR: return std::get<XOR>(op) (left, right, args ...); } return false; }; }; template <Checkable L, Checkable R> CompositeConstraint<L, R> operator && (const L& left, const R& right) { typedef CompositeConstraint<L, R> C; return * new C (left, right); } template <Checkable L, Checkable R> CompositeConstraint<L, R> operator || (const L& left, const R& right) { typedef CompositeConstraint<L, R> C; return *new C(left, right, OrOperand<L,R>()); } class StringConstraint : public Constraint <StringConstraint> { private: typedef Constraint<StringConstraint> Base; const std::basic_regex <C> regex; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); StringConstraint (const S& aregex = W(""), const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), regex (aregex) { } virtual ~StringConstraint() {} bool ok(const S& s = W("")) const noexcept { return std::regex_search (s, regex); }; }; template <RangeCheckable T> class RangeConstraint : public Constraint <RangeConstraint<T>> { private: typedef Constraint<RangeConstraint<T>> Base; const T mmin; const T mmax; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); RangeConstraint (const T& amin, const T& amax, const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), mmin (amin), mmax (amax) { } RangeConstraint (const T& avalue, const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), mmin (avalue), mmax (avalue) { } virtual ~RangeConstraint() {} bool ok(const T& t = 0) const noexcept { return (t >= mmin) && (t <= mmax); }; }; } } #endif </DOCUMENT>
<DOCUMENT filename="cs.hpp">
#ifndef CS_HPP #define CS_HPP #include <array> #include <cstring> #include <string> #include <stdexcept> #include <string_view> #include <iostream> #include <sstream> #include "string_def.hpp" namespace pensar_digital { namespace cpplib { using S = std::basic_string<C>; using SView = std::basic_string_view<C>; using SIter = std::basic_string<C>::iterator; using SConstIter = std::basic_string<C>::const_iterator; using InStream = std::basic_istream<C>; using OutStream = std::basic_ostream<C>; using SStream = std::basic_stringstream<C>; using InStreamBuf = std::basic_streambuf<C>; using OutStreamBuf = std::basic_streambuf<C>; using InStreamBufIter = std::istreambuf_iterator<C>; using OutStreamBufIter = std::ostreambuf_iterator<C>; using InStringStream = std::basic_istringstream<C>; using OutStringStream = std::basic_ostringstream<C>; using InFStream = std::basic_ifstream<C>; using OutFStream = std::basic_ofstream<C>; using FStream = std::basic_fstream<C>; using InFileBuf = std::basic_filebuf<C>; using InFileBufIter = std::istreambuf_iterator<C>; using OutFileBuf = std::basic_filebuf<C>; using OutFileBufIter = std::ostreambuf_iterator<C>; inline void remove_accent(C* c) noexcept { switch (*c) { case W('á'): case W('à'): case W('ã'): case W('ä'): case W('â'): *c = W('a'); break; case W('é'): case W('è'): case W('ë'): case W('ê'): *c = W('e'); break; case W('í'): case W('ì'): case W('ï'): case W('î'): *c = W('i'); break; case W('ó'): case W('ò'): case W('õ'): case W('ö'): case W('ô'): *c = W('o'); break; case W('ú'): case W('ù'): case W('ü'): case W('û'): *c = W('u'); break; case W('ç'): *c = W('c'); break; case W('Á'): case W('À'): case W('Ã'): case W('Ä'): case W('Â'): *c = W('A'); break; case W('É'): case W('È'): case W('Ë'): case W('Ê'): *c = W('E'); break; case W('Í'): case W('Ì'): case W('Ï'): case W('Î'): *c = W('I'); break; case W('Ó'): case W('Ò'): case W('Õ'): case W('Ö'): case W('Ô'): *c = W('O'); break; case W('Ú'): case W('Ù'): case W('Ü'): case W('Û'): *c = W('U'); break; case W('Ç'): *c = W('C'); break; default: break; } } inline C copy_remove_accent(const C c) noexcept { C ch = c; remove_accent(&ch); return ch; } inline bool equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { if (case_sensitive) { if (accent_sensitive) { return c == c2; } else { return copy_remove_accent(c) == copy_remove_accent(c2); } } else { if (accent_sensitive) { return std::tolower(c) == std::tolower(c2); } else { return std::tolower(copy_remove_accent(c)) == std::tolower(copy_remove_accent(c2)); } } } inline bool less(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { if (case_sensitive) { if (accent_sensitive) { return c < c2; } else { return copy_remove_accent(c) < copy_remove_accent(c2); } } else { if (accent_sensitive) { return std::tolower(c) < std::tolower(c2); } else { return std::tolower(copy_remove_accent(c)) < std::tolower(copy_remove_accent(c2)); } } } inline bool not_equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return !equal(c, c2, case_sensitive, accent_sensitive); } template <typename C = char> inline bool greater(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return !less(c, c2, case_sensitive, accent_sensitive) && !equal(c, c2, case_sensitive, accent_sensitive); } inline bool less_equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return less(c, c2, case_sensitive, accent_sensitive) || equal(c, c2, case_sensitive, accent_sensitive); } inline bool greater_equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return greater(c, c2, case_sensitive, accent_sensitive) || equal(c, c2, case_sensitive, accent_sensitive); } template<size_t MIN = 0, size_t MAX = 20> class CS { public: using value_type = C; std::array<C, MAX> data; bool case_sensitive = false; bool accent_sensitive = false; inline static const size_t MAX_SIZE = MAX; inline static const size_t MAX_LENGTH = MAX - 1; inline static const size_t MIN_SIZE = MIN; const constexpr inline size_t size() const noexcept { return MAX; } void inline fill(C c) noexcept { data.fill(c); } void fill_null() noexcept { fill(NULL_CHAR); } CS() { fill_null(); } inline bool is_null_char(size_t index) const noexcept { return (data[index] == NULL_CHAR); } inline size_t length() const noexcept { return std::char_traits<C>::length(data.data()); } inline void copy(const C* s, size_t s_length, bool add_null_at_end = true, bool fill_null_before_copy = true) { if (s_length >= MAX) { std::string error = "String is too long. Max size is "; error += std::to_string(MAX); throw std::runtime_error(error); } if (s_length < MIN) { std::string error = "String is too short. Min size is "; error += std::to_string(MIN); throw std::runtime_error(error); } if (fill_null_before_copy) fill_null(); if (s_length > 0) std::memcpy(data.data(), s, s_length * sizeof(C)); if (add_null_at_end and (s_length >= 0)) data[s_length] = NULL_CHAR; } inline void copy(const C* str) { auto strlen = std::char_traits<C>::length(str); copy(str, strlen); } inline void copy(const S& str) { copy(str.c_str(), str.length()); } CS(const C* str) { copy(str); } CS(const S& str) { copy(str.c_str(), str.length()); } operator C* () const noexcept { size_t size = length() + 1; C* c = new C[size]; std::memcpy(c, data.data(), size); return c; } inline S to_string() const noexcept { return S(data.data()); } inline S str() const noexcept { return S(data.data()); } operator S() const noexcept { return to_string(); } inline size_t cmp_strlen(const CS& other) const noexcept { return length() - other.length(); } inline bool eq_strlen(const CS& other) const noexcept { return length() == other.length(); } inline bool empty() const noexcept { return length() == 0; } inline C& operator[] (const size_t index) const noexcept { return const_cast<C&>(data[index]); } inline C& at(const size_t index) const noexcept { return operator[](index); } bool operator== (const CS& other) const noexcept { bool result = eq_strlen(other); if (result) { auto strlen = length(); for (size_t i = 0; i < strlen; ++i) { if (!equal(data[i], other.data[i], case_sensitive, accent_sensitive)) { result = false; break; } } } return result; } bool operator!=(const CS& other) const noexcept { return !(*this == other); } bool operator<(const CS& other) const noexcept { bool result = less(data[0], other.data[0], case_sensitive, accent_sensitive); if (result) { auto strlen = length(); for (size_t i = 1; i < strlen; ++i) { if (!less(data[i], other.data[i], case_sensitive, accent_sensitive)) { result = false; break; } } } return result; } bool operator>(const CS& other) const noexcept { return other < *this; } bool operator<=(const CS& other) const noexcept { return !(other < *this); } bool operator>=(const CS& other) const noexcept { return !(*this < other); } CS& operator= (const S& str) noexcept { copy(str); return *this; } CS& operator= (const C* str) { copy(str); return *this; } CS& operator= (const std::array<C, MAX>& arr) noexcept { std::memcpy(data.data(), arr.data(), MAX * sizeof(C)); return *this; } CS& assign(const CS& other) { copy(other.data.data(), other.length(), ADD_NULL_AT_END); return *this; } CS& operator+= (const CS& other) { auto strlen = length(); auto other_strlen = other.length(); if (strlen + other_strlen > MAX) { std::string error = "CString is too long. Max size is "; error += std::to_string(MAX); throw std::runtime_error(error); } std::memcpy(data.data() + strlen, other.data.data(), other_strlen * sizeof(C)); data[strlen + other_strlen] = NULL_CHAR; return *this; } CS operator+ (const CS& other) { CS result = *this; result += other; return result; } OutStream& write(OutStream& os) const noexcept { os << data.data(); return os; } InStream& read(InStream& is) { S s; is >> s; copy(s); return is; } }; template <size_t MIN = 0, size_t MAX> OutStream& operator<< (OutStream& os, const CS<MIN, MAX>& cs) { return cs.write(os); } template <size_t MIN = 0, size_t MAX> InStream& operator>> (InStream& is, CS<MIN, MAX>& cs) { return cs.read(is); } template<int N, int N2> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const CS<0, N2>& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const CS<N>& rhs) - lhs must be of size N > 0")); CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs.data.begin(), rhs.data.end(), result.data.begin() + N); return result; } template<int N, int N2, typename Char = char> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const S& rhs) { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const S& rhs) - lhs must be of size N > 0")); if (rhs.size() != N2) { throw std::runtime_error(W("CS<N> operator+ (const CS<N>& lhs, const std::basic_string<Char>& rhs) - rhs must be of size N2")); } CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs.begin(), rhs.end(), result.data.begin() + N); return result; } template<int N, int N2> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const C* rhs) { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const Char* rhs) - lhs must be of size N > 0")); if (std::char_traits<C>::length(rhs) != N2) { throw std::runtime_error(W("CS<N> operator+ (const CS<N>& lhs, const Char* rhs) - rhs must be of size N2")); } CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs, rhs + N, result.data.begin() + N); return result; } template<int N, size_t N2> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const std::array<C, N2>& rhs) noexcept { static_assert (N2 > 0, W("CS<N> operator+ (const CS<N>& lhs, const std::array<Char, N2>& rhs) - rhs must be of size > 0")); static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const std::array<Char, N2>& rhs) - lhs must be of size > 0")); CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs.begin(), rhs.end(), result.data.begin() + N); return result; } template<size_t N> CS<0, N + 1> operator+ (const S& lhs, const CS<0, N>& rhs) { size_t min_size = lhs.length() + rhs.length() + 1; if (N < min_size) std::runtime_error("CS<N> operator+ (const std::basic_string<Char>& lhs, const CS<N>& rhs) - rhs must be of size > " + std::to_string(min_size)); CS<0, N + 1> result; std::copy(lhs.begin(), lhs.end(), result.data.begin()); std::copy(rhs.data.begin(), rhs.data.begin() + rhs.length(), result.data.begin() + lhs.length()); return result; } template<int N, int N2> CS<0, N + N2> operator+ (const std::array<C, N>& lhs, const CS<0, N2>& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const std::array<Char, N>& lhs, const CS<N2>& rhs) - lhs must be of size > 0")); CS<0, N + N2> result; std::copy(lhs.begin(), lhs.end(), result.data.begin()); std::copy(rhs.data.begin(), rhs.data.end(), result.data.begin() + N); return result; } template<int N> CS<0, N + sizeof(C)> operator+ (const CS<0, N>& lhs, const C& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const Char& rhs) - lhs must be of size > 0")); CS<0, N + sizeof(C)> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); result.data[N] = rhs; return result; } template<int N> CS<0, N + sizeof(C)> operator+ (const C& lhs, const CS<0, N>& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const Char& lhs, const CS<N>& rhs) - lhs must be of size > 0")); CS<0, N + sizeof(C)> result; result.data[0] = lhs; std::copy(rhs.data.begin(), rhs.data.end(), result.data.begin() + 1); return result; } template<int N> std::array<C, N>& assign(std::array<C, N>& lhs, const std::array<C, N>& rhs) noexcept { std::memcpy(lhs.data(), rhs.data(), N); return lhs; } } } #endif </DOCUMENT>
<DOCUMENT filename="distance.hpp">
#ifndef DISTANCE_HPP_INCLUDED #define DISTANCE_HPP_INCLUDED #undef min #include <algorithm> #include "s.hpp" namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; #include <algorithm> #include <vector> inline size_t distance(const S& source, const S& target) { const size_t n = source.length(); const size_t m = target.length(); if (n == 0) return m; if (m == 0) return n; std::vector<size_t> row1(m + 1); std::vector<size_t> row2(m + 1); std::vector<size_t> row3(m + 1); for (size_t j = 0; j <= m; j++) { row2[j] = j; } for (size_t i = 1; i <= n; i++) { row3[0] = i; for (size_t j = 1; j <= m; j++) { const char s_i = source[i - 1]; const char t_j = target[j - 1]; size_t cost = (s_i == t_j) ? 0 : 1; row3[j] = std::min(std::min(row3[j - 1] + 1, row2[j] + 1), row2[j - 1] + cost); if (i > 1 && j > 1 && s_i == target[j - 2] && t_j == source[i - 2]) { row3[j] = std::min(row3[j], row1[j - 2] + 1); } } row1 = row2; row2 = row3; } return row2[m]; } #ifndef LESS_DIFF #define LESS_DIFF struct LessDistance { S reference; LessDistance (const S& s) : reference(s) {} bool operator () (const S& left, const S& right) { return pd::distance (left, reference) < pd::distance (right, reference); } }; #endif template <class Container = std::vector<S>> typename Container::value_type min_distance (const S& s, const Container& c) { INVALID_ARGUMENT(c.size () == 0, "c.size () = 0"); typename Container::const_iterator it = c.begin (); typename Container::value_type min = *it; int min_dist = pd::distance (min, s); for (const auto& it : c) { int dist = pd::distance (it, s); if (dist < min_dist) { min = it; min_dist = dist; } } return min; } template <class Container = std::vector<C*>> typename Container::value_type min_distance (const C* s, const Container& c) { return min_distance (S(s), c); } template <class Container = std::map<S, S>> typename Container::value_type min_distance_map_key (const S& s, const Container& c, int max_distance = std::numeric_limits<int>::max()) { INVALID_ARGUMENT(c.size () == 0, "c.size () = 0"); typename Container::const_iterator it = c.begin (); std::pair<typename Container::key_type, typename Container::mapped_type> minimum(it->first, it->second); int min_dist = pd::distance (minimum.first, s); for (; it != c.end (); ++it) { int dist = pd::distance (it->first, s); if (dist < min_dist) { minimum = *it; min_dist = dist; } } std::pair<typename Container::key_type, typename Container::mapped_type> nope; return (min_dist <= max_distance) ? minimum : nope; } template <class Container = std::vector<S>, class OutContainer = std::vector<S>> void min_distance (const S& s, const Container& c, OutContainer& out, unsigned max_elements = 0) { INVALID_ARGUMENT(c.size () == 0, "c.size () = 0"); LessDistance ld (s); using MSet = std::multiset<S, LessDistance>; MSet mset (ld); for (const auto& it : mset) { mset.insert (it); } if (max_elements == 0) std::copy (mset.begin (), mset.end (), std::back_inserter(out)); else { typename MSet::iterator fim = mset.begin (); while (max_elements--) ++fim; std::copy (mset.begin (), fim, std::back_inserter(out)); } } template <class Container = std::vector<C*>, class OutContainer = std::vector<C*>> void min_distance (const C* s, const Container& c, OutContainer& out, unsigned max_elements = 0) { min_distance (S(s), c, out, max_elements); } } } #endif </DOCUMENT>
<DOCUMENT filename="encoding.hpp">
#ifndef ENCODE_HPP #define ENCODE_HPP #include "cs.hpp" #include "bool.hpp" #include "array.hpp" #include "endian.hpp" namespace pensar_digital { namespace cpplib { using BomBytes = CArray<4>; inline static BomBytes NO_BOM = { 0, 0, 0, 0 }; inline static BomBytes BOM_UTF_8 = { 0xEF, 0xBB, 0xBF, 0x00 }; inline static BomBytes BOM_UTF_16_BE = { 0xFE, 0xFF, 0x00, 0x00 }; inline static BomBytes BOM_UTF_16_LE = { 0xFF, 0xFE, 0x00, 0x00 }; inline static BomBytes BOM_UTF_32_BE = { 0x00, 0x00, 0xFE, 0xFF }; inline static BomBytes BOM_UTF_32_LE = { 0xFF, 0xFE, 0x00, 0x00 }; inline static void init_bom () { NO_BOM._data_size = 0; BOM_UTF_8._data_size = 3; BOM_UTF_16_BE._data_size = 2; BOM_UTF_16_LE._data_size = 2; BOM_UTF_32_BE._data_size = 4; BOM_UTF_32_LE._data_size = 4; } struct Encoding {}; template <size_t NameSize, Bool HasBOM = Bool::T> struct EncodingBase : public Encoding { CS<NameSize> name; Endian endian; BomBytes bom; }; const EncodingBase< 5, Bool::F> ASCII = { Encoding (), "ASCII" , Endian::NOT_APPLICABLE, NO_BOM }; const EncodingBase< 5, Bool::F> UTF_8 = { Encoding (), "UTF-8" , Endian::NOT_APPLICABLE, NO_BOM }; const EncodingBase< 9, Bool::T> UTF_8_BOM = { Encoding (), "UTF-8-BOM" , Endian::NOT_APPLICABLE, BOM_UTF_8 }; const EncodingBase< 9, Bool::F> UTF_16_BE = { Encoding (), "UTF-16-BE" , Endian::BIG , NO_BOM }; const EncodingBase<13, Bool::T> UTF_16_BE_BOM = { Encoding (), "UTF-16-BE-BOM", Endian::BIG , BOM_UTF_16_BE }; const EncodingBase< 9, Bool::F> UTF_16_LE = { Encoding (), "UTF-16-LE" , Endian::LITTLE , NO_BOM }; const EncodingBase<13, Bool::T> UTF_16_LE_BOM = { Encoding (), "UTF-16-LE-BOM", Endian::LITTLE , BOM_UTF_16_LE }; const EncodingBase< 9, Bool::F> UTF_32_BE = { Encoding (), "UTF-32-BE" , Endian::BIG , NO_BOM }; const EncodingBase<13, Bool::T> UTF_32_BE_BOM = { Encoding (), "UTF-32-BE-BOM", Endian::BIG , BOM_UTF_32_BE }; const EncodingBase< 9, Bool::F> UTF_32_LE = { Encoding (), "UTF-32-LE" , Endian::LITTLE , NO_BOM }; const EncodingBase<13, Bool::T> UTF_32_LE_BOM = { Encoding (), "UTF-32-LE-BOM", Endian::LITTLE , BOM_UTF_32_LE }; }; } #endif </DOCUMENT>
<DOCUMENT filename="endian.hpp">
#ifndef ENDIAN_HPP #define ENDIAN_HPP #include "concept.hpp" #include <cstdint> namespace pensar_digital { namespace cpplib { struct Endian; struct Endian { int8_t _value; static const int8_t NOT_APPLICABLE = -2; static const int8_t UNKNOWN = -1; static const int8_t LITTLE = static_cast<int8_t> (std::endian::little); static const int8_t BIG = static_cast<int8_t> (std::endian::big ); static const int8_t NATIVE = static_cast<int8_t> (std::endian::native); Endian() = default; constexpr Endian (int_fast8_t value) : _value(value) {} constexpr Endian (std::endian value) : _value(value == std::endian::little ? LITTLE : (value == std::endian::big ? BIG : NATIVE)) {} constexpr operator Endian() const { return static_cast<std::endian>(_value); } constexpr operator int_fast8_t() const { return _value; } }; static_assert(std::is_trivially_copyable<Endian>::value, "Endian must be trivially copyable."); } } #endif </DOCUMENT>
<DOCUMENT filename="equal.hpp">
#ifndef EQUAL_HPP #define EQUAL_HPP #include "concept.hpp" #include "constant.hpp" #include <type_traits> #include <cstring> namespace pensar_digital { namespace cpplib { template <class T> concept TriviallyHashComparable = HasStdLayoutTriviallyCopyableData<T> && pensar_digital::cpplib::Hashable<T>; struct HashComparableTag {}; struct DataComparableTag {}; struct TriviallyComparableTag {}; struct StdLayoutTriviallyCopyableTag {}; template <class T> using EqualDispatchTag = std::conditional_t< pensar_digital::cpplib::TriviallyHashComparable<T>, pensar_digital::cpplib::HashComparableTag, std::conditional_t< pensar_digital::cpplib::HasStdLayoutTriviallyCopyableData<T>, pensar_digital::cpplib::DataComparableTag, std::conditional_t< std::is_trivially_copyable_v<T>, pensar_digital::cpplib::StdLayoutTriviallyCopyableTag, pensar_digital::cpplib::TriviallyComparableTag > > >; template <TriviallyHashComparable T> bool equal_impl(const T& l, const T& r, HashComparableTag) { if (l.hash() != r.hash()) return false; return equal_impl(l, r, DataComparableTag{}); } template <HasStdLayoutTriviallyCopyableData T> bool equal_impl(const T& l, const T& r, DataComparableTag) { if (&l == &r) return true; return std::memcmp(l.data(), r.data(), l.data_size()) == 0; } bool equal_impl(const auto& l, const auto& r, TriviallyComparableTag) { return l == r; } template <StdLayoutTriviallyCopyable T> bool equal_impl(const T& l, const T& r, StdLayoutTriviallyCopyableTag) { if (&l == &r) return true; return std::memcmp(&l, &r, sizeof(l)) == 0; } template <typename T> bool equal(const T& l, const T& r) { return equal_impl(l, r, EqualDispatchTag<T>{}); } } } #endif </DOCUMENT>
<DOCUMENT filename="error.hpp">
 #ifndef ERROR_HPP_INCLUDED #define ERROR_HPP_INCLUDED #include "string_def.hpp" #include "object.hpp" #include "version.hpp" #include "log.hpp" #include <stdexcept> #include <sstream> namespace pensar_digital { namespace cpplib { class Exception : public std::exception { public: Exception (const S& message): message (message) {} const S what_error () const noexcept { #ifdef WIDE_CHAR std::string s = what(); return to_wstring (s); #else return what (); #endif } private: S message; }; #define INVALID_ARGUMENT(condition,message) \ if (condition)\ {\ SStream ss;\ ss << __FILE__ << '\t' << __LINE__ << '\t' << message << std::endl;\ std::cerr << ss.str ();\ std::cerr.flush ();\ throw std::invalid_argument (ss.str ());\ }; #define WINVALID_ARGUMENT(condition,message) \ if (condition)\ {\ std::wstringstream ss;\ ss << WFILE << L'\t' << WLINE << L'\t' << message << std::endl;\ std::wcerr << ss.str ();\ std::wcerr.flush ();\ throw std::invalid_argument (ss.str ());\ }; class Error : public Object { public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); Error (const S& error_msg, const Id aid = 0): Object (aid), error_message (error_msg) {} const S& get_error_message () const { return error_message; } ; void set_error_message (const S& error_msg) { error_message = error_msg; }; void append_error_message (const S& error_msg) { error_message = error_message + error_msg; }; virtual InStream& read (InStream& is) { Id id; is >> id >> error_message; set_id (id); return is; }; virtual OutStream& write (OutStream& os) const { os << error_message << id (); return os; }; private: S error_message; }; inline OutStream& operator<< (OutStream& os, const Error& e) { return e.write (os); } inline InStream& operator>> (InStream& is, Error& e) { return e.read (is); } class UnsupportedVersion : public Error { public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); UnsupportedVersion (const Version v): Error (W("Unsupported version number: ") + v.to_string ()){}; }; inline static void log_and_throw(const S& error_msg = W("")) { LOG(error_msg); throw Error(error_msg); } } } #endif </DOCUMENT>
<DOCUMENT filename="factory.hpp">
 #ifndef FACTORY_HPP_INCLUDED #define FACTORY_HPP_INCLUDED #include <memory> #include <type_traits> #include <vector> #include <cassert> namespace pensar_digital { namespace cpplib { template <class T, typename... Args> class NewFactory { public: typedef typename std::shared_ptr<T> P; virtual ~NewFactory (){} virtual P get(const Args& ... args) const { return std::make_shared<T> (args ...); } private: }; template <class T, typename... Args> class MockupFactory: public NewFactory <T, Args...> { public: using P = NewFactory<T, Args...>::P; MockupFactory(T* amockup_pointer) : mockup_pointer(amockup_pointer) { }; virtual ~MockupFactory() {} virtual P get(const Args& ... args) const { std::shared_ptr<T> ptr(mockup_pointer); return ptr; } private: T* mockup_pointer; }; template <class T, typename... Args> class PoolFactory : public NewFactory <T, Args...> { private: using P = NewFactory<T, Args...>::P; void fill_pool (const size_t& pool_size, const Args& ... args) { for (size_t i = 0; i < pool_size; ++i) { std::shared_ptr<T>&& ptr = std::make_shared<T>(args ...); pool.push_back(std::move(ptr)); } available_count = pool_size; } void add (const size_t& count, const Args& ... args) { for (size_t i = 0; i < count; ++i) { std::shared_ptr<T>&& ptr = std::make_shared<T>(args ...); pool.push_back(ptr); } available_count += count; } public: PoolFactory (const size_t initial_pool_size, const size_t a_refill_size, const Args& ... args) : available_count (0), refill_size(a_refill_size) { fill_pool(initial_pool_size, args ...); }; PoolFactory(const Args& ... args) : PoolFactory (10, 10, args ...) { }; virtual ~PoolFactory() {} virtual P get(const Args& ... args) { for (auto& ptr : pool) { if (ptr.use_count () < 2) { ptr->initialize (args ...); available_count--; return * new (std::shared_ptr<T>) (ptr); } } assert(available_count <= 0); add (refill_size, args ...); return get (args ...); } size_t get_available_count() const { return available_count; } size_t get_pool_size() const { return pool.size(); } size_t get_refill_size() const { return refill_size; } void set_refill_size(const size_t& value) { refill_size = value; } void reset(const size_t& initial_pool_size, const size_t& a_refill_size, const Args& ... args) { pool.clear(); fill_pool(initial_pool_size, args ...); available_count = initial_pool_size; refill_size = a_refill_size; } private: std::vector<typename std::shared_ptr<T>> pool; size_t available_count; size_t refill_size; }; template <class T, typename... Args> class SingletonFactory : public NewFactory <T, Args...> { private: using P = NewFactory<T, Args...>::P; public: SingletonFactory (const Args& ... args) : singleton (std::make_shared<T>(args ...)) { }; virtual ~SingletonFactory () {} virtual P get (const Args& ... args) const { return singleton; } private: std::shared_ptr<T> singleton; }; template <class T, typename... Args> class Factory { public: using P = NewFactory<T, Args...>::P; Factory (const size_t pool_size, const size_t refill_size, const Args& ... args) { mfactory_ptr = std::make_shared<PoolFactory<T, Args...>>(pool_size, refill_size, args ...); }; virtual ~Factory() { } virtual P get (const Args& ... args) { return mfactory_ptr->get(args ...); } NewFactory<T, Args...>& get_factory () const { return *mfactory_ptr.get(); } void set_factory (const NewFactory<T, Args...>* afactory) { mfactory_ptr = afactory; } private: std::shared_ptr<NewFactory<T, Args...>> mfactory_ptr; }; } } #endif </DOCUMENT>
<DOCUMENT filename="file.hpp">
 #ifndef FILE_HPP #define FILE_HPP #ifdef CODE_GEAR #pragma hdrstop #endif #include <fstream> #include <string> #include <filesystem> #include <cstdio> #include <cerrno> #include <cstring> #include <functional> #include "s.hpp" #include "object.hpp" #include "path.hpp" #include "version.hpp" #include "generator.hpp" #include "memory_buffer.hpp" #include "random_util.hpp" #include "log.hpp" #include "error.hpp" #include "icu_util.hpp" #include "constant.hpp" #include "encoding.hpp" namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; namespace fs = std::filesystem; class TextMode; class BinMode; class OpenMode { public: using Mode = std::ios::openmode; private: Mode _mode; public: OpenMode(const std::ios::openmode mode) : _mode(mode) {} inline bool is_bin_mode (const Mode mode) const noexcept { return mode & std::ios::binary; } inline bool is_bin_mode ( ) const noexcept { return is_bin_mode (_mode) ; } inline bool is_text_mode (const Mode mode) const noexcept { return ! is_bin_mode (mode) ; } inline bool is_text_mode ( ) const noexcept { return !is_bin_mode () ; } inline const Mode mode() const noexcept { return _mode; } inline S to_string () const noexcept { S s; if (_mode & std::ios::in ) s += W("in"); if (_mode & std::ios::out ) s += (s.empty() ? W("out" ) : W(" | out" )); if (_mode & std::ios::binary ) s += (s.empty() ? W("binary") : W(" | binary")); if (_mode & std::ios::app ) s += (s.empty() ? W("app" ) : W(" | app" )); if (_mode & std::ios::ate ) s += (s.empty() ? W("ate" ) : W(" | ate" )); if (_mode & std::ios::trunc ) s += (s.empty() ? W("trunc" ) : W(" | trunc" )); } inline const C* c_str() const noexcept { C* buffer = new C[to_string().size() + 1]; return buffer; } inline bool operator == (const OpenMode& mode) const noexcept { return _mode == mode._mode; } inline bool operator != (const OpenMode& mode) const noexcept { return _mode != mode._mode; } inline bool operator == (const Mode mode) const noexcept { return _mode == mode; } inline bool operator != (const Mode mode) const noexcept { return _mode != mode; } inline operator Mode() const noexcept { return _mode; } inline operator S() const noexcept { return to_string(); } inline operator const C* () const noexcept { return c_str(); } static const BinMode BIN_READ; static const BinMode BIN_WRITE; static const BinMode BIN_APPEND; static const BinMode BIN_ATE; static const BinMode BIN_RW; static const BinMode BIN_RW_ATE; static const TextMode TEXT_READ; static const TextMode TEXT_WRITE; static const TextMode TEXT_APPEND; static const TextMode TEXT_ATE; static const TextMode TEXT_RW; static const TextMode TEXT_RWA; static const TextMode TEXT_RW_ATE; static const BinMode DEFAULT_BIN_MODE; static const TextMode DEFAULT_TEXT_MODE; static const OpenMode DEFAULT_OPEN_MODE; }; class BinMode : public OpenMode { public: BinMode (const OpenMode::Mode mode) : OpenMode (mode) { if (!is_bin_mode (mode)) throw Error(W("BinMode::BinMode (): Error: Invalid binary mode: ") + mode); } }; class TextMode : public OpenMode { public: TextMode (const Mode mode) : OpenMode(mode) { if (!is_text_mode(mode)) throw Error(W("TextMode::TextMode(): Error: Invalid text mode: ") + mode); } }; inline const BinMode OpenMode::BIN_READ = BinMode(std::ios::binary | std::ios::in); inline const BinMode OpenMode::BIN_WRITE = BinMode(std::ios::binary | std::ios::out); inline const BinMode OpenMode::BIN_APPEND = BinMode(std::ios::binary | std::ios::app); inline const BinMode OpenMode::BIN_ATE = BinMode(std::ios::binary | std::ios::ate); inline const BinMode OpenMode::BIN_RW = BinMode(std::ios::binary | std::ios::in | std::ios::out); inline const BinMode OpenMode::BIN_RW_ATE = BinMode(std::ios::binary | std::ios::in | std::ios::out | std::ios::ate); inline const TextMode OpenMode::TEXT_READ = TextMode(std::ios::in); inline const TextMode OpenMode::TEXT_WRITE = TextMode(std::ios::out); inline const TextMode OpenMode::TEXT_APPEND = TextMode(std::ios::app); inline const TextMode OpenMode::TEXT_ATE = TextMode(std::ios::ate); inline const TextMode OpenMode::TEXT_RW = TextMode(std::ios::in | std::ios::out); inline const TextMode OpenMode::TEXT_RWA = TextMode(std::ios::in | std::ios::out | std::ios::app); inline const TextMode OpenMode::TEXT_RW_ATE = TextMode(std::ios::in | std::ios::out | std::ios::ate); inline const BinMode OpenMode::DEFAULT_BIN_MODE = BIN_RW; inline const TextMode OpenMode::DEFAULT_TEXT_MODE = TEXT_RWA; inline const OpenMode OpenMode::DEFAULT_OPEN_MODE = DEFAULT_BIN_MODE; class File : public Object { protected: OpenMode _mode; Path _fullpath; std::fstream* _file; public: inline static const size_t MAX_BUFFER_SIZE = 1024 ^ 3; enum Seek { SET = SEEK_SET, CUR = SEEK_CUR, END = SEEK_END }; inline S s_io_error_msg (const errno_t error) const { C msg[icu::BUFFER_SIZE]; #ifdef WIDE_CHAR strerror_s(msg, icu::BUFFER_SIZE, error); icu::utf8_char_ptr_to_wchar_t_ptr(msg, sys_err_msg); #else if (msg == nullptr) log_and_throw(W("File::s_io_error_msg(): Error: Could not convert error message to wide char.")); else strerror_s(msg, icu::BUFFER_SIZE, error); #endif msg[icu::BUFFER_SIZE - 1] = 0; return S(msg); } decltype(File::_file)& file_open (const Path& file_name, OpenMode mode) { #ifdef WIDE_CHAR err = _wfopen_s(&_file, file_name.c_str(), mode.c_str()); #else _file->open (_fullpath.str (), mode); #endif if (_file->fail ()) log_and_throw(S(W("File::file_open(): Error: Could not open file "))); return _file; } public: inline File(const Path& full_path = W("."), const Id id = NULL_ID, const OpenMode mode = OpenMode::DEFAULT_BIN_MODE) : _fullpath(full_path), Object(id), _mode(mode) { _fullpath.create_dir (); _file = new std::fstream (); file_open (_fullpath, mode); } inline virtual ~File() noexcept { close(); free(_file); } inline void close() noexcept { if (is_open()) { _file->close (); if (_file->fail ()) { log_and_throw (S("File::~File(): Error: Could not close file ") + _fullpath.str()); } } } inline bool exists() const { return _fullpath.exists(); } inline const Path& fullpath() const noexcept { return _fullpath; } inline bool is_open() const noexcept { return _file->is_open (); } inline bool is_bin_read () const noexcept { return _mode == OpenMode::BIN_READ ; } inline bool is_bin_write () const noexcept { return _mode == OpenMode::BIN_WRITE ; } inline bool is_bin_rw () const noexcept { return _mode == OpenMode::BIN_RW_ATE; } inline bool is_text_read () const noexcept { return _mode == OpenMode::TEXT_READ ; } inline bool is_text_write () const noexcept { return _mode == OpenMode::TEXT_WRITE ; } inline bool is_text_rw () const noexcept { return _mode == OpenMode::TEXT_RW_ATE; } inline bool eof () const noexcept { return _file->eof () != 0; } inline bool fail () const noexcept { return _file->fail () != 0; } inline const C* c_str() const noexcept { S s = _fullpath.str(); } inline bool remove() { if (is_open()) close(); return fs::remove(_fullpath); } inline virtual bool initialize(const Path& afull_path = CURRENT_DIR, const Id id = NULL_ID, const OpenMode mode = OpenMode::DEFAULT_OPEN_MODE) noexcept { _fullpath = afull_path; _mode = mode; Object::set_id(id); return true; } inline virtual OpenMode get_mode() const noexcept { return _mode; } inline virtual S debug_string() const noexcept { return Object::debug_string() + W(" path = ") + _fullpath.str(); } inline void log_if_error (const errno_t error, const S& error_msg = W("")) const noexcept { if (error != 0) { S errmsg = error_msg + W(" in file ") + _fullpath.to_string() + W (" ") + s_io_error_msg (error); LOG(errmsg); } } inline void log_and_throw_if_error(const errno_t error, const S& error_msg = W("")) const { if (error != 0) { S errmsg = error_msg + W(" in file ") + _fullpath.to_string() + W(" ") + s_io_error_msg(error); LOG(errmsg); throw Error (errmsg); } } inline void move_cursor (FILE* f, const long pos, const Seek seek = Seek::SET) const { errno_t err = fseek (f, pos, seek); if (err != 0) { S error_msg = W("File::move_cursor(): Error: Could not move cursor to position."); log_and_throw_if_error(err, error_msg); } } inline void move_to_start (FILE* f) const { move_cursor (f, 0, Seek::SET); } inline void move_to_end (FILE* f) const { move_cursor (f, 0, Seek::END); } long position (FILE* f) const { long pos = ftell (f); if (pos == -1) { S error_msg = W("File::position(): Error: Could not get file position "); log_and_throw_if_error(errno, error_msg); } return pos; } inline void set_binary_mode (FILE* f) noexcept { long pos = 0; if (is_open()) { long pos = position (f); close(); } _mode = OpenMode::BIN_RW; open(); if (pos > 0) move_cursor (f, pos); } inline void set_text_mode (FILE* f) { long pos = 0; if (is_open()) { long pos = position (f); close(); } _mode = OpenMode::TEXT_RW; open(); if (pos > 0) move_cursor (f, pos); } inline decltype(_file)& open (const OpenMode& mode = OpenMode::DEFAULT_OPEN_MODE) { _mode = mode; if (!is_open()) { _file->open (_fullpath, _mode); } return _file; } inline size_t size() const noexcept { return fs::file_size(_fullpath); } inline size_t size (FILE* f) const noexcept { move_to_end (f); long size = ftell(f); if (size == -1) { S error_msg = W("TextFile::read(): Error: Could not get file size "); LOG(error_msg); } return size; } decltype(_file)& get_stream() { open(); return _file; } }; class TextFile : public File { private: public: inline static const Version::Ptr VERSION = Version::get(1, 1, 1); TextFile(const Path& full_path, const S& content = EMPTY, const TextMode mode = OpenMode::DEFAULT_TEXT_MODE, const Id id = NULL_ID) : File(full_path, id, mode) { if (File::exists()) { if (content != EMPTY) append(content); else { open (mode); } } else { open (mode); write(content); File::close(); } } inline virtual ~TextFile() = default; virtual bool get_char(C* c) { if (!is_open() || !_mode.is_text_mode()) return false; *c = _file->get(); return *c != EOF; } inline bool read_line(std::string& line) { if (!is_open() || !_mode.is_text_mode ()) return false; std::ifstream file_stream(_fullpath.str()); if (!file_stream.is_open()) return false; if (std::getline(file_stream, line)) return true; return false; } inline TextFile& write (const S& content, bool flushes = true) { if (! File::is_open()) File::open (); _file->write(content.c_str(), content.size()); if (fail ()) { log_and_throw (S(W("TextFile::write(): Error: Could not write to the file "))); } if (flushes) { _file->flush(); if (fail()) { log_and_throw(S(W("TextFile::write(): Error: Could not flush the file "))); } } return *this; } inline TextFile& append (const S& content) { if (! File::is_open()) File::open (); write (content); return *this; } inline S fullpath_to_string() const noexcept { return File::_fullpath.to_string (); } inline operator S() const noexcept { return to_string(); } inline S read() { if (! File::is_open()) open (OpenMode::TEXT_READ); size_t file_size = size (); size_t count = file_size / sizeof(C); C* content = new C[count + 1]; memset(content, 0, count + 1); _file->seekg(0, std::ios::beg); size_t read_count = _file->read(content, count).gcount(); if (read_count != count) { delete[] content; S error_msg = W("TextFile::read(): Error: Could not read the file "); log_and_throw (error_msg); } #pragma warning(suppress:6001) return S(content); } }; class RandomFileNameGenerator { private: inline static const size_t DEFAULT_LENGTH = 8; inline static const S DEFAULT_TEXT_FILE_EXTENSION = W("txt"); inline static const S DEFAULT_BINARY_FILE_EXTENSION = W("bin"); enum class ExtensionType { FIXED, RANDOM, NONE, NUMERIC_SEQUENCE, CHAR_SEQUENCE, FUNCTION }; inline static const ExtensionType DEFAULT_EXTENSION_TYPE = ExtensionType::FIXED; typedef std::function<S()> CUSTOM_EXT_FUNCTION; inline static const CUSTOM_EXT_FUNCTION NULL_CUSTOM_EXT_FUNCTION = []() { return EMPTY; }; ExtensionType mextension_type; S mextension; inline static const size_t MAX_FULL_NAME_LENGTH = 255; typedef Generator<RandomFileNameGenerator, size_t> G; G generator; CUSTOM_EXT_FUNCTION mcustom_ext_function; inline static S random_string(const size_t len) { static const S CHARS = W("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"); Random<size_t> r(0, CHARS.size() - 1); S s; size_t i = len; s.reserve(i); typename S::value_type c = CHARS[r()]; size_t count = 1000; while (c >= '0' && c <= '9') { c = CHARS[r()]; if (--count == 0) { S error_msg = W("RandomFileNameGenerator::random_string(): Error: Could not generate a random string after 1000 tries."); LOG(error_msg); runtime_error(error_msg); } } s += c; --i; while (i--) s += CHARS[r ()]; return s; } inline S get_extension() const { switch (mextension_type) { case ExtensionType::FIXED: return mextension; case ExtensionType::RANDOM: return random_string(DEFAULT_LENGTH); case ExtensionType::NONE: return EMPTY; case ExtensionType::CHAR_SEQUENCE: return EMPTY; case ExtensionType::FUNCTION: return mcustom_ext_function(); default: return EMPTY; } } public: inline RandomFileNameGenerator (const ExtensionType ext_type = DEFAULT_EXTENSION_TYPE, const S& extension = DEFAULT_TEXT_FILE_EXTENSION, const CUSTOM_EXT_FUNCTION& custom_ext_function = NULL_CUSTOM_EXT_FUNCTION) : mextension_type(ext_type), mextension(extension), mcustom_ext_function(custom_ext_function) { } inline Path operator() (const S& name_prefix = W(""), const S& name_suffix = W(""), const S& extension = DEFAULT_TEXT_FILE_EXTENSION, const Path& path = TMP_DIR) { return path / (name_prefix + random_string(DEFAULT_LENGTH) + name_suffix + W(".") + get_extension()); } }; class TmpTextFile : public TextFile { public: inline static const Version::Ptr VERSION = Version::get(1, 1, 1); inline TmpTextFile (const S& file_name = EMPTY, const S& content = EMPTY, const Id id = null_value<Id>()) : TextFile(TMP_PATH / file_name, content, OpenMode::DEFAULT_TEXT_MODE, id) { } inline TmpTextFile (const C* file_name = EMPTY, const C* content = EMPTY, const Id id = null_value<Id>()) : TextFile (S(file_name), S(content), OpenMode::DEFAULT_TEXT_MODE, id) {} inline void log_error() { LOG(W("Failed to remove temporary file ") + File::_fullpath.s ()); } inline virtual ~TmpTextFile() { if (!File::remove()) { log_error(); } } }; class BinaryFile : public File { private: public: inline static const Version::Ptr VERSION = Version::get(1, 1, 1); private: inline BinaryFile (const Path& full_path, const OpenMode mode = OpenMode::DEFAULT_BIN_MODE, const BytePtr data = nullptr, const size_t size = 0, const Id id = null_value<Id>() ) : File (full_path, id, mode) { append (data, size); } inline BinaryFile (const Path& full_path, const BytePtr data = nullptr, const size_t size = 0, const Id id = null_value<Id>()) : BinaryFile(full_path, OpenMode::DEFAULT_BIN_MODE, data, size, id) { } inline virtual ~BinaryFile() { close(); } inline BinaryFile& append(const BytePtr data = nullptr, const size_t size = 0) { static_assert (sizeof(char) == sizeof(std::byte), W("sizeof(char) != sizeof(Byte)")); if ((data != nullptr) && (size > 0)) { if (! is_open()) open (OpenMode::BIN_RW_ATE); _file->write(reinterpret_cast<const char*>(data), size); if (_file->fail ()) { S error_msg = W("BinaryFile::append(): Error: Could not append data to the file "); log_and_throw_if_error(errno, error_msg); } } return *this; } private: MemoryBuffer data; }; extern InStream& operator >> (InStream& is, File& file); extern OutStream& operator << (OutStream& os, const File& file); } } #endif </DOCUMENT>
<DOCUMENT filename="generator.hpp">
 #ifndef GENERATOR_HPP_INCLUDED #define GENERATOR_HPP_INCLUDED #include "object.hpp" #include "constant.hpp" #include "string_def.hpp" #include "s.hpp" #include "factory.hpp" #include "error.hpp" #include <memory> #include <iosfwd> #include <bit> #include <concepts> namespace pensar_digital { namespace cpplib { template <typename Type = Id, typename T = Id> class Generator : public Object { public: using UsedByType = Type; using IdType = T; using G = Generator<Type, T>; using GeneratorPtr = std::shared_ptr<G>; using Factory = pd::Factory<G, T, T, T>; inline static Factory mfactory = { 3, 10, null_value<T>(), 0, 1}; private: struct Data : public pd::Data { T minitial_value; T mvalue; T mstep; Data(T initial_value = 0, T step = 1) : minitial_value(initial_value), mvalue(initial_value), mstep(step) {} }; Data mdata; public: inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("Generator"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } using DataType = Data; inline static constexpr size_t DATA_SIZE = sizeof(mdata); inline static constexpr size_t SIZE = DATA_SIZE + sizeof(INFO) + Object::SIZE; inline const pd::Data* generator_data () const noexcept { return &mdata ; } virtual const pd::Data* data() const noexcept { return &mdata; } virtual size_t data_size() const noexcept { return DATA_SIZE; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)&mdata; } inline const BytePtr generator_data_bytes() const noexcept { return (BytePtr)&mdata; } inline static const Data NULL_DATA = { null_value<T>(), null_value<T>() }; inline virtual pd::Data* get_null_data() const noexcept { return (pd::Data*)(&NULL_DATA); } Generator (T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept : Object(aid == null_value<T>() ? 0 : aid), mdata(initial_value, step) {}; Generator(MemoryBuffer& mb) noexcept : Object(mb) { assign_without_parent (mb); } virtual ~Generator () = default; inline G& assign_without_parent (MemoryBuffer& mb) noexcept { INFO.test_class_name_and_version(mb); mb.read_known_size((BytePtr)(&mdata), DATA_SIZE); return *this; } inline G& generator_assign(MemoryBuffer& mb) noexcept { object_assign (mb); return assign_without_parent (mb); } inline virtual Object& assign(MemoryBuffer& mb) noexcept { return generator_assign (mb); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append (object_bytes ()); mb->append (INFO.bytes()); mb->write ((BytePtr)data (), data_size ()); return mb; } inline MemoryBuffer::Ptr generator_bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append(object_bytes()->data (), Object::SIZE); mb->append(INFO.bytes ()); mb->write(generator_data_bytes (), DATA_SIZE); return mb; } inline virtual T get_id () { mdata.mvalue += mdata.mstep; return mdata.mvalue; } inline virtual const T next() { return (mdata.mvalue + mdata.mstep); } inline virtual const T current () const { return mdata.mvalue; } virtual bool initialize (T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept { bool ok = Object::initialize(aid == null_value<T>() ? 0 : aid); mdata.minitial_value = initial_value; mdata.mvalue = initial_value; mdata.mstep = step; return ok; } inline virtual void set_value(T val) { mdata.mvalue = val; } /* virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read (is, byte_order); read_bin_version(is, *VERSION, byte_order); is.read((char*)data(), data_size()); return is; }; virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); VERSION->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; }; */ void set_id (const T& aid) { Object::set_id (aid); } static inline Factory::P get (T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept { return mfactory.get (aid, initial_value, step); }; Factory::P clone() { return get (get_id (), mdata.minitial_value, mdata.mstep); }; inline virtual InStream& read(InStream& is) { Object::read(is); is >> mdata.minitial_value; is >> mdata.mstep; is >> mdata.mvalue; return is; } inline virtual OutStream& write (OutStream& os) const { Object::write(os); return os << mdata.minitial_value << mdata.mstep << W(" ") << mdata.mvalue; } }; template <class Type, typename T> OutStream& operator << (OutStream& os, const Generator<Type, T>& g) { return g.write (os); } template <class Type, typename T> InStream& operator >> (InStream& is, Generator<Type, T>& g) { return g.read (is); } } } #endif </DOCUMENT>
<DOCUMENT filename="icu_util.hpp">
 #ifndef ICU_UTIL_HPP #define ICU_UTIL_HPP #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/ucsdet.h" #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/utypes.h" #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/ucnv.h" #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/ustring.h" #include <string> #include <fstream> #include <vector> #include <iostream> #include <exception> #include <stdio.h> #include <string.h> #include "string_def.hpp" #include "log.hpp" #include "encoding.hpp" namespace pensar_digital { namespace cpplib { namespace icu { inline static const size_t BUFFER_SIZE = 1024; #undef max static inline constexpr size_t max_int32_t = std::numeric_limits<int32_t>::max(); inline void convert_utf8_to_uchar(const char* src, UChar* dest, int32_t destCapacity) { UErrorCode status = U_ZERO_ERROR; int32_t destLen = ucnv_toUChars(NULL, NULL, 0, src, -1, &status); status = U_ZERO_ERROR; if (destLen <= destCapacity) { ucnv_toUChars(NULL, dest, destLen, src, -1, &status); if (U_FAILURE(status)) { std::basic_string<C> msg = W("convert_utf8_to_uchar: Failed to convert error message"); LOG(msg); throw msg; } } else { std::stringstream msg; msg << "convert_utf8_to_uchar: destination buffer is too small. Required size = " << destLen << " but it was " << destCapacity; std::basic_string<C> error = W(msg.str()); LOG(error); throw error; } } inline void char_ptr_to_uchar_ptr(const char* msg, UChar* out) { if (strlen(msg) > BUFFER_SIZE) { std::stringstream msg; msg << "char_ptr_to_uchar_ptr: Message is too big to be converted to UChar string. Max. size = " << BUFFER_SIZE; std::basic_string<C> error = W(msg.str()); LOG(error); throw error; } convert_utf8_to_uchar (msg, out, BUFFER_SIZE); } inline void utf8_char_ptr_to_wchar_t_ptr (const char* msg, wchar_t* out) { UChar uMsg[BUFFER_SIZE]; convert_utf8_to_uchar (msg, uMsg, BUFFER_SIZE); UErrorCode status = U_ZERO_ERROR; wchar_t wcharMsg[BUFFER_SIZE]; u_strToWCS(wcharMsg, BUFFER_SIZE, NULL, uMsg, -1, &status); if ( !U_SUCCESS(status)) { std::basic_string<C> error = W("char_ptr_to_wchar_ptr: Error converting UChar to wchar_t"); LOG(error); throw error; } } inline std::wstring to_wstring(const std::string& s) { UErrorCode status = U_ZERO_ERROR; UConverter* conv = ucnv_open("utf-8", &status); if (U_FAILURE(status)) { wprintf(L"Failed to open the converter\n"); } int32_t destLen = ucnv_toUChars(conv, NULL, 0, s.c_str(), -1, &status); status = U_ZERO_ERROR; UChar* dest = new UChar[destLen]; ucnv_toUChars(conv, dest, destLen, s.c_str(), -1, &status); if (U_FAILURE(status)) { wprintf(L"Failed to convert error message\n"); } wchar_t wcharMsg[BUFFER_SIZE]; u_strToWCS(wcharMsg, BUFFER_SIZE, NULL, dest, -1, &status); if (!U_SUCCESS(status)) { } return std::wstring(wcharMsg); } inline std::string utf16_to_utf8 (const std::wstring& s) { UErrorCode status = U_ZERO_ERROR; UConverter* conv = ucnv_open("utf-8", &status); if (U_FAILURE(status)) { std::basic_string<C> error = W("pd::icu::utf16_to_utf8: Error getting converter."); LOG(error); throw error; } const UChar* source = reinterpret_cast<const UChar*>(s.c_str()); size_t slen = s.length(); if (slen > max_int32_t) { std::basic_string<C> error = W("pd::icu::utf16_to_utf8: Error converting string. Buffer size is too big."); LOG(error); throw error; } uint32_t len = static_cast<uint32_t>(slen); int32_t destLen = ucnv_fromUChars(conv, NULL, 0, source, len, &status); status = U_ZERO_ERROR; char* dest = new char[destLen + 1]; ucnv_fromUChars(conv, dest, destLen + 1, source, len, &status); if (U_FAILURE(status)) { S error = W("pd::icu::utf16_to_utf8: Error converting string."); LOG(error); throw error; } std::string result(dest, destLen); delete[] dest; ucnv_close(conv); return result; } #ifdef Windows std::string to_string(const std::wstring& s) { return utf16_to_utf8(s); } #endif inline std::string utf32_to_utf8(const std::wstring& s) { UErrorCode status = U_ZERO_ERROR; UConverter* convToUTF8 = ucnv_open("UTF-8", &status); if (U_FAILURE(status)) { S error = W("1. pd::icu::utf32_to_utf8: Failed to open UTF-8 converter."); LOG(error); throw error; } UConverter* convFromUTF32 = ucnv_open("UTF-32", &status); if (U_FAILURE(status)) { ucnv_close(convToUTF8); S error = W("2. pd::icu::utf32_to_utf8: Failed to open UTF-32 converter."); LOG(error); throw error; } size_t slen = s.length(); if (slen > max_int32_t) { S error = W("pd::icu::utf32_to_utf8: Error converting string. Buffer size is too big."); LOG(error); throw error; } int32_t srcLength = static_cast<int32_t>(slen); const UChar* source = reinterpret_cast<const UChar*>(s.c_str()); int32_t utf8Length = ucnv_fromUChars(convToUTF8, NULL, 0, source, srcLength, &status); if (U_FAILURE(status)) { ucnv_close(convToUTF8); ucnv_close(convFromUTF32); S error = W("pd::icu::utf32_to_utf8: Failed to calculate buffer size for UTF-8 string."); LOG(error); throw error; } char* utf8String = new char[utf8Length + 1]; status = U_ZERO_ERROR; ucnv_fromUChars(convToUTF8, utf8String, utf8Length + 1, source, srcLength, &status); if (U_FAILURE(status)) { delete[] utf8String; ucnv_close(convToUTF8); ucnv_close(convFromUTF32); S error = W("pd::icu::to_string: Failed to convert string from UTF-32 to UTF-8."); LOG(error); throw error; } std::string result(utf8String, utf8Length); delete[] utf8String; ucnv_close(convToUTF8); ucnv_close(convFromUTF32); return result; } inline bool check_bom (const std::vector<char>& buffer, Encoding& encoding) { bool detected = true; if (buffer.size () >= 4) { if (buffer[0] == 0x00 && buffer[1] == 0x00 && buffer[2] == 0xFE && buffer[3] == 0xFF) { encoding = UTF_32_BE_BOM; } else if (buffer[0] == 0xFF && buffer[1] == 0xFE && buffer[2] == 0x00 && buffer[3] == 0x00) { encoding = UTF_32_LE_BOM; } } else if (buffer.size() >= 3) { if (buffer[0] == 0xEF && buffer[1] == 0xBB && buffer[2] == 0xBF) { encoding = UTF_8_BOM; } } else if (buffer.size() >= 2) { if (buffer[0] == 0xFE && buffer[1] == 0xFF) { encoding = UTF_16_BE_BOM; } else if (buffer[0] == 0xFF && buffer[1] == 0xFE) { encoding = UTF_16_LE_BOM; } } else detected = false; return detected; } inline Encoding s_encoding_to_encoding(const std::string& s_encoding) { if (s_encoding == "ASCII") { return ASCII; } else if (s_encoding == "UTF-8") { return UTF_8; } else if (s_encoding == "UTF-8-BOM") { return UTF_8_BOM; } else if (s_encoding == "UTF-16-BE") { return UTF_16_BE; } else if (s_encoding == "UTF-16-BE-BOM") { return UTF_16_BE_BOM; } else if (s_encoding == "UTF-16-LE") { return UTF_16_LE; } else if (s_encoding == "UTF-16-LE-BOM") { return UTF_16_LE_BOM; } else if (s_encoding == "UTF-32-BE") { return UTF_32_BE; } else if (s_encoding == "UTF-32-BE-BOM") { return UTF_32_BE_BOM; } else if (s_encoding == "UTF-32-LE") { return UTF_32_LE; } else if (s_encoding == "UTF-32-LE-BOM") { return UTF_32_LE_BOM; } else { throw std::runtime_error("Error: Unknown encoding " + s_encoding); } } inline Encoding detect_encoding (const std::string& file_name) { std::ifstream file_stream(file_name, std::ios::binary); if (!file_stream.is_open()) { throw std::runtime_error("Error: Could not open file " + file_name); } constexpr size_t MAX_BYTES = 10000; std::vector<char> buffer(MAX_BYTES); file_stream.read(buffer.data(), MAX_BYTES); std::streamsize bytes_read = file_stream.gcount(); if (file_stream.bad()) { file_stream.close(); throw std::runtime_error("Error: Could not read file " + file_name); } file_stream.close(); Encoding bom_encoding; if (check_bom (buffer, bom_encoding)) { return bom_encoding; } UErrorCode error = U_ZERO_ERROR; UCharsetDetector* csd = ucsdet_open(&error); if (U_FAILURE(error)) { throw std::runtime_error("Error: Could not open ICU charset detector"); } ucsdet_setText(csd, buffer.data(), static_cast<int32_t>(buffer.size()), &error); if (U_FAILURE(error)) { ucsdet_close(csd); throw std::runtime_error("Error: Could not set text for ICU charset detector"); } const UCharsetMatch* match = ucsdet_detect(csd, &error); if (U_FAILURE(error)) { ucsdet_close(csd); throw std::runtime_error("Error: Could not detect charset"); } const char* detected_encoding = ucsdet_getName(match, &error); if (U_FAILURE(error)) { ucsdet_close(csd); throw std::runtime_error("Error: Could not get detected charset name"); } std::string s_encoding(detected_encoding); ucsdet_close(csd); return s_encoding_to_encoding (detected_encoding); } } } } #endif </DOCUMENT>
virtual void set_id (const Id& value) = 0; virtual std::istream& read (std::istream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) = 0; virtual void from_xml(const String & sxml) = 0; }; } } #endif </DOCUMENT>
<DOCUMENT filename="io_util.hpp">
 #ifndef IO_UTIL_HPP #define IO_UTIL_HPP #include "multiplatform.hpp" #include "defines.hpp" #include "s.hpp" #include "memory.hpp" #include "constant.hpp" #include "concept.hpp" #include "icu_util.hpp" #include "log.hpp" #include "error.hpp" #include "code_util.hpp" #include INCLUDE(io_util) namespace pensar_digital { namespace cpplib { using LINE_HANDLER = void(*)(const int64_t line_count, const S& line); Result<S> get_exe_full_path(); } } #endif </DOCUMENT>
<DOCUMENT filename="macros.hpp">
 #ifndef MACROS_HPP_INCLUDED #define MACROS_HPP_INCLUDED #define WIDE2(x) L##x #define WIDE1(x) WIDE2(x) #define __WFILE__ WIDE1(__FILE__) #ifdef WIDE_CHAR #define FILE_LINE __WFILE__ << L"\t linha " << __LINE__ << L"\t" #else #define FILE_LINE __FILE__ << "\t linha " << __LINE__ << "\t" #endif #endif </DOCUMENT>
<DOCUMENT filename="mac_address.hpp">
#ifndef MAC_ADDRESS_HPP #define MAC_ADDRESS_HPP #include <string> #include <inttypes.h> namespace pensar_digital { namespace cpplib { class MacAddress { int64_t mac; public: MacAddress(int64_t mac) : mac(mac) {} operator std::string() const { char buffer[18]; sprintf_s(buffer, "%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64, (mac >> 40) & 0xff, (mac >> 32) & 0xff, (mac >> 24) & 0xff, (mac >> 16) & 0xff, (mac >> 8) & 0xff, mac & 0xff); return buffer; } operator int64_t() const { return mac; } operator std::wstring() const { wchar_t buffer[18]; swprintf_s(buffer, L"%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64, (mac >> 40) & 0xff, (mac >> 32) & 0xff, (mac >> 24) & 0xff, (mac >> 16) & 0xff, (mac >> 8) & 0xff, mac & 0xff); return buffer; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="memory.hpp">
#ifndef MEMORY_H_INCLUDED #define MEMORY_H_INCLUDED #include "constant.hpp" #include <cstring> namespace pensar_digital { namespace cpplib { extern size_t getPeakRSS(); extern size_t get_available_memory(); static inline BytePtr memory_copy(const BytePtr dest, const BytePtr src, size_t size) { std::memcpy(static_cast <void*> (dest), static_cast <void*> (src), size); } } } #endif </DOCUMENT>
<DOCUMENT filename="memory_buffer.hpp">
 #ifndef MEMORY_BUFFER_HPP #define MEMORY_BUFFER_HPP #include "constant.hpp" #include "concept.hpp" #include "factory.hpp" #include <memory> #include <concepts> #include <exception> #include <string> #include <typeinfo> #include <string.h> #include <utility> #include <unordered_map> #include <functional> #include <typeindex> #include <span> namespace pd = pensar_digital::cpplib; namespace pensar_digital { namespace cpplib { class MemoryBuffer { public: using Offset = size_t; using Ptr = std::unique_ptr<MemoryBuffer>; protected: std::span<std::byte> mbuffer; Offset mwrite_offset; Offset mread_offset; std::unordered_map<Offset, size_t> mindex; public: MemoryBuffer(size_t initial_size = 1024*1024) : mread_offset(0), mwrite_offset(0) { mbuffer = std::span<std::byte>(new std::byte[initial_size], initial_size); } MemoryBuffer(BytePtr bp, size_t size) : MemoryBuffer() { write (bp, size); } MemoryBuffer (const Ptr ptr, size_t size) : MemoryBuffer() { write(ptr->data(), size); } MemoryBuffer(const MemoryBuffer& mb) : MemoryBuffer() { write(mb.mbuffer.data(), mb.size()); } template <class T> requires std::is_trivially_copyable_v<T> MemoryBuffer(const T* t) : MemoryBuffer() { write(t, sizeof(T)); } template <HasStdLayoutTriviallyCopyableData T> MemoryBuffer(const T& t) : MemoryBuffer() { write(t.data_bytes(), T::DATA_SIZE); } template <HasStdLayoutTriviallyCopyableData T> MemoryBuffer() : MemoryBuffer() { T t; write(t.data_bytes(), T::DATA_SIZE); } template <HasStdLayoutTriviallyCopyableData T> MemoryBuffer& operator+=(const T& t) { write(t.data_bytes(), T::DATA_SIZE); return *this; } Offset subtract_from_read_offset (const Offset& amount) { if (amount > mread_offset) { throw std::runtime_error("MemoryBuffer::subtract_from_read_offset: invalid amount to subtract."); } mread_offset -= amount; return mread_offset; } void reset_read_offset () { mread_offset = 0; } virtual ~MemoryBuffer() { delete[] mbuffer.data(); } BytePtr data() noexcept { return mbuffer.data(); } const BytePtr data() const noexcept { return mbuffer.data(); } const size_t size() const noexcept { return mbuffer.size(); } const size_t count() const noexcept { return mindex.size(); } const Offset woffset() const noexcept { return mwrite_offset; } const size_t data_size() const noexcept { return mwrite_offset; } const Offset roffset() const noexcept { return mread_offset; } const size_t wavailable() const noexcept { return mbuffer.size() - mwrite_offset; } const size_t ravailable() const noexcept { return mwrite_offset - mread_offset; } Offset write(const BytePtr data, const size_t size) noexcept { if (wavailable() < size) { auto new_buffer = std::span<std::byte>(new std::byte[mbuffer.size() + size], mbuffer.size() + size); memcpy(new_buffer.data(), mbuffer.data(), mbuffer.size()); delete[] mbuffer.data(); mbuffer = new_buffer; } memcpy(mbuffer.data() + mwrite_offset, data, size); mindex[mwrite_offset] = size; Offset offset = mwrite_offset; mwrite_offset += size; return offset; } Offset write (std::ifstream& in, const size_t size) { in.read((char*)(mbuffer.data() + mwrite_offset), size); mindex[mwrite_offset] = size; Offset offset = mwrite_offset; mwrite_offset += size; return offset; } void read (BytePtr dest, const Offset offset, size_t size) { if (ravailable() < size) { throw std::runtime_error("MemoryBuffer::read: not enough data in the buffer."); } memcpy(dest, mbuffer.data() + offset, size); if (mread_offset == offset) { mread_offset += size; } } void read (BytePtr dest, const Offset offset) { size_t size = mindex[offset]; if (size == 0) { throw std::runtime_error("MemoryBuffer::read: not enough data in the buffer."); } read(dest, offset, size); } void read(BytePtr dest) { read(dest, mread_offset); } void read_known_size(BytePtr dest, const size_t size) { read(dest, mread_offset, size); } template <StdLayoutTriviallyCopyable T> void read(T* t, Offset offset) { read(t, offset, sizeof(T)); } template <HasStdLayoutTriviallyCopyableData T> void read_into_data(T* t, Offset offset) { read(t->data_bytes(), offset, T::DATA_SIZE); } Offset copy (const MemoryBuffer& mb, const Offset offset = 0) { if (wavailable() < mb.size()) { auto new_buffer = std::span<std::byte>(new std::byte[mbuffer.size() + mb.size()], mbuffer.size() + mb.size()); memcpy(new_buffer.data(), mbuffer.data(), mbuffer.size()); delete[] mbuffer.data(); mbuffer = new_buffer; } mindex[mwrite_offset] = mb.size(); memcpy(mbuffer.data() + mwrite_offset, mb.mbuffer.data(), mb.size()); mwrite_offset += mb.size(); return offset; } inline Offset append (const MemoryBuffer& mb) { return copy(mb, mwrite_offset); } inline Offset append(const MemoryBuffer::Ptr& mb) { if (!mb) { throw std::runtime_error("MemoryBuffer::append: null pointer."); } return append(*mb); } inline Offset append(const BytePtr data, const size_t size) { return write(data, size); } inline Offset operator+=(const MemoryBuffer& mb) { return append (mb); } template <HasStdLayoutTriviallyCopyableData T> Offset append(const T& t) { return write(t.data_bytes (), T::DATA_SIZE); } }; template <typename T> concept MemoryBufferPtrConvertible = requires(T t) { { t.bytes() } -> std::convertible_to<MemoryBuffer::Ptr>; }; template <typename T> concept WriteableToMemoryBuffer = Sizeable<T> && MemoryBufferPtrConvertible<T>; template <typename T> concept BinaryConstructible = requires(MemoryBuffer & bytes) { { T(bytes) } -> std::convertible_to<T>; }; template <typename T> concept BinaryIO = MemoryBufferPtrConvertible<T> && BinaryConstructible<T>; template <class T> concept BinaryWriteableObject = MemoryBufferPtrConvertible<T> && Sizeofable<T>; template <typename T> concept BinaryStreamableObject = MemoryBufferPtrConvertible<T> && Streamable<T>; template <typename T, typename Obj> concept ObjectBinaryWriteable = requires(T t, const Obj & object) { { t.template write<Obj>(object) } -> std::convertible_to<void>; }&& BinaryWriteableObject<Obj>; template <typename T, typename Obj, typename... Args> concept FactoryObjectBinaryWriteable = requires(T t, const Obj & object) { { t.template write<Obj, Args...>(object) } -> std::convertible_to<void>; }&& ObjectBinaryWriteable<T, Obj>&& FactoryConstructible<Obj, Args ...>; template <typename T> concept BinaryWriteable = requires(T t, std::span<std::byte>&wbytes) { { t.write(wbytes) } -> std::convertible_to<void>; }; template <typename T> concept BinaryPersistable = BinaryWriteable<T> && BinaryReadable<T>; /* template <class T> class ObjMemoryBuffer { protected: std::span<std::byte> mbuffer; size_t mwrite_offset; size_t mread_offset; std::unordered_map<Id, size_t> mindex; public: ObjMemoryBuffer(size_t initial_size = 1000 * sizeof(T)) : mread_offset(0), mwrite_offset(0) { mbuffer = std::span<std::byte>(new std::byte[initial_size], initial_size); } virtual ~ObjMemoryBuffer() { delete[] mbuffer.data(); } const size_t size() const noexcept { return mbuffer.size(); } const size_t count() const noexcept { return mindex.size(); } const size_t woffset() const noexcept { return mwrite_offset; } const size_t roffset() const noexcept { return mread_offset; } const size_t wavailable() const noexcept { return mbuffer.size() - mwrite_offset; } const size_t ravailable() const noexcept { return mwrite_offset - mread_offset; } void write(const BytePtr data, const size_t size) noexcept { if (wavailable() < size) { auto new_buffer = std::span<std::byte>(new std::byte[mbuffer.size() + size], mbuffer.size() + size); memcpy(new_buffer.data(), mbuffer.data(), mbuffer.size()); delete[] mbuffer.data(); mbuffer = new_buffer; } memcpy(mbuffer.data() + mwrite_offset, data, size); mwrite_offset += size; } void read(BytePtr dest, const size_t offset, size_t size) { if (ravailable() < size) { throw std::runtime_error("MemoryBuffer::read: not enough data in the buffer."); } memcpy(dest, mbuffer.data() + offset, size); if (mread_offset == offset) { mread_offset += size; } } }; */ } } #endif </DOCUMENT>
<DOCUMENT filename="mg.hpp">
 #ifndef MG_H #define MG_H #endif </DOCUMENT>
<DOCUMENT filename="multiplatform.hpp">
#ifndef MULTIPLATFORM_HPP #define MULTIPLATFORM_HPP namespace pensar_digital { namespace cpplib { #if defined(_WIN32) || defined(_WIN64) #define _PLATFORM_FOLDER windows #define _PLATFORM_SUFFIX windows #define _INCLUDE_PATH(base_name) _STRINGIFY(./windows/base_name##_windows.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #elif defined(__linux__) #define _PLATFORM_FOLDER linux #define _PLATFORM_SUFFIX linux #define _INCLUDE_PATH(base_name) _STRINGIFY(./linux/base_name##_linux.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #elif defined(__APPLE__) && defined(TARGET_OS_IPHONE) #define _PLATFORM_FOLDER ios #define _PLATFORM_SUFFIX ios #define _INCLUDE_PATH(base_name) _STRINGIFY(./ios/base_name##_ios.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #elif defined(__ANDROID__) #define _PLATFORM_FOLDER android #define _PLATFORM_SUFFIX android #define _INCLUDE_PATH(base_name) _STRINGIFY(./android/base_name##_android.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #else #error "Unsupported platform" #endif #define _STRINGIFY(x) #x } } #endif </DOCUMENT>
<DOCUMENT filename="object.hpp">
 #ifndef OBJECT_HPP #define OBJECT_HPP #include "constant.hpp" #include "s.hpp" #include "clone_util.hpp" #include "factory.hpp" #include "log.hpp" #include "string_def.hpp" #include "memory_buffer.hpp" #include "equal.hpp" #include "concept.hpp" #include <sstream> #include <iostream> #include <memory> #include <concepts> #include <string> #include <typeinfo> #include <vector> #include <span> #include <cstddef> #include <bit> #include <cstring> #include <bit> namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; inline static void log_throw(const S& error_msg = W("")) { LOG(error_msg); throw std::runtime_error (error_msg); } template <class T> T& assigns (T& l, const T& r) noexcept { std::memcpy (l.data (), ((T&)r).data (), sizeof(T::DataType)); return l; } template <class T> T& moves (T& l, const T& r) noexcept { std::memmove (l.data (), ((T&)r).data (), sizeof(T::DataType)); return l; } struct ClassInfo { inline static const size_t MAX_IDENTIFIER_SIZE = 100; using Identifier = CS<0, MAX_IDENTIFIER_SIZE>; Identifier mnamespace; Identifier mclass_name; VersionInt mpublic_interface_version; VersionInt mprotected_interface_version; VersionInt mprivate_interface_version; inline static const VersionInt NULL_VERSION = -1; ClassInfo(const S& ns = EMPTY, const S& cn = EMPTY, VersionInt pub_ver = NULL_VERSION, VersionInt pro_ver = NULL_VERSION, VersionInt pri_ver = NULL_VERSION) noexcept : mnamespace (ns), mclass_name (cn), mpublic_interface_version (pub_ver), mprotected_interface_version (pro_ver), mprivate_interface_version (pri_ver) {} inline void write (MemoryBuffer& mb) const noexcept { mb.write((BytePtr)this, sizeof(ClassInfo)); } inline void read (MemoryBuffer& mb) { mb.read_known_size((BytePtr)this, sizeof(ClassInfo)); } MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(sizeof(ClassInfo)); write(*mb); return mb; } inline bool operator==(const ClassInfo& other) const noexcept { return equal<ClassInfo> (*this, other); } inline bool operator!=(const ClassInfo& other) const noexcept { return !(*this == other); } inline void test_class_name_and_version(MemoryBuffer& mb) const { if (mb.size() < sizeof(ClassInfo)) log_throw(W("MemoryBuffer size is smaller than ClassInfo size.")); ClassInfo info; info.read (mb); if (info != *this) log_throw(W("Version mismatch.")); } inline const S to_s () const noexcept { SStream ss; ss << mnamespace << W("::") << mclass_name << W(" v") << mpublic_interface_version << W(".") << mprotected_interface_version << W(".") << mprivate_interface_version; return ss.str(); } inline std::istream& binary_read(std::istream& is, const std::endian& byte_order) { return is.read((char*)(this), sizeof(ClassInfo)); } inline std::ostream& binary_write(std::ostream& os, const std::endian& byte_order) const { return os.write((const char*) this, sizeof(ClassInfo)); } inline void test_class_name_and_version (std:: istream& is, const std::endian& byte_order = std::endian::native) const { ClassInfo info; info.binary_read(is, byte_order); if (info != *this) log_throw(W("Version mismatch.")); } }; static_assert(StdLayoutTriviallyCopyable<ClassInfo>, W("ClassInfo must be a trivially copyable type")); template<typename T> concept HasClassInfo = requires { { T::INFO } -> std::same_as<ClassInfo>; requires std::is_same_v<decltype(T::INFO), const ClassInfo>; }; class Object { public: inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("Object"), 1, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } private: struct Data : public pd::Data { Id mid; Data(const Id& id = NULL_ID) noexcept : mid(id) {} }; static_assert(TriviallyCopyable<Data>, "Data must be a trivially copyable type"); Data mdata; public: using Ptr = std::shared_ptr<Object>; inline const static Data NULL_DATA = { NULL_ID }; using DataType = Data; private: using Factory = pd::Factory<Object, typename Object::DataType>; public: inline virtual pd::Data* get_null_data() const noexcept { return (pd::Data*)(&NULL_DATA); } using FactoryType = Factory; inline const BytePtr object_data_bytes() const noexcept { return (BytePtr)&mdata; } inline const size_t object_data_size() const noexcept { return sizeof(mdata); } virtual const pd::Data* data() const noexcept { return &this->mdata; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)&this->mdata; } inline static constexpr size_t DATA_SIZE = sizeof(mdata); inline static constexpr size_t SIZE = DATA_SIZE + sizeof(ClassInfo); virtual size_t data_size() const noexcept { return sizeof(this->mdata); } virtual size_t size() const noexcept { return data_size() + sizeof(ClassInfo); } protected: void set_id(const Id& value) { mdata.mid = value; } private: inline static Factory mfactory = { 3, 10, NULL_DATA }; friend class Factory; public: Object(const Data& data = NULL_DATA) noexcept { initialize(data); } Object(const Object& o) { assign(o); } Object(Object&& o) noexcept { assign(o); } Object(MemoryBuffer& mb) { object_assign(mb); } virtual ~Object() {} virtual Object& assign(const Object& o) noexcept { std::memcpy((void*)data(), ((Object&)o).data(), data_size()); return *this; } virtual Object& assign(const Object&& o) noexcept { std::memmove((void*)data(), ((Object&)o).data(), data_size()); return *this; } Object& object_assign(MemoryBuffer& mb) noexcept { INFO.test_class_name_and_version (mb); mb.read_known_size(object_data_bytes(), DATA_SIZE); return *this; } virtual Object& assign(MemoryBuffer& mb) { if (mb.size() < SIZE) log_throw(W("MemoryBuffer size is smaller than Object size.")); return object_assign (mb); } Object& object_assign(const Object& o) noexcept { mdata = o.mdata; return *this; } inline virtual const Object& write(MemoryBuffer& mb) const noexcept { info_ptr ()->write(mb); mb.write((BytePtr)(data ()), data_size ()); return *this; } inline const Object& object_write(MemoryBuffer& mb) const noexcept { INFO.write(mb); mb.write((BytePtr)(&mdata), DATA_SIZE); return *this; } /* inline virtual void bytes_to_vector(ConstBytes& v) const noexcept { VERSION->bytes(v); size_t req_size = v.size() + data_size(); if (v.capacity() < req_size) v.resize(req_size); std::copy_n(reinterpret_cast<const std::byte*>(&mdata), data_size(), v.end() - data_size()); } */ inline MemoryBuffer::Ptr object_bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append((BytePtr)&INFO, sizeof(ClassInfo)); mb->append((BytePtr)(&mdata), DATA_SIZE); return mb; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { return object_bytes (); } inline operator MemoryBuffer::Ptr() const noexcept { return bytes(); } inline virtual ByteSpan data_span() const noexcept { return ByteSpan(data_bytes(), data_size()); } inline virtual std::span<std::byte> wbytes() noexcept { static_assert (sizeof(char) == sizeof(std::byte)); auto byte_span = std::span<std::byte>((std::byte*)(data()), data_size()); return std::as_writable_bytes(byte_span); } inline virtual std::string sclass_name() const { std::string s = typeid(*this).name(); s.erase(0, sizeof("class ") - 1); return s; } inline virtual S class_name() const { std::string s = typeid(*this).name(); s.erase(0, sizeof("class ") - 1); #ifdef WIDE_CHAR return pd::to_wstring(s); #else return s; #endif } inline Object::Ptr clone() const noexcept { return pd::clone<Object>(*this, mdata.mid); } inline virtual Object* get_obj() const noexcept { return ((Object*)(&(*(mfactory.get(NULL_DATA))))); } /*inline virtual Object* clone() const noexcept { Object* o = get_obj(); o->assign(*this); return o; } */ inline virtual bool equals(const Object& o) const noexcept { return equal<Object>(*this, o); } inline virtual const Id id() const noexcept { return mdata.mid; }; inline virtual const Hash hash() const noexcept { return this->id(); }; inline virtual bool initialize(const Data& data) noexcept { mdata = data; return true; } inline std::ostream& bin_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { INFO.binary_write (os, byte_order); os.write((const char*)(&mdata), DATA_SIZE); return os; }; inline bool operator == (const Object& o) const { return equals(o); } inline bool operator != (const Object& o) const { return !equals(o); } inline S to_string() const noexcept { return pd::to_string(mdata.mid); } inline operator S () const noexcept { return to_string(); } inline virtual S debug_string() const noexcept { SStream ss; ss << W("id = ") << Object::to_string(); return ss.str(); } inline Object& operator=(const Object& o) noexcept { return assign(o); } inline Object& operator=(Object&& o) noexcept { return assign(o); } static inline Factory::P get(const Data& data = NULL_DATA) { return mfactory.get(data); }; static inline Factory::P get(const Id& id) { return mfactory.get(Data(id)); }; static inline Factory::P get (MemoryBuffer& mb) { Factory::P o_ptr = get(); Object& o = *o_ptr; o.assign(mb); return o_ptr; }; inline virtual InStream& read(InStream& is) { return is >> mdata.mid; } inline virtual OutStream& write(OutStream& os) const { return os << id(); } inline InStream& operator >> (InStream& is) { return read(is); } inline OutStream& operator << (OutStream& os) { return write(os); } inline std::istream& bin_read(std::istream& is, const std::endian& byte_order = std::endian::native) { INFO.test_class_name_and_version(is, byte_order); is.read((char*)(&mdata), DATA_SIZE); return is; } inline virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { bin_read(is, byte_order); info_ptr ()->test_class_name_and_version (is, byte_order); is.read((char*)data(), data_size()); return is; }; inline virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { bin_write(os, byte_order); info_ptr ()->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; } }; inline InStream& operator >> (InStream& is, Object& o) { return o.read(is); } inline OutStream& operator << (OutStream& os, const Object& o) { return o.write(os); } /* template <typename T> concept CloneableConcept = requires (T t) { { t.clone() } -> std::convertible_to<Object*>; }; */ /* template<typename Container> std::istream& binary_read(Container& c, std::istream& is, const std::endian& byte_order) { size_t size = 0; is.read(reinterpret_cast<char*>(&size), sizeof(size)); if (byte_order != std::endian::native) { size = std::bit_cast<size_t>(std::byteswap<uint64_t>(std::bit_cast<uint64_t>(size))); } c.clear(); auto* as_vector = dynamic_cast<std::vector<Object::Ptr>*>(&c); if (as_vector) { as_vector->reserve(size); } for (size_t i = 0; i < size; ++i) { Object::Ptr obj = Object::get (); obj->binary_read(is, byte_order); c.insert(c.end(), obj); } return is; } template<typename Container> std::ostream& binary_write(const Container& c, std::ostream& os, const std::endian& byte_order) { size_t size = c.size(); if (byte_order != std::endian::native) { size = std::bit_cast<size_t>(byteswap(std::bit_cast<uint64_t>(size))); } os.write(reinterpret_cast<const char*>(&size), sizeof(size)); for (const auto& obj : c) { obj->binary_write(os, byte_order); } return os; } template<typename Container> std::ostream& binary_write(const Container& c, std::ostream& os, const std::endian& byte_order) { size_t size = c.size(); if (byte_order != std::endian::native) { size = std::bit_cast<size_t>(byteswap(std::bit_cast<uint64_t>(size))); } os.write(reinterpret_cast<const char*>(&size), sizeof(size)); for (const auto& obj : c) { obj->binary_write(os, byte_order); } return os; } */ /*template <Versionable MainClass, Versionable RequiredClass> class Dependency { private: Version::Int required_public_interface_version; Version::Int required_protected_interface_version; Version::Int required_private_interface_version; public: Dependency(Version v) noexcept : required_public_interface_version(v.get_public ()), required_protected_interface_version(v.get_protected ()), required_private_interface_version(v.get_private ()) {} virtual ~Dependency() {} virtual bool ok() const noexcept = 0; };*/ } } #endif </DOCUMENT>
<DOCUMENT filename="path.hpp">
 #ifndef PATH_HPP #define PATH_HPP #include "object.hpp" #include "s.hpp" #include "system.hpp" #include "memory.hpp" #include "constant.hpp" #include "version.hpp" #include "concept.hpp" #include "io_util.hpp" #include "clone_util.hpp" #include "error.hpp" #include <string> #include <cstdio> #include <stdlib.h> #include <io.h> #include <windows.h> #include <filesystem> namespace pensar_digital { namespace cpplib { namespace fs = std::filesystem; class Path; typedef std::shared_ptr<Path> PathPtr; typedef Factory<Path, fs::path, Id> PathFactory; class Path : public fs::path, public Object { private: inline static PathFactory mfactory = { 3, 10, W("."), null_value<Id>()}; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); Path(const fs::path& p = W("."), const Id& id = null_value<Id>()) : Object(id), fs::path(p) {} Path(const std::string& s, const Id& id = null_value<Id>()) : Object(id), fs::path(s) {} Path(const char* path, const Id& id = null_value<Id>()) : Object(id), fs::path(path) {} Path(const wchar_t* path, const Id& id = null_value<Id>()) : Object(id), fs::path(path) {} Path(const std::wstring& path, const Id& id = null_value<Id>()) : Object(id), fs::path(path) {} Path(const Path& p, const Id& aid = null_value<Id>()) noexcept : Object(aid), fs::path(p) {} Path(Path&& p, const Id& aid = null_value<Id>()) noexcept : Object(aid), fs::path(p) {} virtual ~Path() noexcept = default; static PathFactory::P get(const fs::path& p = ".", const Id& aid = null_value<Id>()) { return mfactory.get (p, aid); }; PathFactory::P clone(const Path& apath) { return get(apath.std_path(), apath.id()); }; PathFactory::P clone(const PathPtr& ptr) { return clone(*ptr); } static bool is_valid (const S& p) noexcept { return true; } bool is_directory() const noexcept { return fs::is_directory(*this); } bool remove() const noexcept { if (exists()) { if (is_directory ()) return fs::remove_all(*this); else return fs::remove(*this); } return true; } bool exists() const noexcept { return fs::exists(*this); } Path absolute() const noexcept { return fs::absolute(*this); } Path canonical() const noexcept { return fs::canonical(*this); } Path relative() const noexcept { return fs::relative(*this); } Path parent_path() const noexcept { return fs::path::parent_path(); } Path root_path () const noexcept { return fs::path::root_path(); } Path filename() const noexcept { return fs::path::filename(); } Path stem() const noexcept { return fs::path::stem(); } Path filename_only () const noexcept { return stem (); } Path extension() const noexcept { return fs::path::extension(); } Path& replace_extension(const std::string& s) noexcept { fs::path::replace_extension(s); return *this; } Path& replace_extension(const Path& p) noexcept { fs::path::replace_extension(p); return *this; } Path& make_preferred() noexcept { fs::path::make_preferred(); return *this; } Path& remove_filename() noexcept { fs::path::remove_filename(); return *this; } Path& remove_trailing_separator() noexcept { if (! has_filename()) { S s = str (); if (s.back() == Sys::path_separator ()) { s.pop_back(); *this = s; } } return *this; } Path copy_without_trailing_separator() const noexcept { Path p = *this; return p.remove_trailing_separator(); } virtual bool initialize(const fs::path& p, const Id& aid = null_value<Id>()) noexcept { fs::path::operator = (p); Object::set_id(aid); return true; } virtual std::istream& binary_read (std::istream& is, const std::endian& byte_order = std::endian::native) { return is; }; virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); VERSION->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; }; virtual S debug_string() const noexcept { return Object::debug_string() + W(" path = ") + s (); } Path& operator = (Path&& p) noexcept { fs::path::operator = (p); return *this; } Path& operator = (const S & s) { fs::path::operator = (s); return *this; } Path& operator = (const Path& p) { fs::path::operator = (p); return *this; } void create_dir () const noexcept { if (has_filename() && has_parent_path ()) fs::create_directories (parent_path()); else fs::create_directories (*this); } inline size_t size () const noexcept { return s ().size(); } inline fs::path std_path() const noexcept { return static_cast<const fs::path&>(*this); } operator fs::path() const noexcept { return std_path(); } operator std::string() const noexcept { return fs::path::string(); } operator std::wstring() const noexcept { return fs::path::wstring(); } S s () const { #ifdef WIDE_CHAR return fs::path::wstring(); #else return fs::path::string(); #endif } operator const char* () const { return _strdup(fs::path::string().c_str()); } wchar_t * wstr() const { return _wcsdup(fs::path::wstring().c_str()); } char* cstr() const { return _strdup(fs::path::string().c_str()); } C* str() const { #ifdef WIDE_CHAR return wstr(); #else return cstr(); #endif } Path& operator = (const char* s) { fs::path::operator = (s); return *this; } Path& operator /= (const S& s) { fs::path::operator /= (s); return *this; } Path& operator /= (const Path& p) { fs::path::operator /= (p); return *this; } Path operator + (const S& s) const { Path p = *this; p /= s; return p; } bool operator == (const Path& apath) const { return apath.std_path () == this->std_path (); } bool operator != (const std::string& s) const { return !(*this == s); } bool operator == (const char* s) const { return *this == std::string(s); } bool operator != (const char* s) const { return !(*this == s); } inline void set_id(const Id& value) { Object::set_id(value); } using fs::path::value_type; }; inline InStream& operator >> (InStream& is, Path& path) { return path.read(is); } inline OutStream& operator << (OutStream& os, const Path& path) { return path.write(os); } class CPath : public CS<0, MAX_PATH> { public: using P = CS<0, MAX_PATH>; CPath(const P& path = CURRENT_DIR) : P(path) {} inline fs::path to_fspath() const noexcept { return fs::path(P::to_string()); } inline Path to_path() const noexcept { return Path(P::to_string()); } operator fs::path() const noexcept { return to_fspath(); } }; inline CPath path_to_cpath (const Path& path) { return CPath(path.s()); } inline Path cpath_to_path(const CPath& cpath) { return Path (cpath.to_path()); } inline const Path& set_tmp_env_var(const Path& path = fs::temp_directory_path()) { Path p = W("TMP="); p += path; int r = _putenv(p.cstr()); if (r != 0) runtime_error(W("Error setting TMP environment variable.")); return path; } inline static const C* TMP_DIR = W("c:\\tmp\\"); inline static const Path TMP_PATH = set_tmp_env_var (TMP_DIR); } } #endif </DOCUMENT>
<DOCUMENT filename="path_factory.hpp">
 #ifndef PATH_FACTORY_HPP #define PATH_FACTORY_HPP #include "factory.hpp" #include "io_util.hpp" #include "version_factory.hpp" namespace pensar_digital { namespace cpplib { typedef Factory<Path, fs::path, Id> PathFactoryBase; class PathFactory : public PathFactoryBase { public: inline static const VersionPtr VERSION = pd::versionf.get(1, 1, 1); PathFactory(const fs::path& p = ".", const Id& aid = NULL_ID) : PathFactoryBase(3, 10, p, aid) { }; virtual ~PathFactory() { }; using P = PathFactoryBase::P; virtual P get(const fs::path& p = ".", const Id& aid = NULL_ID) { return PathFactoryBase::get(p, aid); }; P clone(const PathRO& apath) { return get(apath.to_std_path (), apath.get_id()); }; P clone(const PathPtr& ptr) { return clone(*ptr); } P parse_json(const String& sjson) { auto j = Json::parse(sjson); String json_class = j.at("class"); if (json_class != pd::class_name<Path>()) throw std::runtime_error("Invalid class name: " + pd::class_name<Path>()); Path p = j; return clone(p); }; }; extern PathFactory pathf; } } #endif </DOCUMENT>
operator >> (InStream& is, Person& p); friend OutStream& operator << (OutStream& os, const Person& p); }; inline InStream& operator >> (InStream& is, Person& p) { return p.read (is); } inline OutStream& operator << (OutStream& os, const Person& p) { return p.write (os); } } } } #endif </DOCUMENT>
<DOCUMENT filename="random_util.hpp">
#ifndef RANDOM_UTIL_HPP_INCLUDED #define RANDOM_UTIL_HPP_INCLUDED #include <chrono> #include <random> #include <cstdlib> namespace pensar_digital { namespace cpplib { using DefaultRandomGeneratorType = unsigned long long int; inline DefaultRandomGeneratorType seed() { return std::chrono::system_clock::now().time_since_epoch().count(); } template <typename T = DefaultRandomGeneratorType> class CustomRandomGenerator { public: using result_type = T; #undef min CustomRandomGenerator(result_type seed) : m_engine(seed), m_dist(std::numeric_limits<result_type>::min(), std::numeric_limits<result_type>::max()) {} static constexpr result_type min() { return std::numeric_limits<result_type>::min(); } static constexpr result_type max() { return std::numeric_limits<result_type>::max(); } result_type operator()() { return m_dist(m_engine); } private: std::mt19937_64 m_engine; std::uniform_int_distribution<result_type> m_dist; }; using RandGen = CustomRandomGenerator<>; template <typename T = DefaultRandomGeneratorType, class Distribution = std::uniform_int_distribution<T>, class RandomGenerator = RandGen> class Random { public: Random(const T min_value, const T max_value) : mmin(min_value), mmax(max_value), mseed(seed()), mdistribution(min_value, max_value), mgenerator(mseed) {} T operator()() { return mdistribution(mgenerator); } private: Distribution mdistribution; RandomGenerator mgenerator; DefaultRandomGeneratorType mseed; T mmin; T mmax; }; class CRandom { public: CRandom (int min_value, int max_value): _min(min_value), _max(max_value) { srand ((unsigned int) seed()); } inline int get () const { return rand () % (_max - _min + 1) + _min;} inline int get_min () const { return _min; } inline int get_max () const { return _max; } inline void set_min (const int min_value) { _min = min_value; } inline void set_max (const int max_value) { _max = max_value; } private: int _min; int _max; }; inline RandGen get_generator() { static RandGen random_generator(seed()) ; return random_generator; } inline RandGen random_generator = get_generator (); } } #endif </DOCUMENT>
<DOCUMENT filename="s.hpp">
 #ifndef S_HPP #define S_HPP #include "constant.hpp" #include "string_def.hpp" #include "concept.hpp" #include "icu_util.hpp" #include <array> #include <algorithm> #include <sstream> #include <fstream> #include <iostream> #include <iomanip> namespace pensar_digital { namespace cpplib { inline void runtime_error(const S& message) { #ifdef WIDE_CHAR throw std::runtime_error(to_string(message)); #else throw std::runtime_error(message); #endif } inline static constexpr S sfile () { #ifdef WIDE_CHAR return __FILEW__; #else return __FILE__; #endif } inline S& read_all(InStream& is, S& s) { C c; while (is.get(c)) s += c; return s; } static inline S& rtrim(S& s) { #ifdef WIDE_CHAR s.erase(std::find_if_not(s.rbegin(), s.rend(), [](wchar_t c) {return iswspace(c); }).base(), s.end()); #else s.erase(std::find_if_not(s.rbegin(), s.rend(), [](unsigned char c) {return iswspace(c); }).base(), s.end()); #endif return s; } static inline S& ltrim(S& s) { #ifdef WIDE_CHAR s.erase(s.begin(), std::find_if_not(s.begin(), s.end(), [](wchar_t c) {return iswspace(c); })); #else s.erase(s.begin(), std::find_if_not(s.begin(), s.end(), [](unsigned char c) {return iswspace(c); })); #endif return s; } static inline void trim(S& s) { ltrim(rtrim(s)); } static inline S trim(const S& s) { S t = s; return ltrim(rtrim(t)); } typedef std::unique_ptr<std::vector<S>> SVectorPtr; template<typename Container = std::vector<S>> inline void split(const S& s, C ch, Container& c, bool trim_elements = true, bool include_empty_fields = false) { size_t i = 0; size_t j = s.find(ch); if (j == S::npos) c.insert(c.end(), s); else while (j != S::npos) { S aux = s.substr(i, j - i); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) c.insert(c.end(), aux); i = ++j; j = s.find(ch, j); if (j == S::npos) { aux = s.substr(i, s.length()); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) c.insert(c.end(), aux); } } } /*void split(const S& s, C c, std::vector<S>& v, bool trim_elements = true, bool include_empty_fields = false) { size_t i = 0; size_t j = s.find(c); if (j == S::npos) v.push_back(s); else while (j != S::npos) { S aux = s.substr(i, j - i); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) v.push_back(aux); i = ++j; j = s.find(c, j); if (j == S::npos) { aux = s.substr(i, s.length()); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) v.push_back(aux); } } }*/ /* template<typename CharType> std::auto_ptr<std::vector<std::basic_string<CharType> > > split (const std::basic_string<CharType>& s, CharType c, bool trim_elements = true) { std::vector<std::basic_string<CharType> > *vp = new std::vector<std::basic_string<CharType> > (); split<CharType> (s, c, *vp, trim_elements); return std::auto_ptr<std::vector<std::basic_string<CharType> > > (vp); } */ /*inline void split(S& s, C c, std::vector<S>& v, bool trim_elements = true) { split(s, c, v, trim_elements); }*/ /* inline std::auto_ptr<std::vector<std::string> > split (const std::string& s, char c, bool trim_elements = true) { return split<char> (s, c, trim_elements); } */ #ifdef CODE_GEAR #endif inline void pad(S& s, const C c, const typename S::size_type n, bool where = PAD_RIGHT) { if (n == 0) return; assert(static_cast<int>(n) > 0); const typename S::size_type length = s.length(); if (where == PAD_RIGHT) { if (n > length) s.append(n - length, c); } else { if (n > length) s.insert(0, n - length, c); } } inline S pad_copy (const S& s, const C c, const typename S::size_type n, bool where = PAD_RIGHT) { S aux(s); pad(aux, c, n, where); return aux; } inline S pad_copy(const C* s, const C c, const unsigned n, bool where = PAD_RIGHT) { assert(s != 0); S aux = s; pad(aux, c, n, where); return aux; } inline S only_digits(const S& s) { S out; for (const auto& ch : s) { if (isdigit(ch)) out += ch; } return out; } inline S only_alpha_numeric(const S& s) { S out; for (const C& ch : s) { if (isalnum(ch)) out += ch; } return out; } inline void troca_char(C* c, const std::locale& loc = std::locale(W(""))) { switch (*c) { case W('á'): case W('à'): case W('ã'): case W('ä'): case W('â'): *c = W('a'); break; case W('é'): case W('è'): case W('ë'): case W('ê'): *c = W('e'); break; case W('í'): case W('ì'): case W('ï'): case W('î'): *c = W('i'); break; case W('ó'): case W('ò'): case W('õ'): case W('ö'): case W('ô'): *c = W('o'); break; case W('ú'): case W('ù'): case W('ü'): case W('û'): *c = W('u'); break; case W('ç'): *c = W('c'); break; case W('Á'): case W('À'): case W('Ã'): case W('Ä'): case W('Â'): *c = W('A'); break; case W('É'): case W('È'): case W('Ë'): case W('Ê'): *c = W('E'); break; case W('Í'): case W('Ì'): case W('Ï'): case W('Î'): *c = W('I'); break; case W('Ó'): case W('Ò'): case W('Õ'): case W('Ö'): case W('Ô'): *c = W('O'); break; case W('Ú'): case W('Ù'): case W('Ü'): case W('Û'): *c = W('U'); break; case W('Ç'): *c = W('C'); break; default: break; } } inline void remove_accents(S& s) { for (C& ch : s) { troca_char(&ch); } } inline S no_accents(const S& s) { S r = s; remove_accents(r); return r; } template <class CharT = char> inline bool is_space(CharT c) { return std::isspace<CharT>(c, std::locale()); } template<typename T = char> inline void remove_blanks(S& s) { s.erase(std::remove_if(s.begin(), s.end(), is_space<T>), s.end()); } template<typename T = char> inline S copy_remove_accents(S s) { S s2 = s; remove_accents(s2); return s2; } template<typename T = char> inline void remove(const S& s, S& target) { typename S::size_type pos = target.find(s); while (pos != S::npos) { target.erase(pos, s.length()); pos = target.find(s); } } template<typename T = char> inline void remove_delimiters(T delimiter, S& s) { if (s[0] == delimiter && s[s.length() - 1] == delimiter) { s.erase(0, sizeof(T)); s.erase(s.length() - 1, sizeof(T)); } } template<typename T = char> inline S copy_remove(const S& s, S target) { remove(s, target); return target; } template<typename C = char> inline void remove_substr(S& s, const S& p) { std::string::size_type n = p.length(); for (std::string::size_type i = s.find(p); i != std::string::npos; i = s.find(p)) s.erase(i, n); } inline bool replace_substr(S& s, const S& o, const S& r) { if (s.size() == 0) return false; bool replaced = false; S::size_type n = o.length(); for (S::size_type i = s.find(o); i != S::npos; i = s.find(o)) { s.replace(i, n, r); replaced = true; } return replaced; } inline bool replace_substr (S& s, const C* o, const C* r) { return replace_substr (s, S(o), S(r)); } inline S insert_grouping_char (const S& s, typename S::value_type grouping_char = W(',')) { S f; unsigned primeiro = s.length() % 3; if (primeiro == 0) primeiro = 3; --primeiro; unsigned i = 0; unsigned count = 0; for (typename S::const_iterator it = s.begin(); it != s.end(); ++it) { f += *it; bool last = (++it == s.end()) ? true : false; --it; if ((i++ == primeiro || ++count == 3) && !last) { f += grouping_char; count = 0; } } return f; } inline std::wstring to_wstring(const std::string& s) { return pensar_digital::cpplib::icu::to_wstring(s); } template<typename IntType = int, bool use_grouping_char = false> S to_string(IntType number, C grouping_char = W(',')) { OutStringStream ss; ss << number; S s = ss.str(); if (number < 0) s.insert(s.begin(), W('-')); return use_grouping_char ? insert_grouping_char(s, grouping_char) : s; } template<bool use_grouping_char = false> S to_string(size_t number, typename C grouping_char = W(',')) { return to_string <size_t, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(int number, C grouping_char = W(',')) { return to_string <int, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(long number, C grouping_char = W(',')) { return to_string <long, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(long long int number, C grouping_char = W(',')) { return to_string <long long int, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(unsigned int number, C grouping_char = W(',')) { return to_string <unsigned int, use_grouping_char, C>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(unsigned long int number, C grouping_char = W(',')) { return to_string <unsigned long int, use_grouping_char>(number, grouping_char); } inline S to_string(double number, unsigned num_decimals , bool use_grouping, C grouping_char = W(','), C decimal_separator = W(',')) { long long int integer_part = (long long)trunc(number); S s = to_string(integer_part); SStream ss; ss << std::fixed << std::setprecision(num_decimals) << number; S s1 = ss.str(); typename S::size_type pos = s1.find(decimal_separator); S decimal_part = W(".00"); if (pos != S::npos) { size_t n = (num_decimals + pos) < s1.length() ? num_decimals : s1.length(); decimal_part = s1.substr(pos, n + 1); } pad(decimal_part, W('0'), num_decimals); return s + decimal_part; } inline std::string to_string(const std::wstring& s) { #ifdef WINDOWS return icu::utf16_to_utf8(s); #else return icu::utf32_to_utf8(s); #endif } inline S pad_left0(long long int number, const unsigned n = 4) { return pad_copy(pd::to_string<decltype(number), false>(number).c_str(), W('0'), n, PAD_LEFT); } inline void remove_ext(S& fname) { typename S::size_type pos = fname.find_last_of(W('.')); if (pos != S::npos) { fname.erase(pos, fname.length()); } } inline S& remove_double_spaces(S& s) { if (s.size() == 0) return s; while (replace_substr (s, W(" "), W(" "))); return s; } inline S reverse(const S& s) { S out; for (typename S::const_reverse_iterator i = s.crbegin(); i != s.crend(); ++i) { out += *i; } return out; } inline void to_upper(S& s) { for (S::iterator p = s.begin(); p != s.end(); ++p) { if (*p >= W('a') && *p <= W('z')) *p = W('A') + (*p - W('a')); else { switch (*p) { case W('á'): *p = W('Á'); break; case W('à'): *p = W('À'); break; case W('ã'): *p = W('Ã'); break; case W('ä'): *p = W('Ä'); break; case W('â'): *p = W('Â'); break; case W('é'): *p = W('É'); break; case W('è'): *p = W('È'); break; case W('ë'): *p = W('Ë'); break; case W('ê'): *p = W('Ê'); break; case W('í'): *p = W('Í'); break; case W('ì'): *p = W('Ì'); break; case W('ï'): *p = W('Ï'); break; case W('î'): *p = W('Î'); break; case W('ó'): *p = W('Ó'); break; case W('ò'): *p = W('Ò'); break; case W('õ'): *p = W('Õ'); break; case W('ö'): *p = W('Ö'); break; case W('ô'): *p = W('Ô'); break; case W('ú'): *p = W('Ú'); break; case W('ù'): *p = W('Ù'); break; case W('ü'): *p = W('Ü'); break; case W('û'): *p = W('Û'); break; case W('Ç'): *p = W('ç'); break; case W('Ñ'): *p = W('ñ'); break; default: break; } } } }; inline void to_lower(S& s) { for (S::iterator p = s.begin(); p != s.end(); ++p) { if (*p >= W('A') && *p <= W('Z')) *p = W('a') + (*p - W('A')); else { switch (*p) { case W('Á'): *p = W('á'); break; case W('À'): *p = W('à'); break; case W('Ã'): *p = W('ã'); break; case W('Ä'): *p = W('ä'); break; case W('Â'): *p = W('â'); break; case W('É'): *p = W('é'); break; case W('È'): *p = W('è'); break; case W('Ë'): *p = W('ë'); break; case W('Ê'): *p = W('ê'); break; case W('Í'): *p = W('í'); break; case W('Ì'): *p = W('ì'); break; case W('Ï'): *p = W('ï'); break; case W('Î'): *p = W('î'); break; case W('Ó'): *p = W('ó'); break; case W('Ò'): *p = W('ò'); break; case W('Õ'): *p = W('õ'); break; case W('Ö'): *p = W('ö'); break; case W('Ô'): *p = W('ô'); break; case W('Ú'): *p = W('ú'); break; case W('Ù'): *p = W('ù'); break; case W('Ü'): *p = W('ü'); break; case W('Û'): *p = W('û'); break; case W('Ç'): *p = W('ç'); break; case W('Ñ'): *p = W('ñ'); break; default: break; } } } }; inline S upper(const S& s) { S r = s; to_upper(r); return r; } inline S lower(const S& s) { S r = s; to_lower(r); return r; } /*void troca_char(wchar_t* c, const std::locale& loc) { switch (*c) { case L'\u00C0'): case L'\u00C1'): case L'\u00C2'): case L'\u00C3'): case L'\u00C4'): case L'\u00C5'): *c = L'A'); break; case L'\u00C8'): case L'\u00C9'): case L'\u00CA'): case L'\u00CB'): *c = L'E'); break; case L'\u00CC'): case L'\u00CD'): case L'\u00CE'): case L'\u00CF'): *c = L'I'); break; case L'\u00D2'): case L'\u00D3'): case L'\u00D4'): case L'\u00D5'): case L'\u00D6'): *c = L'O'); break; case L'\u00D9'): case L'\u00DA'): case L'\u00DB'): case L'\u00DC'): *c = L'U'); break; case L'\u00C7'): *c = L'C'); break; case L'\u00D1'): *c = L'N'); break; case L'\u00E0'): case L'\u00E1'): case L'\u00E2'): case L'\u00E3'): case L'\u00E4'): *c = L'a'); break; case L'\u00E8'): case L'\u00E9'): case L'\u00EA'): case L'\u00EB'): *c = L'e'); break; case L'\u00EC'): case L'\u00ED'): case L'\u00EE'): case L'\u00EF'): *c = L'i'); break; case L'\u00F2'): case L'\u00F3'): case L'\u00F4'): case L'\u00F5'): case L'\u00F6'): *c = L'o'); break; case L'\u00E7'): *c = L'c'); break; case L'\u00F1'): *c = L'n'); break; case L'\u00F9'): case L'\u00FA'): case L'\u00FB'): case L'\u00FC'): *c = L'u'); break; default: break; } } */ #ifdef CODE_GEAR /*void __fastcall split(const AnsiString& as, char c, std::vector<AnsiString>* v, bool trim_elements) { S s = as.c_str(); S::size_type i = 0; S::size_type j = s.find(c); if (j == S::npos) v->push_back(as); else while (j != S::npos) { S aux = s.substr(i, j - i); if (trim_elements) trim(aux); AnsiString s1 = aux.c_str(); v->push_back(s1); i = ++j; j = s.find(c, j); if (j == S::npos) { aux = s.substr(i, s.length()); if (trim_elements) trim(aux); s1 = aux.c_str(); v->push_back(s1); } } } AnsiString __fastcall only_digits(const AnsiString& s) { AnsiString d = ""; for (int i = 1; i <= s.Length(); i++) { if (isdigit(s[i])) d += s[i]; } return d; } AnsiString __fastcall remove_acentos(const AnsiString& s) { AnsiString sem_acentos = s; for (int i = 1; i <= s.Length(); ++i) { troca_char<char>(&sem_acentos[i]); } return sem_acentos; }*/ #endif /*void remove_accent(wchar_t* c) noexcept { switch (*c) { case L'\u00C0'): case L'\u00C1'): case L'\u00C2'): case L'\u00C3'): case L'\u00C4'): case L'\u00C5'): *c = L'A'); break; case L'\u00C8'): case L'\u00C9'): case L'\u00CA'): case L'\u00CB'): *c = L'E'); break; case L'\u00CC'): case L'\u00CD'): case L'\u00CE'): case L'\u00CF'): *c = L'I'); break; case L'\u00D2'): case L'\u00D3'): case L'\u00D4'): case L'\u00D5'): case L'\u00D6'): *c = L'O'); break; case L'\u00D9'): case L'\u00DA'): case L'\u00DB'): case L'\u00DC'): *c = L'U'); break; case L'\u00C7'): *c = L'C'); break; case L'\u00D1'): *c = L'N'); break; case L'\u00E0'): case L'\u00E1'): case L'\u00E2'): case L'\u00E3'): case L'\u00E4'): *c = L'a'); break; case L'\u00E8'): case L'\u00E9'): case L'\u00EA'): case L'\u00EB'): *c = L'e'); break; case L'\u00EC'): case L'\u00ED'): case L'\u00EE'): case L'\u00EF'): *c = L'i'); break; case L'\u00F2'): case L'\u00F3'): case L'\u00F4'): case L'\u00F5'): case L'\u00F6'): *c = L'o'); break; case L'\u00E7'): *c = L'c'); break; case L'\u00F1'): *c = L'n'); break; case L'\u00F9'): case L'\u00FA'): case L'\u00FB'): case L'\u00FC'): *c = L'u'); break; default: break; } }*/ } } #endif </DOCUMENT>
<DOCUMENT filename="sorted_list.hpp">
 #ifndef SORTED_LIST_HPP #define SORTED_LIST_HPP #include "string_def.hpp" #include <vector> #include <algorithm> #include <ranges> #include <iterator> #include <stdexcept> #include <concepts> #include <functional> namespace pensar_digital { namespace cpplib { template<typename T, typename Compare> concept ComparableWith = requires(T a, T b, Compare comp) { { comp(a, b) } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; inline void validate_index(size_t index, size_t size, const S& context = W("SortedList")) { if (index >= size) { throw std::out_of_range(context + W(": Index ") + std::to_string(index) + W(" out of bounds for size ") + std::to_string(size)); } } template<typename T, typename Compare = std::less<T>> requires ComparableWith<T, Compare>&& std::strict_weak_order<Compare, T, T> class SortedList { public: using value_type = T; using iterator = typename std::vector<T>::iterator; using const_iterator = typename std::vector<T>::const_iterator; using reverse_iterator = typename std::vector<T>::reverse_iterator; using const_reverse_iterator = typename std::vector<T>::const_reverse_iterator; using comparator_type = Compare; SortedList(bool unique = false, const Compare& comp = Compare()) : unique_(unique), comp_(comp) { } SortedList(std::initializer_list<T> init, bool unique = false, const Compare& comp = Compare()) : unique_(unique), comp_(comp) { data_.reserve(init.size()); for (const auto& item : init) { add(item); } } template<std::ranges::input_range R> SortedList(R&& range, bool unique = false, const Compare& comp = Compare()) : unique_(unique), comp_(comp) { for (const auto& item : range) { add(item); } } SortedList(const SortedList& other) = default; SortedList(SortedList&& other) noexcept = default; SortedList& operator=(const SortedList& other) = default; SortedList& operator=(SortedList&& other) noexcept = default; ~SortedList() = default; operator S() const { return to_s(); } S to_s() const { SStream ss; ss << W("["); bool first = true; for (const auto& item : *this) { if (!first) ss << W(", "); ss << item; first = false; } ss << W("]"); return ss.str(); } void set_unique(bool unique) noexcept { unique_ = unique; } bool is_unique() const noexcept { return unique_; } bool add(const T& value) { try { auto it = std::lower_bound(data_.begin(), data_.end(), value, comp_); if (unique_ && it != data_.end() && !comp_(*it, value) && !comp_(value, *it)) { return false; } data_.insert(it, value); return true; } catch (const std::exception& e) { throw std::runtime_error(W("Failed to add element: ") + S(e.what())); } } const_iterator find(const T& value) const { try { auto it = std::lower_bound(data_.begin(), data_.end(), value, comp_); if (it != data_.end() && !comp_(*it, value) && !comp_(value, *it)) return it; return data_.end(); } catch (const std::exception& e) { throw std::runtime_error(W("Failed to find element: ") + S(e.what())); } } bool remove(const T& value) { try { auto it = find(value); if (it != data_.end()) { data_.erase(it); return true; } return false; } catch (const std::exception& e) { throw std::runtime_error(W("Failed to remove element: ") + S(e.what())); } } void remove_at(size_t index) { try { validate_index(index, data_.size(), W("SortedList::remove_at")); data_.erase(data_.begin() + index); } catch (const std::exception& e) { throw std::runtime_error(W("Failed to remove element at index: ") + S(e.what())); } } T& at(size_t index) { validate_index(index, data_.size(), W("SortedList::at")); return data_[index]; } const T& at(size_t index) const { validate_index(index, data_.size(), W("SortedList::at")); return data_[index]; } T& operator[](size_t index) { validate_index(index, data_.size(), W("SortedList::operator[]")); return data_[index]; } const T& operator[](size_t index) const { validate_index(index, data_.size(), W("SortedList::operator[]")); return data_[index]; } bool contains(const T& value) const { return find(value) != data_.end(); } size_t size() const noexcept { return data_.size(); } bool empty() const noexcept { return data_.empty(); } void clear() noexcept { data_.clear(); } iterator begin() noexcept { return data_.begin(); } const_iterator begin() const noexcept { return data_.begin(); } const_iterator cbegin() const noexcept { return data_.cbegin(); } iterator end() noexcept { return data_.end(); } const_iterator end() const noexcept { return data_.end(); } const_iterator cend() const noexcept { return data_.cend(); } reverse_iterator rbegin() noexcept { return data_.rbegin(); } const_reverse_iterator rbegin() const noexcept { return data_.rbegin(); } const_reverse_iterator crbegin() const noexcept { return data_.crbegin(); } reverse_iterator rend() noexcept { return data_.rend(); } const_reverse_iterator rend() const noexcept { return data_.rend(); } const_reverse_iterator crend() const noexcept { return data_.crend(); } auto as_range() const noexcept { return std::ranges::subrange(data_.begin(), data_.end()); } const std::vector<T>& data() const noexcept { return data_; } const Compare& comparator() const noexcept { return comp_; } inline auto& last () const { if (data_.empty()) throw std::out_of_range(W("SortedList::back: List is empty")); return data_.back(); } inline auto& back() const { return last(); } private: std::vector<T> data_; bool unique_ = false; Compare comp_; }; } } #endif </DOCUMENT>
<DOCUMENT filename="stream_util.hpp">
 #ifndef STREAM_UTIL_HPP #define STREAM_UTIL_HPP #include "s.hpp" #include <iostream> #include <sstream> namespace pensar_digital { namespace cpplib { inline constexpr OutStream& out() noexcept { #ifdef WIDE_CHAR return std::wcout; #else return std::cout; #endif } inline auto StringStream() noexcept { #ifdef WIDE_CHAR return std::wstringstream (); #else return std::stringstream(); #endif } } } #endif </DOCUMENT>
<DOCUMENT filename="string_def.hpp">
 #ifndef STRING_DEF_HPP_INCLUDED #define STRING_DEF_HPP_INCLUDED namespace pensar_digital { namespace cpplib { #ifdef WIDE_CHAR using C = wchar_t; #define W(x) L ## x #else using C = char; #define W(x) x #endif inline static const C* EMPTY = W(""); inline static const C SPACE = W(' '); inline static const C* CURRENT_DIR = W("."); inline static const C* DEFAULT_TXT_FILE_EXTENSION = W(".txt"); inline static const C* DEFAULT_BIN_FILE_EXTENSION = W(".bin"); inline static const C* DOUBLE_QUOTES = W("\""); inline static const C NULL_CHAR = W('\0'); using S = std::basic_string<C>; using SView = std::basic_string_view<C>; using SIter = std::basic_string<C>::iterator; using SConstIter = std::basic_string<C>::const_iterator; using InStream = std::basic_istream<C>; using OutStream = std::basic_ostream<C>; using SStream = std::basic_stringstream<C>; using InStreamBuf = std::basic_streambuf<C>; using OutStreamBuf = std::basic_streambuf<C>; using InStreamBufIter = std::istreambuf_iterator<C>; using OutStreamBufIter = std::ostreambuf_iterator<C>; using InStringStream = std::basic_istringstream<C>; using OutStringStream = std::basic_ostringstream<C>; using InFStream = std::basic_ifstream<C>; using OutFStream = std::basic_ofstream<C>; using FStream = std::basic_fstream<C>; using InFileBuf = std::basic_filebuf<C>; using InFileBufIter = std::istreambuf_iterator<C>; using OutFileBuf = std::basic_filebuf<C>; using OutFileBufIter = std::ostreambuf_iterator<C>; } } #endif </DOCUMENT>
<DOCUMENT filename="string_types.hpp">
 #ifndef STRING_TYPES_HPP_INCLUDED #define STRING_TYPES_HPP_INCLUDED #include "s.hpp" namespace pensar_digital { namespace cpplib { } } #endif </DOCUMENT>
<DOCUMENT filename="sysinfo.hpp">
 #ifndef SYSINFO_HPP #define SYSINFO_HPP #include <vector> #include <thread> #include <chrono> #include <atomic> #include <cmath> #include <iostream> #include "code_util.hpp" namespace pensar_digital { namespace cpplib { using EstimateCPUCoresResult = Result<unsigned int>; auto estimate_cpu_threads () { const unsigned int max_threads = std::thread::hardware_concurrency() * 2; const unsigned int min_threads = 1; const double workload_duration_ms = 100.0; const double degradation_threshold = 1.20; std::vector<double> execution_times(max_threads + 1, 0.0); auto worker = [](std::atomic<bool>& running, double duration_ms) { auto start = std::chrono::high_resolution_clock::now(); double dummy = 0.0; while (running) { for (int i = 0; i < 100; ++i) { dummy += std::sin(std::cos(dummy + i)); } auto now = std::chrono::high_resolution_clock::now(); auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - start).count(); if (elapsed >= duration_ms) { break; } } if (dummy == 0.0) std::cout << ""; }; for (unsigned int num_threads = min_threads; num_threads <= max_threads; ++num_threads) { std::vector<std::thread> threads; std::atomic<bool> running(true); auto start = std::chrono::high_resolution_clock::now(); for (unsigned int i = 0; i < num_threads; ++i) { threads.emplace_back(worker, std::ref(running), workload_duration_ms); } for (auto& t : threads) { t.join(); } running = false; auto end = std::chrono::high_resolution_clock::now(); execution_times[num_threads] = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0; if (num_threads > 1) { double prev_time = execution_times[num_threads - 1]; double curr_time = execution_times[num_threads]; if (curr_time > prev_time * degradation_threshold) { return num_threads; } } } } auto cpu_threads(const unsigned int n = 10) { auto result = std::thread::hardware_concurrency(); if (result > 0) { return result; } std::vector<unsigned int> results(n); for (unsigned int i = 0; i < n; ++i) { results[i] = estimate_cpu_threads(); std::this_thread::sleep_for(std::chrono::milliseconds(50)); } std::sort(results.begin(), results.end()); unsigned int mode = results[0]; unsigned int count = 1; unsigned int max_count = 1; for (unsigned int i = 1; i < n; ++i) { if (results[i] == results[i - 1]) { count++; } else { if (count > max_count) { max_count = count; mode = results[i - 1]; } count = 1; } } if (count > max_count) { mode = results[n - 1]; } return mode; } } } #endif </DOCUMENT>
<DOCUMENT filename="system.hpp">
 #ifndef SYSTEM_HPP #define SYSTEM_HPP #ifdef _WIN32 #define _WINSOCKAPI_ #include <winsock2.h> #include <iphlpapi.h> #include <intrin.h> #include <windows.h> #elif __APPLE__ #include <sys/socket.h> #include <sys/sysctl.h> #include <net/if.h> #include <net/if_dl.h> #include <sys/statvfs.h> #elif __linux__ #include <unistd.h> #include <sys/ioctl.h> #include <net/if.h> #include <linux/if.h> #include <linux/sockios.h> #include <sys/statvfs.h> #endif #include "s.hpp" #include "mac_address.hpp" #include <iostream> #include <type_traits> #include <string> #include <bit> #include <cstdint> #include <cstring> #include <cstdio> #include <array> #include <fstream> namespace pensar_digital { namespace cpplib { #if defined(_WIN32) || defined(_WIN64) #include <windows.h> #elif __linux__ #include <unistd.h> #include <sys/utsname.h> #define MAX_PATH 4096 #define MAX_UNC_PATH 4096 #define PATH_SEPARATOR W('/') #endif static S os_name() { #if defined(_WIN32) || defined(_WIN64) return W("Windows"); #elif defined(__APPLE__) && defined(TARGET_OS_IOS) return W("iOS"); #elif defined(__ANDROID__) return W("Android"); #elif defined(__linux__) return W("Linux"); #else return W("Other"); #endif } enum class OS { Windows, Linux, MacOS, IOS, Android, Other }; inline static constexpr OS os() { #if defined(_WIN32) || defined(_WIN64) return OS::Windows; #elif defined(__APPLE__) && defined(TARGET_OS_IOS) return OS::IOS; #elif defined(__ANDROID__) return OS::Android; #elif defined(__linux__) return OS::Linux; #else return OS::Other; #endif } static S os_version() { #if defined(_WIN32) || defined(_WIN64) OSVERSIONINFO info; ZeroMemory(&info, sizeof(OSVERSIONINFO)); info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); S s = to_string(info.dwMajorVersion); s += W("."); s += to_string(info.dwMinorVersion); S r(s.c_str()); return r; #elif __linux__ struct utsname buffer; uname(&buffer); return buffer.release; #else return W("Unknown"); #endif } class BaseSystem { public: inline static constexpr size_t DEFAULT_MAX_NAME_LENGTH = 255; inline static constexpr size_t DEFAULT_MAX_PATH = 260; inline static S endianess_name() noexcept { return (std::endian::native == std::endian::little) ? W("Little Endian") : W("Big Endian"); } static std::endian endianess() noexcept { return (std::endian::native == std::endian::little) ? std::endian::little : std::endian::big; } inline static bool is_name_valid_common(const S& name) { return !name.empty() && name[0] != '.' && name.size() <= DEFAULT_MAX_NAME_LENGTH; } }; template<OS OSTtype> class System : public BaseSystem { static_assert (OSTtype == OS::Windows || OSTtype == OS::Linux || OSTtype == OS::MacOS || OSTtype == OS::IOS || OSTtype == OS::Android, W("Unsupported operating system.")); }; template<> class System<OS::Linux> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static size_t get_max_name_length () noexcept { return 255; } inline static size_t get_max_path () noexcept { #define DEFAULT_LINUX_MAX_PATH 4096 #ifdef PATH_MAX return PATH_MAX; #else return DEFAULT_LINUX_MAX_PATH; #endif } inline static constexpr C path_separator() { return W('/'); } inline static bool is_valid_file_name (const S& file_name) { return is_name_valid_common (file_name) && file_name.find (path_separator ()) == S::npos && file_name.find ('\0') == S::npos; } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common(path_name) && path_name.find('\0') == S::npos; } inline static std::vector<MacAddress> mac_addresses () { #ifdef __linux__ std::vector<MacAddress> mac_addresses; struct ifreq ifr; struct ifconf ifc; char buf[1024]; int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); if (sock == -1) { }; ifc.ifc_len = sizeof(buf); ifc.ifc_buf = buf; if (ioctl(sock, SIOCGIFCONF, &ifc) == -1) { } struct ifreq* it = ifc.ifc_req; const struct ifreq* const end = it + (ifc.ifc_len / sizeof(struct ifreq)); for (; it != end; ++it) { strcpy(ifr.ifr_name, it->ifr_name); if (ioctl(sock, SIOCGIFFLAGS, &ifr) == 0) { if (!(ifr.ifr_flags & IFF_LOOPBACK)) { if (ioctl(sock, SIOCGIFHWADDR, &ifr) == 0) { unsigned char mac_address[6]; memcpy(mac_address, ifr.ifr_hwaddr.sa_data, 6); int64_t mac; sscanf_s((char*)mac_address, "%llx", &mac); mac_addresses.push_back(MacAddress(mac)); } } } else { } return mac_addresses; #endif } #ifdef __linux__ static inline S cpu_id() { S cpu_id; InFStream cpuinfo (W("/proc/cpuinfo")); if (cpuinfo) { S line; while (std::getline (cpuinfo, line)) { if (line.substr (0, 9) == W("processor")) { cpu_id = line; break; } } } return cpu_id; } #endif }; template<> class System<OS::IOS> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static constexpr size_t get_max_name_length () noexcept { return 255; } inline static constexpr size_t get_max_path () noexcept { #define DEFAULT_IOS_MAX_PATH 4096 return DEFAULT_IOS_MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('/'); } inline static bool is_valid_file_name (const S& file_name) { return is_name_valid_common (file_name) && file_name.find (path_separator ()) == S::npos && file_name.find ('\0') == S::npos; } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } }; template<> class System<OS::Android> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static constexpr size_t get_max_name_length() noexcept { return 255; } inline static constexpr size_t get_max_path () noexcept { #define DEFAULT_ANDROID_MAX_PATH 4096 return DEFAULT_ANDROID_MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('/'); } inline static bool is_valid_file_name(const S& file_name) { return is_name_valid_common(file_name) && file_name.find(path_separator()) == S::npos && file_name.find('\0') == S::npos; } inline static bool is_valid_path(const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } }; template<> class System<OS::MacOS> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static constexpr size_t get_max_name_length () noexcept { return 255; } inline static constexpr size_t get_max_path () noexcept { #define DEFAULT_MACOS_MAX_PATH 1024 return DEFAULT_MACOS_MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('/'); } inline static bool is_valid_file_name (const S& file_name) { return is_name_valid_common (file_name) && file_name.find (path_separator ()) == S::npos && file_name.find ('\0') == S::npos; } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } inline static std::vector<MacAddress> mac_addresses () { return std::vector<MacAddress>(); } }; template<> class System <OS::Windows> : public BaseSystem { public: inline static const S LINE_FEED = W("\r\n"); inline static size_t get_max_name_length () noexcept { return 255; } inline static size_t get_max_path () noexcept { return MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('\\'); } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } inline static bool is_valid_file_name (const S& file_name) { static const S invalidChars = W("<>:\"/\\|?*"); return is_name_valid_common (file_name) && file_name.find_first_of (invalidChars) == S::npos; } #if defined(_WIN32) || defined(_WIN64) #pragma comment(lib, "IPHLPAPI.lib") #endif inline static std::vector<MacAddress> mac_addresses () { std::vector<MacAddress> mac_addresses; PIP_ADAPTER_INFO AdapterInfo; DWORD dwBufLen = sizeof(AdapterInfo); char* mac_addr = new char[18]; AdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO)); if (AdapterInfo == NULL) { printf("Error allocating memory needed to call GetAdaptersinfo\n"); return mac_addresses; } if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) { AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen); if (AdapterInfo == NULL) { printf("Error allocating memory needed to call GetAdaptersinfo\n"); return mac_addresses; } } if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) { PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; do { sprintf_s(mac_addr, 18, "%02X:%02X:%02X:%02X:%02X:%02X", pAdapterInfo->Address[0], pAdapterInfo->Address[1], pAdapterInfo->Address[2], pAdapterInfo->Address[3], pAdapterInfo->Address[4], pAdapterInfo->Address[5]); printf("Address: %s, mac: %s\n", pAdapterInfo->IpAddressList.IpAddress.String, mac_addr); int64_t mac; sscanf_s(mac_addr, "%llx", &mac); mac_addresses.push_back(MacAddress(mac)); pAdapterInfo = pAdapterInfo->Next; } while (pAdapterInfo); } free(AdapterInfo); return mac_addresses; } inline static S cpu_id() { std::array<int, 4> cpuid; __cpuid (cpuid.data (), 0); S cpu_id = to_string (cpuid[1]) + to_string (cpuid[3]); return cpu_id; } }; using Sys = System<os()>; inline const static S LF = Sys::LINE_FEED; inline static bool is_valid_path(const S& path_name) { return Sys::is_valid_file_name(path_name); } inline static bool is_valid_file_name(const S& file_name) { return Sys::is_valid_file_name(file_name); } inline static std::vector<MacAddress> mac_addresses() { return Sys::mac_addresses(); } inline static S cpu_id() { return Sys::cpu_id(); } inline static S file_name(const S& path_name) { size_t pos = path_name.find_last_of(Sys::path_separator()); if (pos == S::npos) return path_name; return path_name.substr(pos + 1); } } } #endif </DOCUMENT>
<DOCUMENT filename="sys_user_info.hpp">
 #ifndef sys_user_infoH #define sys_user_infoH #include "s.hpp" #include "io_util.hpp" #include "path.hpp" namespace pensar_digital { namespace cpplib { #ifdef _WIN32 template <bool use_exceptions = true> Path get_user_home_windows() { std::string home = ""; char* s; size_t len; errno_t err = _dupenv_s(&s, &len, "USERPROFILE"); if (err != 0) { err = _dupenv_s(&s, &len, "HOMEDRIVE"); if (err != 0) { err = _dupenv_s(&s, &len, "HOMESHARE"); } else { home = s; free(s); err = _dupenv_s(&s, &len, "HOMEPATH"); home = (err ? (home + s) : ""); } } home = (err ? "" : s); free(s); if (err and use_exceptions) { throw std::runtime_error("get_user_home_windows: Failed to get user home dir."); } return home; } #endif #if defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__)) template <bool use_exceptions = true> Path get_user_home_unix() { S home = ""; char* s; size_t len; errno_t err = _dupenv_s(&s, &len, "USERPROFILE"); if (!err) { home = s; free(s); } else { if (!s_GetHomeByUID(home)) { s_GetHomeByLOGIN(home); } } if (err and use_exceptions) { throw std::runtime_error("get_user_home_unix: Failed to get user home dir."); } } #endif template <bool use_exceptions = true> Path get_user_home() { S home; #ifdef _WIN32 return get_user_home_windows<use_exceptions>(); #elif defined(__unix__ || __APPLE__ || __linux__) return get_user_home_unix<use_exceptions>(); #else if (use_exceptions) throw std::runtime_error("get_user_home: Não foi possível pegar o diretório home do usuário pois o sistema operacional não foi identificado."); else return ""; #endif } } } #endif </DOCUMENT>
<DOCUMENT filename="transcoder.hpp">
#ifndef TRANSCODER_HPP_INCLUDED #define TRANSCODER_HPP_INCLUDED #include <unicode/ucnv.h> #include <iostream> #include <fstream> #include <sstream> #include "s.hpp" namespace pensar_digital { namespace cpplib { class Encoding { public: Encoding (const S& name) : name(name) {} operator S() const { return name; } const S& s() const noexcept { return name; } friend OutStream& operator<<(OutStream& os, const Encoding& encoding); static const Encoding UTF8; static const Encoding UTF16; static const Encoding ISO_8859_1; static const Encoding WINDOWS_1252; private: S name; }; inline OutStream& operator<<(OutStream& os, const Encoding& encoding) { os << encoding.s (); return os; } const Encoding Encoding::UTF8 (W("UTF-8" )); const Encoding Encoding::UTF16 (W("UTF-16" )); const Encoding Encoding::ISO_8859_1 (W("ISO-8859-1" )); const Encoding Encoding::WINDOWS_1252 (W("windows-1252")); #ifdef WIDE_CHAR const Encoding DefaultEncoding = Encoding::UTF16; #else const Encoding DefaultEncoding = Encoding::UTF8; #endif class Transcoder { public: Transcoder(const Encoding& in, const Encoding& out) : min(in), mout(out) {} void transcode(InStream& in_stream, OutStream& out_stream) { UErrorCode error = U_ZERO_ERROR; UConverter* in_converter = ucnv_open(min.s ().c_str (), &error); if (U_FAILURE(error)) { std::cerr << "Failed to open input converter for " << min << std::endl; return; } UConverter* out_converter = ucnv_open (mout.s ().c_str (), &error); if (U_FAILURE(error)) { std::cerr << "Failed to open output converter for " << mout << std::endl; return; } S line; while (std::getline (in_stream, line)) { const C* source = line.c_str(); const C* sourceLimit = source + line.length (); const size_t size = 1024; UChar target[size]; UChar* targetStart = target; ucnv_toUnicode (in_converter, &targetStart, &target[size - 1], &source, sourceLimit, NULL, true, &error); if (U_FAILURE (error)) { std::cerr << "Failed to convert line to Unicode" << std::endl; return; } C output[1024]; C* out_ptr = output; ucnv_fromUnicode(out_converter, &out_ptr, output + sizeof(output), (const UChar**)&target, targetStart, NULL, true, &error); if (U_FAILURE(error)) { std::cerr << "Failed to convert line from Unicode" << std::endl; return; } out_stream << output << std::endl; } ucnv_close (in_converter); ucnv_close (out_converter); } private: Encoding min; Encoding mout; }; } } #endif </DOCUMENT>
<DOCUMENT filename="type_manipulation.hpp">
#ifndef TYPE_MANIPULATION_HPP_INCLUDED #define TYPE_MANIPULATION_HPP_INCLUDED namespace pensar_digital { template <int v> struct Int2Type { enum { value = v }; }; } #endif </DOCUMENT>
<DOCUMENT filename="type_util.hpp">
 #ifndef TYPE_UTIL_HPP_INCLUDED #define TYPE_UTIL_HPP_INCLUDED #include <typeinfo> #include "constant.hpp" #include "s.hpp" namespace pensar_digital { namespace cpplib { template <class T> S class_name() noexcept { std::string s = typeid(T).name(); s.erase(0, sizeof(W("class ")) - 1); #ifdef WIDE_CHAR return to_wstring (s); #else return s; #endif } } } #endif </DOCUMENT>
<DOCUMENT filename="validation.hpp">
 #ifndef validationH #define validationH #endif #include <string> #include <locale> #include <iostream> #include <stdexcept> #include <sstream> namespace pensar_digital { namespace cpplib { static const bool USE_EXCEPTIONS = false; template <typename T, class String = std::string> bool min_check (T value, T min, String param_name = "", bool no_throw = true, std::locale loc = std::locale()) { bool ok = true; if (value < min) { std::stringstream ss; ss << param_name << " = " << value << " is less than min (" << min << ")." << std::endl; ok = false; if (no_throw) std::cerr << ss.str (); else throw std::invalid_argument (ss.str ()); } return ok; } template <typename T, class String = std::string> bool max_check (T value, T max, String param_name = "", bool no_throw = true, std::locale loc = std::locale()) { bool ok = true; if (value > max) { std::stringstream ss; ss << param_name << " = " << value << " is greater than max (" << max << ")." << std::endl; ok = false; if (no_throw) std::cerr << ss.str (); else throw std::invalid_argument (ss.str ()); } return ok; } template <typename T, class String = std::string> bool range_check (T value, T min, T max, String param_name = "", bool no_throw = true, std::locale loc = std::locale()) { bool ok = min_check (value, min, param_name, no_throw, loc); if (ok) ok = max_check (value, max, param_name, no_throw, loc); return ok; } #ifdef CODE_GEAR #include <vcl.h> extern const AnsiString MSG_INVALID_DATE; extern const AnsiString MSG_INVALID_CPF_1; extern const AnsiString MSG_INVALID_CPF_2; extern const AnsiString MSG_INVALID_NAME; extern const AnsiString MSG_EMPTY; extern const AnsiString MSG_INVALID_PHONE_NUMBER; extern const int CPF_SIZE; typedef struct vr { bool ok; AnsiString err_msg; operator bool () const { return ok; } operator std::string () const { AnsiString s = ok ? "true" + err_msg: "false, " + err_msg; std::string s1 = s.c_str (); return s1; } bool operator == (const struct vr& v) {return ok == v.ok && err_msg == v.err_msg;} } VALIDATION_RESULT; class validation_exception { private: int err_code; void* p; AnsiString err_msg; public: validation_exception (AnsiString err_message = "", void* somepointer = 0, int err = 0): err_msg(err_message), err_code(err), p(somepointer) {}; void* get_pointer () {return p;} AnsiString __fastcall what () { return err_msg; } int __fastcall get_err_code () { return err_code; } }; class cpf_exception : public validation_exception { public: cpf_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; class cnpj_exception : public validation_exception { public: cnpj_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; class date_exception : public validation_exception { public: date_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; class name_exception : public validation_exception { public: name_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; extern VALIDATION_RESULT is_valid_cpf (AnsiString cpf, void* somepointer = 0, bool use_exception = true) throw (cpf_exception); extern VALIDATION_RESULT is_valid_cnpj (AnsiString cnpj, void* somepointer = 0, bool use_exception = true) throw (cnpj_exception); extern VALIDATION_RESULT is_valid_complete_name (AnsiString name, void* somepointer = 0, bool use_exception = true) throw (name_exception); extern VALIDATION_RESULT is_not_empty (AnsiString s, void* somepointer = 0, bool use_exception = true) throw (validation_exception); extern VALIDATION_RESULT is_valid_date (AnsiString date, void* somepointer = 0, bool use_exception = true) throw (date_exception); extern VALIDATION_RESULT is_valid_phone_number (AnsiString phone, void* somepointer = 0, bool use_exception = true) throw (validation_exception); #endif } } </DOCUMENT>
<DOCUMENT filename="wstring_stream_hack.hpp">
#ifndef WSTRING_STREAM_HACK_HPP_INCLUDED #define WSTRING_STREAM_HACK_HPP_INCLUDED namespace std { extern ostream& operator << (ostream& ostr, wstring const& str); } #endif </DOCUMENT>
<DOCUMENT filename="xml_util.hpp">
 #ifndef XML_UTIL_HPP_INCLUDED #define XML_UTIL_HPP_INCLUDED #include "constant.hpp" #include "s.hpp" #include "type_util.hpp" #include "header_lib/xmlParser.h" namespace pensar_digital { namespace cpplib { template <class T> concept Objectable = requires (T t) { { t.class_name() } -> std::convertible_to<S>; { t.id() } -> std::convertible_to<Id>; }; template<Objectable T> S ObjXMLPrefix (const T& o) noexcept { return "<object class_name = \"" + o.class_name() + "\" id = \"" + std::to_string (o.id ()) + "\""; } template <class T> XMLNode parse_object_tag (const S& sxml, Id* id_from_xml) { const char* xml = sxml.c_str (); XMLCSTR tag = W("object"); XMLResults* pResults = 0; XMLNode node = XMLNode::parseString (xml, tag, pResults); S xml_class_name = node.getAttribute (W("class_name")); if (xml_class_name == class_name<T> ()) { S sid = node.getAttribute (W("id")); *id_from_xml = std::stoi (sid); } else throw std::runtime_error (W("Invalid class name")); return node; } } } #endif </DOCUMENT>
