<DOCUMENT filename="test\algorithm_util_test.cpp">
 #include <unordered_map> #include <cctype> #include <functional> #include "../../../unit-test/src/test.hpp" #include "../version.hpp" #include "../algorithm_util.hpp" #include "../s.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(algorithm_util, true) std::unordered_map<int, std::string> map; map[0] = "a"; map[1] = "1"; map[2] = "c"; erase_if(map, std::isdigit); test::CHECK_EQ(std::string, map[0], "a", "0"); CHECK_EQ(W("c"), map[2]); CHECK_EQ(2u, map.size()); std::vector<int> v(3); v[0] = 0; v[1] = 1; v[2] = 2; pd::erase_if(v, std::bind2nd(std::equal_to<int>(), 1)); CHECK_EQ(0, v[0]); CHECK_EQ(2, v[1]); CHECK_EQ(2u, v.size()); END_TEST(algorithm_util); } } </DOCUMENT>
<DOCUMENT filename="test\byte_order_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../byte_order.hpp" #include "../array.hpp" #include <span> namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { template <typename U, typename T = U> void test_byte_order_conversion(Test& t, std::vector<U> a, std::vector<T> expected, uint_fast8_t count = 0) { std::vector<T> a6; for (auto x : a) a6.push_back (x); auto data = std::span{ a }; auto b = std::as_writable_bytes(data); auto size = sizeof(U); pd::convert<>(b, size, pd::native_byte_order, pd::big_address_8_byte_order); if (sizeof(U) > sizeof(std::byte)) { if ((sizeof(T) == sizeof(U))) { Array<T> c(expected.size()); std::memcpy(c.data(), b.data(), b.size()); std::vector<T> a3(c.data(), c.data() + c.size()); static_assert (ContainerV<pd::Array<T>, T>); static_assert (ContainerV<std::vector<T>, T>); t.check_equal_collection<std::vector<T>, std::vector<T>>(a3, expected, pd::to_string<decltype(count)>(count++) + W("."), sfile (), __LINE__); pd::convert<>(b, size, pd::big_address_8_byte_order, pd::native_byte_order); std::memcpy(c.data(), b.data(), b.size()); std::vector<T> a5(c.data(), c.data() + c.size()); t.check_equal_collection<std::vector<T>, std::vector<T>>(a5, a6, pd::to_string<decltype(count)>(count++) + W("."), sfile(), __LINE__); } else { if (sizeof(T) > sizeof(U)) { /* size_t diff = sizeof(T) - sizeof(U); Array<T> c(expected.size()); for (auto i = 0; i < expected.size(); i++) { c[i] = 0x00000000; std::byte* p = (std::byte*)(&c[i]) + i * sizeof(U); *p = b[i]; *(p + 1) = b[i + 1]; } t.check<pd::Array<T>, std::vector<T>>(c, expected, pd::to_string<decltype (count)>(count++) + ".", __FILE__, __LINE__); Array<U> d(a.size()); pd::convert<>(b, size, pd::big_address_8_byte_order, pd::native_byte_order); std::memcpy(d.data(), b.data(), b.size()); t.check<Array<U>, std::vector<T>>(d, a6, pd::to_string<decltype(count)>(count++) + ".", __FILE__, __LINE__); */ } } } } TEST(ByteOrder1, true) std::vector<uint8_t> a1 = { 0, 1, 2, 3, 4, 5, 6, 7, 8 }; std::vector<uint8_t> a2 = { 0, 1, 2, 3, 4, 5, 6, 7, 8 }; test_byte_order_conversion<uint8_t > (*this, a1, a2, 0); std::vector<uint16_t> a3 = {0, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008}; std::vector<uint16_t> expected = { 0, 0x0100, 0x0200, 0x0300, 0x0400, 0x0500, 0x0600, 0x0700, 0x0800 }; test_byte_order_conversion<uint16_t> (*this, a3, expected, 1); std::vector<uint32_t> a5 = { 0, 0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008 }; std::vector<uint32_t> a6 = { 0, 0x01000000, 0x02000000, 0x03000000, 0x04000000, 0x05000000, 0x06000000, 0x07000000, 0x08000000 }; test_byte_order_conversion<uint32_t> (*this, a5, a6, 2); std::vector<uint64_t> a7 = { 0, 0x0000000000000001, 0x0000000000000002, 0x0000000000000003, 0x0000000000000004, 0x0000000000000005, 0x0000000000000006, 0x0000000000000007, 0x0000000000000008 }; std::vector<uint64_t> a8 = { 0, 0x0100000000000000, 0x0200000000000000, 0x0300000000000000, 0x0400000000000000, 0x0500000000000000, 0x0600000000000000, 0x0700000000000000, 0x0800000000000000 }; test_byte_order_conversion<uint64_t> (*this, a7, a8, 3); std::vector<int8_t> a9 = { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8 }; std::vector<int8_t> a10 = { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2 ,3, 4, 5, 6, 7, 8 }; test_byte_order_conversion<int8_t >(*this, a9, a10, 4); std::vector<int16_t > a11 = { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8 }; std::vector<uint16_t> a12 = { 0xf8ff, 0xf9ff, 0xfaff, 0xfbff, 0xfcff, 0xfdff, 0xfeff, 0xffff, 0x0000, 0x0100, 0x0200 ,0x0300, 0x0400, 0x0500, 0x0600, 0x0700, 0x0800 }; test_byte_order_conversion<int16_t, uint16_t>(*this, a11, a12, 5); std::vector<int32_t > a13 = { -8, -7, -6, -5, -4, -3, -2, -1, 0x00000000, 0x00000001, 0x00000002 ,0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008 }; std::vector<uint32_t> a14 = { 0xf8ffffff, 0xf9ffffff, 0xfaffffff, 0xfbffffff, 0xfcffffff, 0xfdffffff, 0xfeffffff, 0xffffffff, 0x0000000000000000, 0x01000000, 0x02000000 ,0x03000000, 0x04000000, 0x05000000, 0x06000000, 0x07000000, 0x08000000 }; test_byte_order_conversion<int32_t, uint32_t>(*this, a13, a14, 6); std::vector<int64_t > a15 = { -8, -7, -6, -5, -4, -3, -2, -1, 0x00000000, 0x00000001, 0x00000002 ,0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008 }; std::vector<uint64_t> a16 = { 0xf8ffffffffffffff, 0xf9ffffffffffffff, 0xfaffffffffffffff, 0xfbffffffffffffff, 0xfcffffffffffffff, 0xfdffffffffffffff, 0xfeffffffffffffff, 0xffffffffffffffff, 0x0000000000000000, 0x0100000000000000, 0x0200000000000000 ,0x0300000000000000, 0x0400000000000000, 0x0500000000000000, 0x0600000000000000, 0x0700000000000000, 0x0800000000000000 }; test_byte_order_conversion<int64_t, uint64_t>(*this, a15, a16, 7); TEST_END(ByteOrder1) } } </DOCUMENT>
<DOCUMENT filename="test\code_util_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../code_util.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { namespace code_util { using R = Result<int>; R f() { return 10; } R f1() { return W("err msg"); } TEST(Result, true) R r = f (); CHECK_EQ(R, r, 10, W("0. r != 10")); CHECK_EQ(Bool, r.mok, Bool::T, W("0. r != Bool::T")); R r1 = f1 (); CHECK (! r1, "r1 must be false."); CHECK_EQ(R::ErrorMessageType, r1.merror_message, W("err msg"), W("0. r1.merror_message != err msg")); CHECK_EQ(Bool, r1, Bool::F, W("1. r1.mok != Bool::F")); TEST_END(Result) TEST(ResultSerialization, true) using R = Result<int>; R r; MemoryBuffer mb((BytePtr)&r, sizeof(R)); R r1(0, Bool::F, R::ErrorMessageType(W("err msg"))); CHECK_NOT_EQ(R, r, r1, W("0. r == r1")); r1 = r; CHECK_EQ(R, r, r1, W("1. r != r1")); TEST_END(ResultSerialization) } } } </DOCUMENT>
<DOCUMENT filename="test\command_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../command.hpp" #include "../memory_buffer.hpp" #include "../obj_memory_buffer.hpp" namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { inline static int value = 0; class IncCmd : public Command { public: using Ptr = std::shared_ptr<IncCmd>; IncCmd(const Id aid = NULL_ID) : Command(aid) { } IncCmd(MemoryBuffer& mb) : Command(mb) { } ~IncCmd() = default; using Factory = pd::Factory<IncCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("IncCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } inline Ptr clone() const noexcept { return pd::clone<IncCmd>(*this, id()); } inline void _run() { ++value; } inline void _undo() const { --value; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class DecCmd : public Command { public: using Ptr = std::shared_ptr<DecCmd>; DecCmd(const Id aid = NULL_ID) : Command(aid) { } DecCmd(MemoryBuffer& mb) : Command(mb) { } ~DecCmd() = default; using Factory = pd::Factory<DecCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("DecCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } virtual Ptr clone() const noexcept { return pd::clone<DecCmd>(*this, id()); } void _run() { --value; } void _undo() const { ++value; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class IncFailCmd : public Command { public: using Ptr = std::shared_ptr<IncFailCmd>; IncFailCmd(const Id aid = NULL_ID) : Command(aid) { } IncFailCmd(MemoryBuffer& mb) : Command(mb) { } ~IncFailCmd() = default; using Factory = pd::Factory<IncFailCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("IncFailCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } virtual Ptr clone() const noexcept { return pd::clone<IncFailCmd>(*this, id()); } void _run() { throw "IncFailCmd.run () error."; } void _undo() const { --value; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class DoubleCmd : public Command { public: using Ptr = std::shared_ptr<DoubleCmd>; DoubleCmd(const Id aid = NULL_ID) : Command(aid) { } DoubleCmd(MemoryBuffer& mb) : Command(mb) { } ~DoubleCmd() = default; using Factory = pd::Factory<DoubleCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("DoubleCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } virtual Ptr clone() const noexcept { return pd::clone<DoubleCmd>(*this, id()); } void _run() { value *= 2; } void _undo() const { value /= 2; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class DoubleFailCmd : public Command { public: using Ptr = std::shared_ptr<DoubleFailCmd>; DoubleFailCmd(const Id aid = NULL_ID) : Command(aid) { } DoubleFailCmd(MemoryBuffer& mb) : Command(mb) { } ~DoubleFailCmd() = default; using Factory = pd::Factory<DoubleFailCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("DoubleFailCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } Ptr clone() const noexcept { return pd::clone<DoubleFailCmd>(*this, id()); } void _run() { throw "Double errors."; } void _undo() const { value /= 2; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; TEST(Command, true) { value = 0; IncCmd inc; CHECK_EQ(int, value, 0, "0"); inc.run(); CHECK_EQ(int, value, 1, "1"); inc.undo(); CHECK_EQ(int, value, 0, "2"); DecCmd dec; CHECK_EQ(int, value, 0, "3"); dec.run(); CHECK_EQ(int, value, -1, "4"); dec.undo(); CHECK_EQ(int, value, 0, "5"); IncFailCmd inc_fail; try { inc_fail.run(); } catch (...) { CHECK_EQ(int, value, 0, "6"); } } TEST_END(Command) TEST(CommandClone, true) IncCmd Cmd; IncCmd Cmd2(1); CHECK_NOT_EQ(IncCmd, Cmd, Cmd2, W("0")); auto ClonedCmd = Cmd.clone(); IncCmd* ClonedCmdPtr = (IncCmd*)ClonedCmd.get (); CHECK_EQ(IncCmd, Cmd, *ClonedCmdPtr, W("1")); TEST_END(CommandClone) TEST(CompositeCommand, true) { using Cmd = CompositeCommand; static_assert (Identifiable<Cmd>); Cmd cmd; value = 0; CHECK_EQ(int, value, 0, "0"); cmd.run(); CHECK_EQ(int, value, 0, "1"); CompositeCommand cmd2; cmd2.add(new IncCmd); cmd2.add(new DecCmd); cmd2.add(new DecCmd); cmd2.add(new DecCmd); CHECK_EQ(int, value, 0, "2"); cmd2.run(); CHECK_EQ(int, value, -2, "3"); cmd2.undo(); CHECK_EQ(int, value, 0, "4"); CompositeCommand cmd3; cmd3.add(new IncCmd); cmd3.add(new DecCmd); cmd3.add(new IncFailCmd); CHECK_EQ(int, value, 0, "5"); try { cmd3.run(); } catch (...) { CHECK_EQ(int, value, 0, "6"); } CHECK_EQ(int, value, 0, "7"); MemoryBuffer::Ptr mb_ptr = cmd2.bytes(); Cmd cmd4(*mb_ptr); value = 0; cmd2.run(); CHECK_EQ(int, value, -2, "3"); cmd2.undo(); CHECK_EQ(int, value, 0, "4"); } TEST_END(CompositeCommand) TEST(CommandBinaryFileStreaming, true) using Cmd = IncCmd; std::ofstream out(W("c:\\tmp\\test\\CommandBinaryStreaming\\test.bin"), std::ios::binary); Cmd cmd; Cmd cmd2; CHECK_NOT_EQ(Cmd, cmd, cmd2, W("0")); cmd.binary_write(out); out.close(); std::ifstream in(W("c:\\tmp\\test\\CommandBinaryStreaming\\test.bin"), std::ios::binary); cmd2.binary_read(in); CHECK_EQ(Cmd, cmd, cmd2, W("1")); TEST_END(CommandBinaryFileStreaming) TEST (CompositeCommandClone, true) using Cmd = CompositeCommand; Cmd cmd; Cmd cmd2; CHECK_NOT_EQ(Cmd, cmd, cmd2, W("0")); Cmd::Ptr cmd3 = cmd.clone(); Cmd& cmd4 = *cmd3; CHECK_EQ(Cmd, cmd4, cmd, W("1")); TEST_END(CompositeCommandClone) TEST(CompositeCmdBinaryStreaming, true) using Cmd = CompositeCommand; Cmd cmd; Cmd cmd2; CHECK_NOT_EQ(Cmd, cmd, cmd2, W("0")); MemoryBuffer::Ptr mb_ptr = cmd.bytes (); cmd2.assign(*mb_ptr); CHECK_EQ(Cmd, cmd2, cmd, W("1")); TEST_END(CompositeCmdBinaryStreaming) } } </DOCUMENT>
<DOCUMENT filename="test\concept_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../concept.hpp" #include "../constraint.hpp" namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { template <typename... Args> class Checkable0 { public: virtual bool ok (Args& ... args) const { return true; } }; class Checkable1 { public: virtual bool ok () const noexcept { return true; } }; TEST(CheckableConcept, true) static_assert(Checkable<Checkable0<int>, int>); static_assert(Checkable<Checkable0<S>, S>); static_assert(Checkable<Checkable0<>>); static_assert(Checkable<Checkable1>); static_assert(Checkable<StringConstraint, S>); TEST_END(CheckableConcept) } } </DOCUMENT>
<DOCUMENT filename="test\config_manager_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "ConfigManager.h" namespace cpp = pensar_digital::cpplib; class Dummy { private: std::string s; int i; std::vector<std::string> slist; friend class boost::serialization::access; template<typename Archive> void serialize(Archive& ar, const unsigned int version) { ar & BOOST_SERIALIZATION_NVP(s); ar & BOOST_SERIALIZATION_NVP(i); ar & BOOST_SERIALIZATION_NVP(slist); } public: Dummy (std::string s_, int i_, const std::vector<std::string>& slist_): s(s_), i(i_), slist(slist_) {} }; BOOST_AUTO_TEST_SUITE(config_manager_suite) BOOST_AUTO_TEST_CASE(config_manager_test) { cpp::ConfigManager<std::string> cfg; cfg.set ("p1", std::string("value1")); cfg.set ("p2", "2"); cfg.save (); cpp::ConfigManager<std::string> cfg2; cfg.load (); std::string p1 = cfg.get<std::string> ("p1"); int p2 = cfg.get<int> ("p2"); BOOST_CHECK_EQUAL ("value1", p1); BOOST_CHECK_EQUAL (2, p2); } BOOST_AUTO_TEST_CASE(config_manager_xml_test) { /* std::vector<std::string> v; v.push_back ("a@a.com"); v.push_back ("b@a.com"); v.push_back ("c@a.com"); TestSerialization ("teste", 1, v); cpp::ConfigManager<std::string, boost::archive::xml_oarchive, boost::archive::xml_iarchive> cfg ("config.xml"); cfg.set ("p1", "value1"); cfg.set ("p2", "2"); cfg.save (); cfg.set ("p1", ""); cfg.set ("p2", ""); cfg.load (); std::string p1 = cfg.get<std::string> ("p1"); int p2 = cfg.get<int> ("p2"); BOOST_CHECK_EQUAL ("value1", p1); BOOST_CHECK_EQUAL (2, p2); */ } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\constraint_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../constraint.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Constraint, true) StringConstraint sc (ONLY_DIGITS_REGEX); CHECK( sc.ok (W("123") ), W("0")); CHECK(!sc.ok (W("123a")), W("1")); CHECK(!sc.ok (W("a123")), W("2")); CHECK( sc.ok (W("") ), W("3")); CHECK(!sc.ok (W(" ") ), W("4")); CHECK(!sc.ok (W(" 123")), W("5")); CHECK( sc.ok (W("0") ), W("6")); StringConstraint sc2(W("^bola$")); CHECK( sc2.ok (W("bola") ), W("7")); CHECK(!sc2.ok (W(" bola")), W("8")); CHECK(!sc2.ok (W("") ), W("9")); CompositeConstraint<StringConstraint, StringConstraint> sc3 = (sc || sc2); CHECK( sc3.ok (W("bola") ), W("10")); CHECK( sc3.ok (W("123") ), W("11")); CHECK(!sc3.ok (W("123bola")), W("12")); TEST_END (Constraint); TEST(RangeConstraint, true) RangeConstraint<int> rc (0, 10); CHECK( rc.ok (0 ), W("0")); CHECK( rc.ok (10 ), W("1")); CHECK( rc.ok (5 ), W("2")); CHECK(!rc.ok (-1 ), W("3")); CHECK(!rc.ok (11 ), W("4")); CHECK(!rc.ok (100), W("5")); RangeConstraint<C> rc2 (W('A'), W('E')); CHECK( rc2.ok (W('A')), W("6")); CHECK( rc2.ok (W('E')), W("7")); CHECK( rc2.ok (W('C')), W("8")); CHECK(!rc2.ok (W('@')), W("9")); CHECK(!rc2.ok (W('F')), W("10")); CHECK(!rc2.ok (W('a')), W("11")); CHECK(!rc2.ok (W('e')), W("12")); RangeConstraint<int> rc3 (10); CHECK( rc3.ok (10), W("13")); CHECK(!rc3.ok (9 ), W("14")); CHECK(!rc3.ok (11), W("15")); TEST_END (RangeConstraint); TEST(CompositeConstraints, true) RangeConstraint<int> baby (0, 2); RangeConstraint<int> kid (3, 10); RangeConstraint<int> teen (11, 19); RangeConstraint<int> adult(20, 60); RangeConstraint<int> old (61, 200); typedef CompositeConstraint<RangeConstraint<int>, RangeConstraint<int>> CompositeRangeInt; CompositeRangeInt babies_or_kids = (baby || kid); CHECK( babies_or_kids.ok ( 0), W("0")); CHECK(!babies_or_kids.ok (11), W("1")); CHECK( babies_or_kids.ok ( 3), W("2")); CHECK( babies_or_kids.ok (10), W("3")); CompositeRangeInt teens_or_adults = (teen || adult); CHECK( teens_or_adults.ok ( 11), W("4")); CHECK( teens_or_adults.ok ( 19), W("5")); CHECK( teens_or_adults.ok ( 20), W("6")); CHECK( teens_or_adults.ok ( 60), W("7")); CHECK(!teens_or_adults.ok ( 10), W("8")); CHECK(!teens_or_adults.ok ( 61), W("9")); typedef CompositeConstraint<CompositeRangeInt, RangeConstraint<int>> Composite3RangeInt; Composite3RangeInt no_adults = (babies_or_kids || teen); CHECK( no_adults.ok ( 0), W("10")); CHECK( no_adults.ok ( 3), W("11")); CHECK( no_adults.ok ( 10), W("12")); CHECK( no_adults.ok ( 11), W("13")); CHECK( no_adults.ok ( 19), W("14")); CHECK(!no_adults.ok ( 20), W("15")); CHECK(!no_adults.ok ( 60), W("16")); CHECK(!no_adults.ok ( 61), W("17")); RangeConstraint<int> legal (18, 200); CHECK(!legal.ok(0), W("10")); CHECK(!legal.ok(3), W("11")); CHECK(!legal.ok(10), W("12")); CHECK(!legal.ok(11), W("13")); CHECK(legal.ok(19), W("14")); CHECK(legal.ok(20), W("15")); CHECK(legal.ok(60), W("16")); CHECK(legal.ok(61), W("17")); TEST_END (CompositeConstraints) } } </DOCUMENT>
<DOCUMENT filename="test\dir_util_test.cpp">
#ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <string> #include <vector> #include <algorithm> #include <iostream> #include <boost/test/unit_test.hpp> #include <filesystem_util.h> #include <io_util.h> #include "my_boost.hpp" using namespace std; using namespace boost::unit_test_framework; using namespace cpplib; const fs::path test_base_path = "dir_util_test_dir"; struct F { F() : d1(test_base_path / "dir1"), d2(test_base_path / "dir2"), d3(test_base_path / "dir3"), d4(test_base_path / "dir4"), d5(d4 / "dir5"), d6(d5 / "dir6"), p1(test_base_path / "file1"), p2(test_base_path / "file2"), p3(d1 / "file3"), p4(d2 / "file4"), p5(d6 / "file5") { if (fs::exists (test_base_path)) fs::remove_all (test_base_path); create_file<string> (p1, ""); create_file<string> (p2, ""); create_file<string> (p3, ""); create_file<string> (p4, ""); create_file<string> (p5, ""); fs::create_directory (d3); } ~F() { } fs::path d1; fs::path d2; fs::path d3; fs::path d4; fs::path d5; fs::path d6; fs::path p1; fs::path p2; fs::path p3; fs::path p4; fs::path p5; }; BOOST_FIXTURE_TEST_SUITE(dir_util_suite, F) BOOST_AUTO_TEST_CASE(get_files_test0) { vector<fs::path> expected; expected.push_back (p1); expected.push_back (p2); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); auto_ptr<vector<fs::path> > files2 = get_files (test_base_path, NO_FILTER, DO_NOT_INCLUDE_DIRS, NO_RECURSION); sort (files2->begin (), files2->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files2); } BOOST_AUTO_TEST_CASE(get_files_test1) { vector<fs::path> expected; expected.push_back (p1); expected.push_back (p2); expected.push_back (p3); expected.push_back (p4); expected.push_back (p5); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path, NO_FILTER, DO_NOT_INCLUDE_DIRS, RECURSIVE); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_CASE(get_files_test2) { vector<fs::path> expected; expected.push_back (p3); auto_ptr<vector<fs::path> > files = get_files (test_base_path, ".*3.*", DO_NOT_INCLUDE_DIRS, RECURSIVE); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_CASE(get_files_test3) { vector<fs::path> expected; expected.push_back (p3); expected.push_back (d3); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path, ".*3.*", INCLUDE_DIRS, RECURSIVE); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_CASE(get_files_test4) { vector<fs::path> expected; expected.push_back (p1); expected.push_back (p2); expected.push_back (p3); expected.push_back (p4); expected.push_back (p5); expected.push_back (d1); expected.push_back (d2); expected.push_back (d3); expected.push_back (d4); expected.push_back (d5); expected.push_back (d6); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path, NO_FILTER, INCLUDE_DIRS, RECURSIVE); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\distance_test.cpp">
#ifndef DISTANCE_TEST_HPP #define DISTANCE_TEST_HPP #include <map> #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../distance.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(DistLev, true) using Pair = std::pair<S, S>; using Map = std::map<Pair, size_t>; Map map; map[Pair (W(""), W(""))] = 0; map[Pair (W(""), W("a"))] = 1; map[Pair (W("abc"), W("abd"))] = 1; map[Pair (W("abc"), W("ab"))] = 1; map[Pair (W("abc"), W("acb"))] = 1; map[Pair (W("abc"), W("a"))] = 2; map[Pair (W("abc"), W("acd"))] = 2; map[Pair (W("abc"), W("agg"))] = 2; map[Pair (W("Campeonato Inglês Arsenal x Liverpool"), W("Campeonato Ingles ArsenalxLiverpool"))] = 3; map[Pair (W("1234"), W("456"))] = 4; map[Pair (W("PLANETA EXPN: SURFE 2009"), W("PLANETA EXPN : AVENTURAS COM RENATA FALZONI"))] = 25; map[Pair (W("Copa América Masculino de Basquete: Brasil x Porto Rico"), W("Copa América (r) Masculino de Basquete -VT- Brasil x Porto Rico"))] = 10; map[Pair (W("copaamericamasculinodebasquetebrasilxportorico"), W("copaamericamasculinodebasqueteVTbrasilxportorico"))] = 2; size_t i = 0; for (const auto& it : map) { S s = it.first.first; S t = it.first.second; size_t result = distance (s, t); std::stringstream ss; ss << s << " " << t << " " << "i = " << i++; CHECK_EQ(size_t, result, it.second, ss.str ()); } TEST_END(DistLev) } } #endif </DOCUMENT>
<DOCUMENT filename="test\factory_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../factory.hpp" #include "../s.hpp" #include "../object.hpp" #include <memory> namespace pensar_digital { using namespace pensar_digital::cpplib; namespace unit_test { TEST(NewFactory, true) { std::vector<Object::Ptr> v; v.push_back (std::make_shared<Object>(1)); CHECK(v[0].use_count() == 1, W("0. use_count() should be 1 but is ") + pd::to_string((int)v[0].use_count())); Object::Ptr ptr = v[0]; CHECK(ptr.use_count() == 2, W("1. use_count() should be 2 but is ") + pd::to_string((int)ptr.use_count())); NewFactory <Object> factory; Object::Ptr o = factory.get (); NewFactory <Object, pd::Id> factory1; Object::Ptr o1 = factory1.get (1); CHECK(*o != *o1, W("0. o != o1 should be true")); o.reset(); CHECK(o.get () == nullptr, W("1. managed object should have been deleted and assigned to nullptr.")); } TEST_END(NewFactory) TEST(SingletonFactory, true) { SingletonFactory <Object, pd::Id> factory (1); Object::Ptr o = factory.get (1); Object::Ptr o1 = factory.get (1); CHECK(*o == *o1, W("0. o == o1 should be true.")); o.reset(); CHECK(o.get () == nullptr, W("1. managed object should have been deleted and assigned to nullptr.")); } TEST_END(SingletonFactory) TEST(MockupFactory, true) { Object* mockup = new Object (1); MockupFactory<Object, pd::Id> factory (mockup); Object::Ptr o = factory.get (1); CHECK(*o == *mockup, W("0. o == mockup should be true.")); } TEST_END(MockupFactory) TEST(PoolFactory, true) { PoolFactory<Object, Object::DataType> factory (3, 10, {1}); { size_t count = factory.get_available_count(); Object::Ptr ptr; for (size_t i = 0; i < count; i++) { ptr = factory.get({1}); CHECK(factory.get_available_count () == factory.get_pool_size () - i - 1, W("0.")); } CHECK(factory.get_available_count() == 0, W("0.1. available_count should be 0 but is ") + pd::to_string((int)factory.get_available_count())); } factory.reset(3, 10, 0); CHECK(factory.get_available_count() == 3, W("1. available_count should be 3 but is ") + pd::to_string((int)factory.get_available_count ())); Object::Ptr o = factory.get ({ 1 }); CHECK(o->id () == 1, W("0. o->id () should be 1 but is ") + pd::to_string((int)o->id ())) CHECK(factory.get_available_count() == 2, W("2. available_count should be 2.")); Object::Ptr o1 = factory.get({ 2 }); CHECK(o1->id() == 2, W("3. o1->id () should be 2 but is ") + pd::to_string((int)o->id())) CHECK(factory.get_available_count() == 1, W("4. available_count should be 1.")); Object::Ptr o2 = factory.get({ 3 }); CHECK(o2->id() == 3, W("5. o2->id () should be 3 but is ") + pd::to_string((int)o->id())) CHECK(factory.get_available_count() == 0, W("6. available_count should be 0.")); Object::Ptr o3 = factory.get({ 4 }); CHECK(factory.get_available_count() == 9, W("7. available_count should be 9 but is ") + pd::to_string((int)factory.get_available_count())); CHECK(o3->id() == 4, W("8. o3->id () should be 4 but is ") + pd::to_string((int)o->id())) CHECK(*o != *o1, W("9. *o != *o1 should be true.")); o.reset(); CHECK(o.get () == nullptr, W("10. managed object should have been deleted and assigned to nullptr.")); } TEST_END(PoolFactory) } } </DOCUMENT>
<DOCUMENT filename="test\file_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../file.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(RandomFileNameGenerator, true) RandomFileNameGenerator r; Path p = r (); CHECK_EQ(Path, p.parent_path(), TMP_PATH.copy_without_trailing_separator(), W("0")); S filename = p.filename_only().str(); CHECK_EQ(S, p.extension(), W(".txt"), W("1")); CHECK_EQ(size_t, filename.length (), 8, W("2")); CHECK(filename.find_first_not_of (W("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")) == S::npos, W("3")); CHECK(filename.find_first_of (W("0123456789")) != 0, W("4")); TEST_END(RandomFileNameGenerator) TEST(TextFile, true) Path p; { p = TMP_PATH / W("text-file-test.txt"); TmpTextFile file(p, W("blah")); p = file.fullpath (); CHECK(file.exists(), W("0")); S s = file.read(); CHECK_EQ(S, s, W("blah"), W("1")); CHECK(file.remove(), W("2")); } CHECK(! p.exists(), W("0")); TEST_END(TextFile) } } </DOCUMENT>
<DOCUMENT filename="test\fixed_columns_parser_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "fixed_columns_parser.h" #include <boost/fusion/include/at_c.hpp> #include <cmath> using namespace std; namespace cpp = pensar_digital::cpplib; using namespace boost::fusion; const string line = "15213MARCOS DA SILVA BRASILEIRO RUA RUA RUA RUA RUA RU 765 APTO 23 POMPEIA SAO PAULO SP 05617000 "; BOOST_AUTO_TEST_SUITE(fixed_columns_parser_suite) BOOST_AUTO_TEST_CASE(parse_test) { cpp::FixedColumnsParser<int, string, int> parser (4, 10, 2); cpp::FixedColumnsParser<int, string, int>::ParseResult r = parser.parse("0123abcdefgh 18"); BOOST_CHECK_EQUAL (123, at_c<0>(r)); BOOST_CHECK_EQUAL ("abcdefgh ", at_c<1>(r)); BOOST_CHECK_EQUAL (18, at_c<2>(r)); typedef cpp::FixedColumnsParser<char, short, int, long, long long, float, double, long double, string, bool> Parser; Parser parser2 (1, 1, 1, 1, 1, 1, 1, 5, 3, 1); Parser::ParseResult r2 = parser2.parse("01234567.777abc0"); BOOST_CHECK_EQUAL ('0', at_c<0>(r2)); BOOST_CHECK_EQUAL (1, at_c<1>(r2)); BOOST_CHECK_EQUAL (2, at_c<2>(r2)); BOOST_CHECK_EQUAL (3L, at_c<3>(r2)); BOOST_CHECK_EQUAL ((long long)4L, at_c<4>(r2)); BOOST_CHECK_EQUAL (5.0f, at_c<5>(r2)); BOOST_CHECK_EQUAL ((double)6.0, at_c<6>(r2)); BOOST_CHECK_CLOSE ((long double)7.777, at_c<7>(r2), 0.000001); BOOST_CHECK_EQUAL ("abc", at_c<8>(r2)); BOOST_CHECK_EQUAL (false, at_c<9>(r2)); } BOOST_AUTO_TEST_CASE(parse_error) { cpp::FixedColumnsParser<int, int> parser (2, 2); bool ok = false; try { parser.parse ("11ab"); } catch (cpp::ParserException& e) { ok = true; BOOST_CHECK_EQUAL (1, e.err_column); } catch (...) {} if (! ok) BOOST_FAIL ("It was supposed to throw a ParserException exception."); } BOOST_AUTO_TEST_CASE (parse_stream_test) { const char* file_name = "FixedColumnsParser_test_file.txt"; ofstream out (file_name); out << "gato01\npato02\nsapo03"; out.close (); cpp::FixedColumnsParser<string, int> parser (4, 2); ifstream in (file_name); cpp::FixedColumnsParser<string, int>::ParseStreamResult r = parser.parse (in); in.close (); BOOST_CHECK_EQUAL ((unsigned)3, r.size () ); BOOST_CHECK_EQUAL ("gato", at_c<0> (r[0])); BOOST_CHECK_EQUAL (1, at_c<1> (r[0])); BOOST_CHECK_EQUAL ("pato", at_c<0> (r[1])); BOOST_CHECK_EQUAL (2, at_c<1> (r[1])); BOOST_CHECK_EQUAL ("sapo", at_c<0> (r[2])); BOOST_CHECK_EQUAL (3, at_c<1> (r[2])); } BOOST_AUTO_TEST_CASE (parse_file_error_test) { cpp::FixedColumnsParser<string, int> parser (4, 2); const char* file_name = "FixedColumnsParser_test_file.txt"; ofstream out (file_name); out << "gato01\nato02\nsapo03"; out.close (); bool ok = false; try { parser.parse_file (file_name); } catch (cpp::ParserException& e) { ok = true; BOOST_CHECK_EQUAL (1, e.err_line); BOOST_CHECK_EQUAL ("The line 'ato02' was supposed to have 6 chars but it has 5 instead.", e.err_message); } catch (...) {} if (! ok) BOOST_FAIL ("It was supposed to throw a ParserException exception."); } BOOST_AUTO_TEST_CASE (parse_file_test) { const char* file_name = "FixedColumnsParser_test_file.txt"; ofstream out (file_name); out << "gato01\npato02\nsapo03"; out.close (); cpp::FixedColumnsParser<string, int> parser (4, 2); cpp::FixedColumnsParser<string, int>::ParseStreamResult r = parser.parse_file (file_name); BOOST_CHECK_EQUAL ((unsigned)3, r.size () ); BOOST_CHECK_EQUAL ("gato", at_c<0> (r[0])); BOOST_CHECK_EQUAL (1, at_c<1> (r[0])); BOOST_CHECK_EQUAL ("pato", at_c<0> (r[1])); BOOST_CHECK_EQUAL (2, at_c<1> (r[1])); BOOST_CHECK_EQUAL ("sapo", at_c<0> (r[2])); BOOST_CHECK_EQUAL (3, at_c<1> (r[2])); } BOOST_AUTO_TEST_CASE (parse_12_args_test) { typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); PropayParser::ParseResult r = parser.parse (line); BOOST_CHECK_EQUAL (15213, at_c<0> (r)); BOOST_CHECK_EQUAL ("MARCOS DA SILVA BRASILEIRO ", at_c<1> (r)); BOOST_CHECK_EQUAL ("RUA RUA RUA RUA RUA RU ", at_c<2> (r)); BOOST_CHECK_EQUAL ("765 ", at_c<3> (r)); BOOST_CHECK_EQUAL ("APTO 23 ", at_c<4> (r)); BOOST_CHECK_EQUAL ("POMPEIA ", at_c<5> (r)); BOOST_CHECK_EQUAL ("SAO PAULO ", at_c<6> (r)); BOOST_CHECK_EQUAL ("SP ", at_c<7> (r)); BOOST_CHECK_EQUAL ("05617000 ", at_c<8> (r)); BOOST_CHECK_EQUAL (" ", at_c<9> (r)); } BOOST_AUTO_TEST_CASE (parse_trim_test) { typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; PropayParser::ParseResult r = parser.parse (line); BOOST_CHECK_EQUAL (15213, at_c<0> (r)); BOOST_CHECK_EQUAL ("MARCOS DA SILVA BRASILEIRO", at_c<1> (r)); BOOST_CHECK_EQUAL ("RUA RUA RUA RUA RUA RU", at_c<2> (r)); BOOST_CHECK_EQUAL ("765", at_c<3> (r)); BOOST_CHECK_EQUAL ("APTO 23", at_c<4> (r)); BOOST_CHECK_EQUAL ("POMPEIA", at_c<5> (r)); BOOST_CHECK_EQUAL ("SAO PAULO", at_c<6> (r)); BOOST_CHECK_EQUAL ("SP", at_c<7> (r)); BOOST_CHECK_EQUAL ("05617000", at_c<8> (r)); BOOST_CHECK_EQUAL ("", at_c<9> (r)); } BOOST_AUTO_TEST_CASE (parse_pad_test) { string line2 = "15213MARCOS DA SILVA BRASILEIRO RUA RUA RUA RUA RUA RU 765 APTO 23 POMPEIA SAO PAULO SP 05617000"; typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; PropayParser::ParseResult r = parser.parse (line2, true); BOOST_CHECK_EQUAL (15213, at_c<0> (r)); BOOST_CHECK_EQUAL ("MARCOS DA SILVA BRASILEIRO", at_c<1> (r)); BOOST_CHECK_EQUAL ("RUA RUA RUA RUA RUA RU", at_c<2> (r)); BOOST_CHECK_EQUAL ("765", at_c<3> (r)); BOOST_CHECK_EQUAL ("APTO 23", at_c<4> (r)); BOOST_CHECK_EQUAL ("POMPEIA", at_c<5> (r)); BOOST_CHECK_EQUAL ("SAO PAULO", at_c<6> (r)); BOOST_CHECK_EQUAL ("SP", at_c<7> (r)); BOOST_CHECK_EQUAL ("05617000", at_c<8> (r)); BOOST_CHECK_EQUAL ("", at_c<9> (r)); } BOOST_AUTO_TEST_CASE (performance_trim_test) { typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; for (int i = 0; i < 10000; i++) { PropayParser::ParseResult r = parser.parse (line); } } BOOST_AUTO_TEST_CASE (performance_pad_test) { string line2 = "15213MARCOS DA SILVA BRASILEIRO RUA RUA RUA RUA RUA RU 765 APTO 23 POMPEIA SAO PAULO SP 05617000"; typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; for (int i = 0; i < 10000; i++) { PropayParser::ParseResult r = parser.parse (line2, true); } } BOOST_AUTO_TEST_SUITE_END() </DOCUMENT>
<DOCUMENT filename="test\generator_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../generator.hpp" #include "../memory_buffer.hpp" #include "../trivially_persistable_memory_buffer.hpp" #include "../concept.hpp" #include <sstream> namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Get, true) Generator<int> g; Id expected = 1; CHECK_EQ(Id, g.get_id (), expected++, W("0")); CHECK_EQ(Id, g.get_id (), expected++, W("1")); Generator<> g2(1, 1, 2); expected = 3; CHECK_EQ(Id, g2.get_id (), expected, W("2")); expected = 5; CHECK_EQ(Id, g2.get_id (), expected, W("3")); TEST_END(Get) TEST(GetNext, true) Generator<int> g; Id expected = 1; CHECK_EQ(Id, g.next(), expected, W("0")); CHECK_EQ(Id, g.next(), expected, W("1")); Generator<> g2(1, 1, 2); expected = 3; CHECK_EQ(Id, g2.next(), expected, W("2")); CHECK_EQ(Id, g2.next(), expected, W("3")); TEST_END(GetNext) TEST(GetCurrent, true) Generator<int> g; Id expected = 0; CHECK_EQ(Id, g.current(), expected, W("0")); CHECK_EQ(Id, g.get_id () , ++expected, W("1")); CHECK_EQ(Id, g.current(), expected, W("2")); Generator<> g2(1, 1, 2); expected = 1; CHECK_EQ(Id, g2.current(), expected, W("4")); CHECK_EQ(Id, g2.get_id () , 3, W("5")); CHECK_EQ(Id, g2.current(), 3, W("6")); TEST_END(GetCurrent) TEST(SetValue, true) Generator<int> g; g.set_value (10); Id expected = 10; CHECK_EQ(Id, g.current (), 10, W("0")); CHECK_EQ(Id, g.get_id () , ++expected, W("1")); TEST_END(SetValue) TEST(SetStep, true) Generator<int> g (1, 0, 2); Id expected = 0; CHECK_EQ(Id, g.current (), expected, W("0")); CHECK_EQ(Id, g.get_id () , 2, W("1")); CHECK_EQ(Id, g.get_id () , 4, W("2")); TEST_END(SetStep) TEST(GeneratorSerialization, false) using G = Generator<int>; G g; MemoryBuffer::Ptr mb = g.bytes (); G g2 (1); CHECK_NOT_EQ(G, g2, g, W("0")); g2.assign(*mb); CHECK_EQ(G, g2, g, W("1")); TEST_END(GeneratorSerialization) TEST(GeneratorFileBinaryStreaming, false) std::ofstream out(W("c:\\tmp\\test\\GeneratorFileBinaryStreaming\\file_binary_streaming_test.bin"), std::ios::binary); typedef Generator<Object> G; typedef std::shared_ptr<G> GP; G g(1); g.binary_write(out); out.close (); out.flush (); std::ifstream in(W("c:\\tmp\\test\\GeneratorFileBinaryStreaming\\file_binary_streaming_test.bin"), std::ios::binary); GP pg2 = G::get (1); pg2->binary_read (in); in.close(); G g3(3); CHECK_NOT_EQ(G, g3, g, W("0")); CHECK_EQ(G, *pg2, g, W("1")); CHECK_EQ(VersionInt, pg2->version()->get_private (), 2, W("2")); TEST_END(GeneratorFileBinaryStreaming) TEST(GeneratorBinaryStreaming, false) typedef Generator<Object> G; static_assert (Identifiable <G>); static_assert (Hashable<G>); static_assert (TriviallyCopyable <G::DataType>); static_assert (TriviallyCopyable <G::DataType>); static_assert (TriviallyPersistable<G>); TriviallyPersistableMemoryBuffer<G> buffer; G g(1); Id id = g.get_id (); buffer.write_obj (g); Hash h = g.hash (); G::Factory::P p2 = buffer.read_obj (1); G g2 (1); Hash h2 = g2.hash (); CHECK_NOT_EQ(G, g2, g, W("0")); CHECK_EQ(G, *p2, g, "1"); G::Factory::P p3 = buffer.write_obj <Id, Id, Id>(3, 2, 1); G::Factory::P p4 = nullptr; buffer.read_obj (&p4); CHECK_EQ(G, *p4, *p3, "2"); TEST_END(GeneratorBinaryStreaming) } } </DOCUMENT>
<DOCUMENT filename="test\genetic\chromossome_test.cpp">
 #include <boost/test/unit_test.hpp> #include "../genetic/Chromossome.hpp" namespace gen = pensar_digital::genetic; BOOST_AUTO_TEST_SUITE(chromossome_suite) BOOST_AUTO_TEST_CASE(chromossome_test) { typedef gen::GeneRandomValueMutator<int> GeneMutator; GeneMutator gene_mutator(2, 3); typedef gen::Gene<int, 0, GeneMutator> G; typedef gen::Chromossome<G> C; G gene(gene_mutator); C c(10, gene); int sum = 0; for (unsigned i = 0; i < c.size (); ++i) { sum += c[i].get_value(); } BOOST_CHECK_EQUAL (0, sum); C c2 = c; BOOST_CHECK (c == c2); c.mutate(); for (unsigned i = 0; i < c.size (); ++i) { sum += c[i].get_value(); } BOOST_CHECK (sum > 1); BOOST_CHECK (c != c2); } BOOST_AUTO_TEST_CASE(chromossome_swap_gene_test) { typedef gen::Gene<int, 0> G; typedef gen::ChromossomeGeneSwapMutator<G> ChromossomeMutator; typedef gen::Chromossome<G, ChromossomeMutator> C; C c(0); for (int i = 0; i < 2; ++i) { G gene; gene = i; c.add (gene); } BOOST_CHECK_EQUAL (0, c[0].get_value()); BOOST_CHECK_EQUAL (1, c[1].get_value()); c.mutate (); BOOST_CHECK_EQUAL (1, c[0].get_value()); BOOST_CHECK_EQUAL (0, c[1].get_value()); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\genetic\gene_test.cpp">
 #include <cmath> #include <boost/test/unit_test.hpp> #include "../genetic/Gene.hpp" namespace gen = pensar_digital::genetic; BOOST_AUTO_TEST_SUITE(genetic_gene_suite) BOOST_AUTO_TEST_CASE(gene_test) { typedef gen::GeneRandomValueMutator<int> Mutator; Mutator mutator(1, 2); typedef gen::Gene<int, 0, Mutator> G; G gene(mutator); gene = 0; BOOST_CHECK_EQUAL (0, gene.get_value()); G gene2 = gene; BOOST_CHECK (gene == gene2); gene.mutate (); BOOST_CHECK (gene.get_value() > 0); BOOST_CHECK (gene != gene2); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\genetic\population_test.cpp">
 #include <cmath> #include <type_traits> #include <boost/test/unit_test.hpp> #include "../genetic/Population.hpp" namespace gen = pensar_digital::genetic; template <class ChromossomeType, class FitnessValueType = int, class Container = std::vector<ChromossomeType> > class SpecimenEvaluator { public: typedef gen::Specimen<SpecimenEvaluator, ChromossomeType, FitnessValueType, Container> S; typename S::FitnessValue evaluate (const S& s, const gen::Environment& e = gen::Environment::get_void_environment()) const { typename S::FitnessValue value = 0; for (typename Container::size_type i = 0; i < s.size (); ++i) { for (typename Container::size_type j = 0; j < s[i].size(); ++j) value += s[i][j].get_value (); } return value; }; }; BOOST_AUTO_TEST_SUITE(population_suite) BOOST_AUTO_TEST_CASE(sort_test) { typedef gen::Gene<int, 0, gen::GeneVoidMutator<>> G; typedef gen::Chromossome<G, gen::ChromossomeVoidMutator<G>> C; typedef SpecimenEvaluator<C> Evaluator; typedef gen::Specimen<Evaluator, C, int> S; typedef gen::Population<S> P; P p (3); S& s = p[1]; s[0][0] = 2; s.evaluate (); std::vector<S> v(0); v.push_back (p[0]); v.push_back (p[1]); v.push_back (p[2]); std::sort (v.begin (), v.end ()); BOOST_CHECK_EQUAL (p[1], v[2]); BOOST_CHECK_EQUAL (0, v[0].get_value ()); BOOST_CHECK_EQUAL (0, v[1].get_value ()); BOOST_CHECK_EQUAL (2, v[2].get_value ()); } BOOST_AUTO_TEST_CASE(population_test) { typedef gen::GeneRandomValueMutator<int> GeneMutator; typedef gen::Gene<int, 0, GeneMutator> G; typedef gen::ChromossomeRandomGeneMutator<G> ChromossomeMutator; typedef gen::Chromossome<G, ChromossomeMutator> C; typedef SpecimenEvaluator<C> Evaluator; typedef gen::Specimen<Evaluator, C, int> S; typedef gen::Population<S> P; GeneMutator gene_mutator(1, 2); G gene(gene_mutator); C c (10, gene); S specimen (1, c); P population (10, specimen); S::FitnessValue value = population.get_best().get_value (); BOOST_CHECK_EQUAL (0, value); population.evolve (20, 100); S::FitnessValue value2 = population.get_best().get_value (); BOOST_CHECK (value2 > 0); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\genetic\specimen_test.cpp">
 #include <cmath> #include <boost/test/unit_test.hpp> #include "../genetic/Specimen.hpp" namespace gen = pensar_digital::genetic; template <class ChromossomeType, class FitnessValueType = int, class Container = std::vector<ChromossomeType> > class SpecimenEvaluator { public: typedef gen::Specimen<SpecimenEvaluator, ChromossomeType, FitnessValueType, Container> S; typename S::FitnessValue evaluate (const S& s, const gen::Environment& e = gen::Environment::get_void_environment()) const { typename S::FitnessValue value = 0; for (typename Container::size_type i = 0; i < s.size (); ++i) { for (typename Container::size_type j = 0; j < s[i].size(); ++j) value += s[i][j].get_value (); } return value; }; }; BOOST_AUTO_TEST_SUITE(specimen_suite) BOOST_AUTO_TEST_CASE(specimen_value_test) { typedef gen::Gene<int, 0> G; typedef gen::Chromossome<G, gen::ChromossomeVoidMutator<G>> C; typedef SpecimenEvaluator<C> Evaluator; typedef gen::Specimen<Evaluator, C, int> S; C c(0); c.add (G(0)); c.add (G(1)); c.add (G(2)); c.add (G(3)); c.add (G(4)); c.add (G(5)); c.add (G(6)); c.add (G(7)); c.add (G(8)); c.add (G(9)); S s (1, c); std::stringstream ss; ss << s; std::string result = ss.str(); BOOST_CHECK_EQUAL (std::string("[(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)] = 45"), result); C c2(c); S s2 (1, c2); s2[0][0] = 1; s2.evaluate (); BOOST_CHECK_EQUAL (46, s2.get_value ()); BOOST_CHECK (s < s2); } BOOST_AUTO_TEST_CASE(specimen_test) { typedef gen::GeneRandomValueMutator<int> GeneMutator; typedef gen::Gene<int, 0, GeneMutator> G; typedef gen::ChromossomeRandomGeneMutator<G> ChromossomeMutator; typedef gen::Chromossome<G, ChromossomeMutator> C; typedef SpecimenEvaluator<C> Evaluator; typedef gen::Specimen<Evaluator, C, int> S; GeneMutator gene_mutator(1, 2); ChromossomeMutator cmutator; G gene(gene_mutator); C c (10, gene, cmutator); S specimen (10, c); S::FitnessValue value = specimen.get_value (); BOOST_CHECK_EQUAL (0, value); specimen.mutate (); S::FitnessValue value2 = specimen.get_value (); BOOST_CHECK_NE (0, value2); S s2 (10, c); BOOST_CHECK (s2 < specimen); S s(specimen); S::FitnessValue value3 = s.get_value (); BOOST_CHECK_NE (0, value3); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\html_util_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "html_util.h" #include <map> #include <string> using namespace std; namespace cpp = pensar_digital::cpplib; BOOST_AUTO_TEST_SUITE(html_util_suite) BOOST_AUTO_TEST_CASE(escape_unescapeHtml_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["&" ] = "&amp;"; map[">" ] = "&gt;"; map["<" ] = "&lt;"; map["&amp;" ] = "&amp;amp;"; map["&gt;" ] = "&amp;gt;"; map["&lt;" ] = "&amp;lt;"; map["<blah>"] = "&lt;blah&gt;"; map["<&>" ] = "&lt;&amp;&gt;"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string escaped = cpp::escape_html (s); string unescaped = cpp::unescape_html (escaped); BOOST_CHECK_EQUAL (escaped, i->second); BOOST_CHECK_EQUAL (s , unescaped); } } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\id_test.cpp">
 #include "id_test.hpp" namespace pensar_digital { namespace cpplib { } } </DOCUMENT>
<DOCUMENT filename="test\io_util_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../io_util.hpp" #include "../sys_user_info.hpp" #include "../file.hpp" #include <memory> namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { TEST(PathTest, true) Path temp_dir = get_user_home<true>() / W("test_dir"); Path file1 = temp_dir / W("file_name"); Path file2 = temp_dir / W("dir" / "file_name"); TextFile tf(file1, W("blah")); CHECK(tf.exists(), W("0")); TextFile tf2(file2, W("blah")); CHECK(tf2.exists(), W("0")); fs::last_write_time (file2, last_write_time (file1)); /*fs::last_write_time(file2, last_write_time(file1) + (time_t)60); BOOST_CHECK (! cpp::is_same (file1, file2)); Path file3 = temp_dir / "file_name3"; cpp::create_file (file3, "blah"); BOOST_CHECK (cpp::is_same (file1, file3, cpp::SAME_SIZE + cpp::SAME_TIME)); */ TEST_END(PathTest) } } </DOCUMENT>
<DOCUMENT filename="test\log_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../io_util.hpp" #include "../log.hpp" #include "../file.hpp" namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { #ifdef LOG_ON TEST(Log, true) enable_log(); LOG(W("Logging is cool and efficient.")); Path p1(default_log_file_name ()); CHECK(p1.exists (), "0"); disable_log(); p1.remove(); LOG(W("nope")); CHECK(!p1.exists(), "1"); enable_log(); LOG(W("nope")); CHECK(p1.exists(), "2"); #endif TEST_END(Log) } } </DOCUMENT>
<DOCUMENT filename="test\name_test.cpp">
 #include "../../unit-test/test.hpp" #include "../name.hpp" #include "../string_def.hpp" /*class Dummy: public pd::Name { public: Dummy(const String& aname = L""): pd::Name(aname){}; }; */ namespace pensar_digital { namespace unit_test { using namespace pensar_digital::cpplib; class Dummy: public Name { public: Dummy(const String& aname = ""): Name(aname){}; }; TEST(GetSet) String expected = "aName"; Dummy n(expected); CHECK_EQ (String, n.get_name (), expected, "0. It was supposed to be ""aName"".") expected = "another name"; n.set_name(expected); CHECK_EQ (String, n.get_name (), expected, "1. It was supposed to be ""another name"".") expected = ""; Dummy n2; CHECK_EQ (String, n2.get_name (), expected, "2. It was supposed to be """".") TEST_END(GetSet) TEST(EqOperator) Dummy n; Dummy n2; CHECK (n == n2, "0. n was supposed to be equal to n2.") n.set_name ("a"); CHECK (! (n == n2), "0. n was supposed to be different of n2.") TEST_END(EqOperator) TEST(DiffOperator) Dummy n; Dummy n2; CHECK (!(n != n2), "0. n was supposed to be equal to n2.") n.set_name ("a"); CHECK (n != n2 , "1. n was supposed to be different of n2.") TEST_END(DiffOperator) } } /* TEST(get_set_test) { std::wstring expected = L"aName"; Dummy<std::wstring> n(expected); BOOST_CHECK_EQUAL (n.get_name (), expected); expected = L"another name"; n.set_name(expected); BOOST_CHECK_EQUAL (n.get_name (), expected); expected = L""; Dummy<> n2; BOOST_CHECK_EQUAL (n2.get_name (), expected); } BOOST_AUTO_TEST_CASE(weq_operator_test) { Dummy<> n; Dummy<> n2; BOOST_CHECK (n == n2); n.set_name (L"a"); BOOST_CHECK (! (n == n2)); } BOOST_AUTO_TEST_CASE(wdiff_operator_test) { Dummy<> n; Dummy<> n2; BOOST_CHECK (!(n != n2)); n.set_name (L"a"); BOOST_CHECK (n != n2); } BOOST_AUTO_TEST_SUITE_END() */ </DOCUMENT>
<DOCUMENT filename="test\object_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../io_util.hpp" #include "../file.hpp" #include "../test/dummy.hpp" #include <memory> #include <fstream> #ifdef _MSC_VER #include <filesystem> #else #include <experimental/filesystem> #endif namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(ObjectClone, true) Factory::P o = pd::Object::get(42); Factory::P o1 = o->clone (); CHECK(*o == *o1,W("0. o == o1 should be true")); Dummy::Ptr d = Dummy::get (42,W("d")); Dummy::Ptr d1 = d->clone(); static_assert(OutputStreamable<Dummy>); CHECK_EQ(Dummy, *d1, *d,W("1. d != d1")); TEST_END(ObjectClone) TEST(ObjectSerialization, true) auto o = pd::Object::get(42); MemoryBuffer::Ptr mb = *o; auto o1 = pd::Object::get(); CHECK_NOT_EQ(Object, *o, *o1, W("0. o == o1")); o1->object_assign (*mb); CHECK_EQ(Object, *o, *o1, W("1. o != o1")); mb->reset_read_offset(); auto o2 = pd::Object::get(*mb); CHECK_EQ(Object, *o, *o2, W("1. o != o1")); TEST_END(ObjectSerialization) TEST(ObjectBinaryFileStreaming, true) std::vector<Object::Ptr> objects; const Id N = 1000; for (Id i = 0; i < N; i++) { objects.push_back(pd::Object::get(i)); } std::ofstream out (W ("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { objects[i]->bin_write(out); } out.close(); std::ifstream in (W("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { Object::Ptr o = pd::Object::get(); o->bin_read(in); Object::Ptr o1 = pd::Object::get(i); CHECK_EQ(Object, *o, *o1, pd::to_string(i)); } TEST_END(ObjectBinaryFileStreaming) TEST(ObjectBinaryFileStreaming2, true) std::vector<Object::Ptr> objects; const Id N = 1000; for (Id i = 0; i < N; i++) { objects.push_back(pd::Object::get(i)); } std::ofstream out(W("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { MemoryBuffer::Ptr mb = objects[i]->bytes(); out.write((const char*)mb->data(), mb->size()); } out.close(); std::ifstream in(W("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { MemoryBuffer mb(Object::SIZE); mb.write (in, mb.size()); Object o(mb); Object::Ptr o1 = pd::Object::get(i); CHECK_EQ(Object, o, *o1, pd::to_string(i)); } TEST_END(ObjectBinaryFileStreaming2) } } </DOCUMENT>
<DOCUMENT filename="test\path_test.cpp">
 #include "..\unit-test\test\test.hpp" #include "../cpplib/cpp namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Path, true) static_assert (TriviallyCopyable<CPath>); Path path; CHECK_EQ (Path, path, CURRENT_DIR, W("0")); path = W("\\\\"); CHECK_EQ (Path, path, path.root_path (), W("1")); path = W("c:\\tmp\\test\\path_test\\"); path.remove(); CHECK(!path.exists(), W("2")); path.create_dir (); CHECK(path.exists(), W("3")); CHECK(!path.has_filename (), W("4")); path += W("\\path_test.txt"); CHECK(path.has_filename (), W("5")); fs::remove (path); CHECK(!path.exists(), W("6")); Path path2 = path.filename (); CHECK_EQ (Path, path2, W("path_test.txt"), W("7")); path2 = path.parent_path (); CHECK_EQ (Path, path2, W("c:\\tmp\\test\\path_test"), W("8")); path2.remove (); TEST_END(Path) } } </DOCUMENT>
<DOCUMENT filename="test\random_util_test.cpp">
 #include <cmath> #include <boost/test/unit_test.hpp> #include "../random_util.hpp" #include "../log.hpp" namespace cpp = pensar_digital::cpplib; BOOST_AUTO_TEST_SUITE(random_util_suite) BOOST_AUTO_TEST_CASE(random_test) { cpp::CRandom r(0, 9); int a[10]; for (unsigned i = 0; i < 10; ++i) a[i] = 0; for (unsigned i = 0; i < 10000; ++i) { unsigned u = r.get (); a[u]++; } double variance = 0.0; for (unsigned i = 0; i < 10; ++i) { variance += pow(a[i] - 1000, 2); } variance /= 10; double standard_deviation = sqrt (variance); BOOST_CHECK (standard_deviation < 50); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\serialization_test.cpp">
#ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "serialization.hpp" #include "dummy.h" namespace cpp = pensar_digital::cpplib; namespace ser = cpp::serialization; namespace tst = cpp::test; BOOST_AUTO_TEST_SUITE(serialization_suite) BOOST_AUTO_TEST_CASE(serialization_test) { std::vector<std::string> v; v.push_back ("a@a.com"); v.push_back ("b@a.com"); v.push_back ("c@a.com"); tst::Dummy d ("teste", 1, v); std::string s; int i = 5; s = ser::to_string<int>(i); BOOST_CHECK_EQUAL (i, ser::from_string<int>(s)); s = ser::to_string<tst::Dummy>(d); tst::Dummy d2 = ser::from_string<tst::Dummy>(s); if (d == d2) BOOST_CHECK (1); else BOOST_CHECK (0); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\sorted_list_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../sorted_list.hpp" #include <cwctype> #include <clocale> namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { struct Descending { bool operator()(int a, int b) const { return a > b; } }; struct CaseInsensitive { bool operator()(const S& a, const S& b) const { S a_lower = a; S b_lower = b; #ifdef WIDE_CHAR std::transform(a_lower.begin(), a_lower.end(), a_lower.begin(), [](C c) { return std::towlower(c); }); std::transform(b_lower.begin(), b_lower.end(), b_lower.begin(), [](C c) { return std::towlower(c); }); #else std::transform(a_lower.begin(), a_lower.end(), a_lower.begin(), [](C c) { return std::tolower(c); }); std::transform(b_lower.begin(), b_lower.end(), b_lower.begin(), [](C c) { return std::tolower(c); }); #endif return a_lower < b_lower; } }; TEST(SortedList, true) std::setlocale(LC_ALL, "C"); SortedList<int> sl = {}; CHECK_EQ(int, sl.size(), 0, W("0: Default constructor size")); CHECK_EQ(bool, sl.is_unique(), false, W("1: Default constructor not unique")); sl.add(2); CHECK_EQ(int, sl.size(), 1, W("2: Size after adding one element")); CHECK_EQ(int, sl[0], 2, W("3: Element at index 0")); sl.add(0); CHECK_EQ(int, sl.size(), 2, W("4: Size after adding second element")); CHECK_EQ(int, sl[0], 0, W("5: Element at index 0 after sorting")); CHECK_EQ(int, sl[1], 2, W("6: Element at index 1 after sorting")); sl.add(1); CHECK_EQ(int, sl.size(), 3, W("7: Size after adding third element")); CHECK_EQ(int, sl[1], 1, W("8: Element at index 1 after sorting")); SortedList<int, Descending> desc_sl({ 3, 1, 4, 1, 5 }, false, Descending{}); CHECK_EQ(int, desc_sl.size(), 5, W("9: Descending list size")); CHECK_EQ(int, desc_sl[0], 5, W("10: Descending list first element")); CHECK_EQ(int, desc_sl[1], 4, W("11: Descending list second element")); CHECK_EQ(int, desc_sl[2], 3, W("12: Descending list third element")); CHECK_EQ(int, desc_sl[3], 1, W("13: Descending list fourth element")); CHECK_EQ(int, desc_sl[4], 1, W("14: Descending list fifth element")); CHECK_EQ(bool, desc_sl.add(2), true, W("15: Add 2 to descending list")); CHECK_EQ(int, desc_sl.size(), 6, W("16: Size after adding to descending list")); CHECK_EQ(int, desc_sl[3], 2, W("17: Element at index 3 after adding 2")); auto it = sl.find(1); CHECK_EQ(int, it != sl.end() ? *it : -1, 1, W("18: Find existing element")); it = sl.find(99); CHECK_EQ(bool, it == sl.end(), true, W("19: Find non-existing element")); CHECK_EQ(bool, sl.contains(2), true, W("20: Contains existing element")); CHECK_EQ(bool, sl.contains(99), false, W("21: Contains non-existing element")); CHECK_EQ(bool, sl.remove(1), true, W("22: Remove existing element")); CHECK_EQ(int, sl.size(), 2, W("23: Size after remove")); CHECK_EQ(bool, sl.contains(1), false, W("24: Element removed")); CHECK_EQ(bool, sl.remove(99), false, W("25: Remove non-existing element")); sl.remove_at(0); CHECK_EQ(int, sl.size(), 1, W("26: Size after remove_at")); CHECK_EQ(int, sl[0], 2, W("27: Element after remove_at")); int expected[] = { 2 }; int i = 0; for (const auto& item : sl) { CHECK_EQ(int, item, expected[i], W("28: Iterator element at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 1, W("29: Iterator count")); i = 0; for (const auto& item : sl.as_range()) { CHECK_EQ(int, item, expected[i], W("30: Range element at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 1, W("31: Range count")); sl.clear(); CHECK_EQ(int, sl.size(), 0, W("32: Size after clear")); CHECK_EQ(bool, sl.empty(), true, W("33: Empty after clear")); bool exception_thrown = false; try { sl[0]; } catch (const std::out_of_range&) { exception_thrown = true; } CHECK_EQ(bool, exception_thrown, true, W("34: operator[] throws on empty list")); exception_thrown = false; try { sl.at(0); } catch (const std::out_of_range&) { exception_thrown = true; } CHECK_EQ(bool, exception_thrown, true, W("35: at throws on empty list")); desc_sl.clear(); desc_sl.add(3); desc_sl.add(2); desc_sl.add(1); int rev_expected[] = { 1, 2, 3 }; i = 0; for (auto it = desc_sl.rbegin(); it != desc_sl.rend(); ++it) { CHECK_EQ(int, *it, rev_expected[i], W("36: Reverse iterator element at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 3, W("37: Reverse iterator count")); CHECK_EQ(bool, desc_sl.comparator()(5, 3), true, W("38: Comparator check (5 > 3)")); CHECK_EQ(int, desc_sl[0], 3, W("39: Descending list operator[] at index 0")); CHECK_EQ(int, desc_sl[1], 2, W("40: Descending list operator[] at index 1")); CHECK_EQ(int, desc_sl[2], 1, W("41: Descending list operator[] at index 2")); SortedList<int> asc_sl2 = {}; asc_sl2.add(5); asc_sl2.add(2); asc_sl2.add(8); asc_sl2.add(1); int asc_expected[] = { 1, 2, 5, 8 }; i = 0; for (const auto& item : asc_sl2) { CHECK_EQ(int, item, asc_expected[i], W("42: Ascending order after multiple adds at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 4, W("43: Ascending order count")); SortedList<S, CaseInsensitive> str_sl({ W("Apple"), W("banana"), W("date") }, false, CaseInsensitive{}); CHECK_EQ(int, str_sl.size(), 3, W("44: String list size")); CHECK_EQ(S, str_sl[0], W("Apple"), W("45: String list first element (case-insensitive)")); CHECK_EQ(S, str_sl[1], W("banana"), W("46: String list second element (case-insensitive)")); CHECK_EQ(S, str_sl[2], W("date"), W("47: String list third element (case-insensitive)")); CHECK_EQ(bool, str_sl.add(W("Cherry")), true, W("48: Add 'Cherry' to string list")); CHECK_EQ(S, str_sl[3], W("date"), W("49: String list after adding 'date'")); CHECK_EQ(S, str_sl.to_s(), W("[Apple, banana, Cherry, date]"), W("50: to_s after adding 'Cherry'")); CHECK_EQ(S, sl.to_s(), W("[]"), W("51: to_s on empty list")); CHECK_EQ(S, S(sl), W("[]"), W("52: Conversion to S on empty list")); CHECK_EQ(S, asc_sl2.to_s(), W("[1, 2, 5, 8]"), W("53: to_s on ascending list")); CHECK_EQ(S, S(asc_sl2), W("[1, 2, 5, 8]"), W("54: Conversion to S on ascending list")); CHECK_EQ(S, desc_sl.to_s(), W("[3, 2, 1]"), W("55: to_s on descending list")); CHECK_EQ(S, S(desc_sl), W("[3, 2, 1]"), W("56: Conversion to S on descending list")); SortedList<int, Descending> desc_sl_copy = desc_sl; CHECK_EQ(int, desc_sl_copy.size(), 3, W("57: Copy constructor size")); CHECK_EQ(int, desc_sl_copy[0], 3, W("58: Copy constructor first element")); CHECK_EQ(bool, desc_sl_copy.comparator()(5, 3), true, W("59: Copy constructor comparator")); SortedList<int, Descending> desc_sl_move = std::move(desc_sl_copy); CHECK_EQ(int, desc_sl_move.size(), 3, W("60: Move constructor size")); CHECK_EQ(int, desc_sl_move[0], 3, W("61: Move constructor first element")); CHECK_EQ(int, desc_sl_copy.size(), 0, W("62: Moved-from list size")); i = 0; for (const auto& item : sl) { i++; } CHECK_EQ(int, i, 0, W("63: Empty iterator count")); CHECK_EQ(bool, desc_sl.add(2), true, W("64: Add duplicate to non-unique descending list")); CHECK_EQ(int, desc_sl.size(), 4, W("65: Size after adding duplicate")); CHECK_EQ(int, desc_sl[1], 2, W("66: First duplicate at index 1")); CHECK_EQ(int, desc_sl[2], 2, W("67: Second duplicate at index 2")); SortedList<int> unique_sl ({}, true); CHECK_EQ(bool, unique_sl.is_unique(), true, W("68: Unique constructor")); CHECK_EQ(bool, unique_sl.add(1), true, W("69: Add to unique list")); CHECK_EQ(int, unique_sl.size(), 1, W("70: Size after first add to unique list")); CHECK_EQ(bool, unique_sl.add(1), false, W("71: Reject duplicate in unique list")); CHECK_EQ(int, unique_sl.size(), 1, W("72: Size unchanged after rejected duplicate")); unique_sl.set_unique(false); CHECK_EQ(bool, unique_sl.is_unique(), false, W("73: set_unique(false)")); CHECK_EQ(bool, unique_sl.add(1), true, W("74: Allow duplicate after set_unique(false)")); CHECK_EQ(int, unique_sl.size(), 2, W("75: Size after allowing duplicate")); CHECK_EQ(int, unique_sl[1], 1, W("76: Duplicate element at index 1")); SortedList<int, Descending> unique_desc_sl({ 3, 1 }, true, Descending{}); CHECK_EQ(bool, unique_desc_sl.is_unique(), true, W("77: Unique descending constructor")); CHECK_EQ(int, unique_desc_sl.size(), 2, W("78: Unique descending list size")); CHECK_EQ(int, unique_desc_sl[0], 3, W("79: Unique descending first element")); CHECK_EQ(int, unique_desc_sl[1], 1, W("80: Unique descending second element")); CHECK_EQ(bool, unique_desc_sl.add(3), false, W("81: Reject duplicate in unique descending list")); CHECK_EQ(int, unique_desc_sl.size(), 2, W("82: Size unchanged after rejected duplicate")); unique_desc_sl.set_unique(false); CHECK_EQ(bool, unique_desc_sl.add(3), true, W("83: Allow duplicate after set_unique(false)")); CHECK_EQ(int, unique_desc_sl.size(), 3, W("84: Size after allowing duplicate")); CHECK_EQ(int, unique_desc_sl[1], 3, W("85: Duplicate element at index 1")); SortedList<S, CaseInsensitive> unique_str_sl({ }, true, CaseInsensitive{}); CHECK_EQ(bool, unique_str_sl.add(W("Apple")), true, W("86: Add to unique string list")); CHECK_EQ(bool, unique_str_sl.add(W("apple")), false, W("87: Reject case-insensitive duplicate")); CHECK_EQ(int, unique_str_sl.size(), 1, W("88: Size after rejected string duplicate")); SortedList<int, Descending> empty_desc_sl({}, false, Descending{}); CHECK_EQ(int, empty_desc_sl.size(), 0, W("89: Empty initializer list size")); CHECK_EQ(bool, empty_desc_sl.is_unique(), false, W("90: Empty initializer list not unique")); SortedList<int, Descending> unique_init_sl({ 3, 1, 3, 1 }, true, Descending{}); CHECK_EQ(int, unique_init_sl.size(), 2, W("91: Unique initializer list size")); CHECK_EQ(int, unique_init_sl[0], 3, W("92: Unique initializer list first element")); CHECK_EQ(int, unique_init_sl[1], 1, W("93: Unique initializer list second element")); SortedList<S, CaseInsensitive> str_order_sl({ W("Cherry"), W("banana"), W("Apple"), W("date") }, false, CaseInsensitive{}); CHECK_EQ(S, str_order_sl[0], W("Apple"), W("94: Case-insensitive order first element")); CHECK_EQ(S, str_order_sl[1], W("banana"), W("95: Case-insensitive order second element")); CHECK_EQ(S, str_order_sl[2], W("Cherry"), W("96: Case-insensitive order third element")); CHECK_EQ(S, str_order_sl[3], W("date"), W("97: Case-insensitive order fourth element")); CHECK_EQ(S, str_sl.to_s(), W("[Apple, banana, Cherry, date]"), W("98: Full order string is not corrett.")); SortedList<S, CaseInsensitive> mixed_case_sl({ W("APPLE"), W("Banana"), W("cherry"), W("Date") }, false, CaseInsensitive{}); CHECK_EQ(S, mixed_case_sl[0], W("APPLE"), W("99: Mixed case order first element")); CHECK_EQ(S, mixed_case_sl[1], W("Banana"), W("100: Mixed case order second element")); CHECK_EQ(S, mixed_case_sl[2], W("cherry"), W("101: Mixed case order third element")); CHECK_EQ(S, mixed_case_sl[3], W("Date"), W("102: Mixed case order fourth element")); CaseInsensitive comp; CHECK(comp(W("Cherry"), W("date")), W("103: Error on comparing Cherry and date")); CHECK(!comp(W("date"), W("Cherry")), W("104: Error on comparing date and C")); TEST_END(SortedList) } } </DOCUMENT>
<DOCUMENT filename="test\stop_watch_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../../src/s.hpp" #include "../../src/stop_watch.hpp" #include "../../src/constraint.hpp" #include <thread> #include <chrono> namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(StopWatch, true) StopWatch<> sp; StopWatch<>::ELAPSED_TYPE T = 2 * StopWatch<>::MS; std::this_thread::sleep_for(std::chrono::nanoseconds(T)); sp.mark (); sp.stop (); StopWatch<>::ELAPSED_TYPE elapsed = sp.elapsed (); CHECK(elapsed >= T, W("0.")); StopWatch<>::ELAPSED_TYPE mark_elapsed = sp.elapsed_since_mark (); S elapsed_formatted = sp.elapsed_formatted (); S elapsed_since_mark_formatted = sp.elapsed_since_mark_formatted (); CHECK(mark_elapsed < elapsed, W("1. elapsed = ") + elapsed_formatted + W(" elapsed_since_mark = ") + elapsed_since_mark_formatted); TEST_END(StopWatch) /* TEST(Over1000msBug, true) const long long UmSegundo = 1000000000; const long long DoisSegundos = 2 * UmSegundo; StopWatch<> sw; sw.mark(); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); sw.stop(); StopWatch<>::ELAPSED_TYPE elapsed = sw.elapsed(); StopWatch<>::ELAPSED_TYPE mark_elapsed = sw.elapsed_since_mark(); S elapsed_formatted = sw.elapsed_formatted(); S elapsed_since_mark_formatted = sw.elapsed_since_mark_formatted(); CHECK(mark_elapsed < elapsed, W("1. elapsed = ") + elapsed_formatted + W(" elapsed_since_mark = ") + elapsed_since_mark_formatted); CHECK(elapsed >= UmSegundo, W("0. elapsed = ") + elapsed_formatted); CHECK(elapsed < DoisSegundos, W("2. elapsed = ") + elapsed_formatted); TEST_END(Over1000msBug) */ } } </DOCUMENT>
<DOCUMENT filename="test\string_util_test-bak.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #define BOOST_TEST_MODULE cpplib_test_module #include <boost/test/included/unit_test.hpp> #include <boost/lexical_cast.hpp> #include <vector> #include <string> #include <map> #include <set> #include <algorithm> #include "string_util.hpp" #include "my_boost.hpp" using namespace std; namespace cpp = pensar_digital::cpplib; namespace std { ostream& operator << (ostream& ostr, wstring const& str) { ostr << boost::lexical_cast<wstring>(str); return ostr; } } BOOST_AUTO_TEST_SUITE(string_util_suite) BOOST_AUTO_TEST_CASE(split_test) { typedef map<string, vector<string> > Map; vector<string> v0, v1, v2, v3; v0.push_back (""); v1.push_back ("blah"); v2.push_back ("a"); v2.push_back ("1"); v3.push_back ("2009"); v3.push_back ("10"); v3.push_back ("09"); vector<string> v4 = {"a", "b", "c", "d"}; Map map; map["" ] = v0; map["blah" ] = v1; map["a, 1" ] = v2; map["2009,10,09"] = v3; map["a,b,,c,,,d"] = v4; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; vector<string> v; cpp::split (s, ',', v); CHECK_EQUAL_COLLECTIONS(i->second, v); } for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; set<string> sset; cpp::split<set<string>> (s, ',', sset); vector<string> v (sset.size ()); std::copy (sset.begin(), sset.end (), v.begin ()); std::sort (v.begin (), v.end ()); std::sort (i->second.begin (), i->second.end ()); CHECK_EQUAL_COLLECTIONS(i->second, v); } v2[1] = " 1"; vector<string> v; cpp::split ("a, 1", ',', v, false); CHECK_EQUAL_COLLECTIONS (v2, v); } BOOST_AUTO_TEST_CASE(split_test2) { std::string s = "ESPN360 BRASIL, ESPN360"; vector<string> v; cpp::split (s, ',', v); BOOST_CHECK_EQUAL (2u, v.size ()); set<string> sset; cpp::split<set<string>> (s, ',', sset); BOOST_CHECK_EQUAL (2u, sset.size ()); } #ifdef UNICODE BOOST_AUTO_TEST_CASE(split_wstring_test) { typedef map<wstring, vector<wstring> > Map; vector<wstring> v0, v1, v2; v0.push_back (L""); v1.push_back (L"blah"); v2.push_back (L"a"); v2.push_back (L"1"); Map map; map[L"" ] = v0; map[L"blah"] = v1; map[L"a, 1"] = v2; for (Map::iterator i = map.begin (); i != map.end (); ++i) { wstring s = i->first; vector<wstring> v; cpp::split (s, ',', &v); CHECK_EQUAL_COLLECTIONS(i->second, v); cpp::WStringVectorPtr vp = cpp::split (s, ','); CHECK_EQUAL_COLLECTIONS(i->second, *vp); } v2[1] = L" 1"; vector<wstring> v; cpp::split (L"a, 1", L',', &v, false); CHECK_EQUAL_COLLECTIONS (v2, v); } #endif BOOST_AUTO_TEST_CASE(pad_copy_test) { string abc = "abc"; BOOST_CHECK_EQUAL ("abc ", cpp::pad_copy (abc, ' ', 6)); BOOST_CHECK_EQUAL ("abc ", cpp::pad_copy ("abc", ' ', 6)); BOOST_CHECK_EQUAL ("abc", cpp::pad_copy ("abc", ' ', 3)); BOOST_CHECK_EQUAL ("abc ", cpp::pad_copy ("abc", ' ', 4)); string empty = ""; BOOST_CHECK_EQUAL (" ", cpp::pad_copy (empty, ' ', 6)); BOOST_CHECK_EQUAL ("abc000", cpp::pad_copy ("abc", '0', 6)); BOOST_CHECK_EQUAL ("abc", cpp::pad_copy ("abc", '0', 3)); BOOST_CHECK_EQUAL ("abc0", cpp::pad_copy ("abc", '0', 4)); BOOST_CHECK_EQUAL ("000000", cpp::pad_copy (empty, '0', 6)); BOOST_CHECK_EQUAL ("000abc", cpp::pad_copy ("abc", '0', 6, cpp::PAD_LEFT)); } BOOST_AUTO_TEST_CASE(only_digits_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = ""; map["12 34a5"] = "12345"; map["123.607.834-07" ] = "12360783407"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::only_digits (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(only_alpha_numeric_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["12 34a5"] = "1234a5"; map["123.607.834-07" ] = "12360783407"; map["a-1,b;2"] = "a1b2"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::only_alpha_numeric (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(remove_blanks_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map[" blah " ] = "blah"; map["12 34 5" ] = "12345"; map["123 456\n\n789\t01"] = "12345678901"; map["á è î õ ü A É Í Ô Ü"] = "áèîõüAÉÍÔÜ"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string result = i->first; cpp::remove_blanks (result); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(remove_accents_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["José da Silva" ] = "Jose da Silva"; map["áàãäâ éèëê íìïî óòõöô úùüû ç"] = "aaaaa eeee iiii ooooo uuuu c"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::copy_remove_accents (s); BOOST_CHECK_EQUAL (result, i->second); } string a = "á"; string s = cpp::copy_remove_accents (a); BOOST_CHECK_EQUAL ("á", a); BOOST_CHECK_EQUAL ("a", s); } BOOST_AUTO_TEST_CASE(remove_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["AO VIVO José da Silva" ] = " José da Silva"; map["Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = "Campeonato Paulista: Palmeiras x Corinthians "; map["AO VIVO"] = ""; map["1 AO VIVO2"] = "1 2"; map["1 AO VIVO 2"] = "1 2"; map["1AO VIVO2"] = "12"; map["1AO VIVO234"] = "1234"; map["AO VIVO, José da Silva" ] = ", José da Silva"; map["AO VIVO1 José da Silva" ] = "1 José da Silva"; map["AO VIVO2 José da Silva" ] = "2 José da Silva"; map["1AO VIVO2 José da Silva" ] = "12 José da Silva"; map["---AO VIVO---"] = "------"; map["1AO VIVO2AO VIVO3"] = "123"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::copy_remove (string("AO VIVO"), s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(remove_delimiter_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["\"José da Silva\"" ] = "José da Silva"; map["\"áàãäâ éèëê íìïî óòõöô úùüû ç\""] = "áàãäâ éèëê íìïî óòõöô úùüû ç"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::remove_delimiters ('"', s); BOOST_CHECK_EQUAL (s, i->second); } } BOOST_AUTO_TEST_CASE(reverse_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "halb"; map["12 34a5"] = "5a43 21"; map["123.607.834-07" ] = "70-438.706.321"; map["a"] = "a"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::reverse (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(wreverse_test) { typedef map<wstring, wstring> Map; Map map; map[L"" ] = L""; map[L"blah" ] = L"halb"; map[L"12 34a5"] = L"5a43 21"; map[L"123.607.834-07" ] = L"70-438.706.321"; map[L"a"] = L"a"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { wstring s = i->first; wstring result = cpp::reverse (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(to_lower_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["AO VIVO JOSÉ"] = "ao vivo josé"; map["Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = "campeonato paulista: palmeiras x corinthians ao vivo"; map["1 AO VIVO2"] = "1 ao vivo2"; map["---"] = "---"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::to_lower (s); BOOST_CHECK_EQUAL (s, i->second); } } BOOST_AUTO_TEST_CASE(to_upper_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["BLAH" ] = "BLAH"; map["ao vivo josé"] = "AO VIVO JOSÉ"; map["Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = "CAMPEONATO PAULISTA: PALMEIRAS X CORINTHIANS AO VIVO"; map["1 ao vivo2"] = "1 AO VIVO2"; map["---"] = "---"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::to_upper (s); BOOST_CHECK_EQUAL (s, i->second); } } /* BOOST_AUTO_TEST_CASE(to_upperw_test) { typedef map<wstring, wstring> Map; Map map; map[L"" ] = L""; map[L"BLAH" ] = L"BLAH"; map[L"ao vivo josé"] = L"AO VIVO JOSÉ"; map[L"Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = L"CAMPEONATO PAULISTA: PALMEIRAS X CORINTHIANS AO VIVO"; map[L"1 ao vivo2"] = L"1 AO VIVO2"; map[L"---"] = L"---"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { wstring s = i->first; cpp::to_upper (s); BOOST_CHECK_EQUAL (s, i->second); } } */ BOOST_AUTO_TEST_CASE(replace_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["BLAH" ] = "BLAH"; map["ao orig jose"] = "ao replaced jose"; map["Palmeiras x orig"] = "Palmeiras x replaced"; map["orig2orig"] = "replaced2replaced"; map["orig"] = "replaced"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::replace_substr (s, std::string("orig"), std::string("replaced")); BOOST_CHECK_EQUAL (s, i->second); } std::string s = "a a"; BOOST_CHECK(cpp::replace_substr (s, " ", " ")); BOOST_CHECK_EQUAL(s, "a a"); s = "55 11 123-4567"; while (cpp::replace_substr (s, " ", " ")); BOOST_CHECK_EQUAL(s, "55 11 123-4567"); } BOOST_AUTO_TEST_CASE(to_string_unsigned_test) { typedef map<unsigned, string> Map; Map map; map[0 ] = "0"; map[1 ] = "1"; map[123 ] = "123"; map[1234 ] = "1,234"; map[12345 ] = "12,345"; map[123456 ] = "123,456"; map[1234567] = "1,234,567"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { unsigned u = i->first; std::string s = cpp::to_string (u); BOOST_CHECK_EQUAL (s, i->second); } BOOST_CHECK_EQUAL ("1.234.567", cpp::to_string((unsigned)1234567, '.')); } BOOST_AUTO_TEST_CASE(to_string_int_test) { typedef map<int, string> Map; Map map; map[0 ] = "0"; map[-1 ] = "-1"; map[123 ] = "123"; map[-1234 ] = "-1,234"; map[12345 ] = "12,345"; map[-123456] = "-123,456"; map[1234567] = "1,234,567"; for (Map::iterator it = map.begin (); it != map.end (); ++it) { int i = it->first; std::string s = cpp::to_string ((int)i); BOOST_CHECK_EQUAL (s, it->second); } BOOST_CHECK_EQUAL ("1.234.567", cpp::to_string(1234567, '.')); } BOOST_AUTO_TEST_CASE(to_string_double_test) { typedef map<double, string> Map; Map map; map[0 ] = "0.00"; map[-1 ] = "-1.00"; map[123.01 ] = "123.01"; map[-1234.02 ] = "-1,234.02"; map[12345.123 ] = "12,345.12"; for (Map::iterator it = map.begin (); it != map.end (); ++it) { double d = it->first; std::string s = cpp::to_string (d); BOOST_CHECK_EQUAL (s, it->second); } std::string s = cpp::to_string (12345.123, 3); BOOST_CHECK_EQUAL(s, "12,345.123"); } BOOST_AUTO_TEST_CASE(remove_ext_test) { typedef map<string, string> Map; Map map; map["" ] = "" ; map["blah" ] = "blah" ; map["fname.txt" ] = "fname" ; map["fname.txt.txt" ] = "fname.txt"; map["fname.extension"] = "fname" ; map[".ext" ] = "" ; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::remove_ext (s); BOOST_CHECK_EQUAL (s, i->second); } } BOOST_AUTO_TEST_SUITE_END() </DOCUMENT>
<DOCUMENT filename="test\s_test.cpp">
 #include "..\unit-test\test\test.hpp" #include "../cpplib/cpp/s.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(CS, true) static_assert(TriviallyCopyable<CS<10>>, W("S is not compliant with StdLayoutTriviallyCopyable concept.")); CS<> s; CS<> s1; CHECK_EQ(CS<>, s, s1, W("0")); s = W("abc"); CHECK_NOT_EQ(CS<>, s, s1, W("1")); CHECK_EQ(CS<>, s, W("abc"), W("2")); CHECK_EQ(size_t, s.length(), 3, W("3")); CHECK_EQ(size_t, s.size(), CS<>::MAX_SIZE, W("4")); CS<> s2 = W("abc"); CHECK_EQ(CS<>, s2.to_string(), W("abc"), W("5")); CHECK(s == s2, W("6")); s2 = W("def"); CHECK_EQ(CS<>, s2, W("def"), W("7")); static_assert (pd::OutputStreamable<CS<>>, "S is not OutputStreamable"); typedef CS<0, 20> WC; WC w = W("abc"); static_assert (pd::OutputStreamable<WC>, "W is not OutputStreamable"); S str = W("abc"); CS<> s3 = str; CHECK_EQ(CS<>, s3, W("abc"), W("9")); CS<> s4 = W("abc"); CS<> s5 = W("def"); CS<> s6 = s4 + s5; CHECK_EQ(CS<>, s6, W("abcdef"), W("11")); TEST_END(CS) } } </DOCUMENT>
<DOCUMENT filename="test\time_util_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "time_util.h" namespace pd = pensar_digital::cpplib; BOOST_AUTO_TEST_SUITE(time_util_suite) BOOST_AUTO_TEST_CASE(stimestamp_test) { std::string s = "2009-10-09 20:40:22"; time_t t = pd::sdatetime2time_t (s); std::string s1 = pd::stimestamp (t); BOOST_CHECK_EQUAL (s, s1); std::string s2 = pd::stimestamp (); } BOOST_AUTO_TEST_CASE(today_test) { std::string stoday = pd::today (); std::string stoday2 = pd::today ("%m%y"); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\version_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../version.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Version, true) Version::Ptr v = Version::get(2, 3, 4); CHECK_EQ(Version, v->get_public(), 2, W("0. public != 2")); CHECK_EQ(Version, v->get_protected(), 3, W("1. protected != 3")); CHECK_EQ(Version, v->get_private(), 4, W("2. private != 4")); TEST_END(Version) TEST(VersionSerialization, true) Version::Ptr v = Version::get(2, 3, 4); MemoryBuffer::Ptr mb = v->bytes(); Version::Ptr v1 = Version::get(); CHECK_NOT_EQ(Version, *v, *v1, W("0. v == v1")); v1->assign(*mb); CHECK_EQ(Version, *v, *v1, W("1. v != v1")); CHECK_EQ(Version::Int, v->get_public(), 2, W("2. public != 2")); CHECK_EQ(Version::Int, v->get_protected(), 3, W("3. protected != 3")); CHECK_EQ(Version::Int, v->get_private(), 4, W("4. private != 4")); TEST_END(VersionSerialization) } } </DOCUMENT>
<DOCUMENT filename="test.cpp">
 #include "framework.h" #include "test.hpp" #include "../../cpplib/cpp/string_def.hpp" #include "../../cpplib/cpp/constant.hpp" namespace pensar_digital { namespace unit_test { Generator<CompositeTest> CompositeTest::generator = Generator<CompositeTest> (); Generator<Test> Test::generator = Generator<Test> (); CompositeTest& all_tests () { static CompositeTest* all = new CompositeTest(W("All tests")); return *all; } } } </DOCUMENT>
