<DOCUMENT filename="bool.hpp">
#ifndef BOOL_HPP #define BOOL_HPP #include "concept.hpp" #include <cstdint> namespace pensar_digital { namespace cpplib { struct Bool { static const int_fast8_t UNKNOWN = -1; static const int_fast8_t F = 0; static const int_fast8_t T = 1; int_fast8_t mvalue = UNKNOWN; Bool() = default; Bool(const Bool&) = default; Bool(Bool&&) = default; Bool& operator=(const Bool&) = default; Bool& operator=(Bool&&) = default; ~Bool() = default; constexpr Bool(int_fast8_t value) : mvalue(value) {} constexpr Bool(bool value) : mvalue(value ? T : F) {} constexpr operator bool() const { return mvalue == T; } constexpr operator int_fast8_t() const { return mvalue; } constexpr bool operator==(const Bool& other) const { return mvalue == other.mvalue; } }; static_assert(std::is_trivially_copyable<Bool>::value, "Bool must be trivially copyable."); } } #endif </DOCUMENT>
<DOCUMENT filename="bytes_util.hpp">
 #ifndef BYTES_UTIL_HPP_INCLUDED #define BYTES_UTIL_HPP_INCLUDED #include "constant.hpp" #include "concept.hpp" #include <span> #include <string> #include <vector> #include <cstddef> #include <bit> namespace pensar_digital { namespace cpplib { extern void string_to_bytes (const std::string& s, ByteSpan& v); extern void string_to_bytes (const std::wstring& s, ByteSpan& v); extern void bytes_to_string (const ByteSpan& bytes, std::string& s); extern void bytes_to_wstring (ByteSpan& bytes, std::wstring s); extern void add_bytes (const ByteSpan& bytes, ByteSpan& dest); extern void add_string_to_bytes (const std::string& s, ByteSpan& bytes); template <typename T> void add_number_to_bytes(const T n, ByteSpan& bytes) { const std::byte* p = reinterpret_cast<const std::byte*>(&n); constexpr size_t size = sizeof(T); ByteSpan number_bytes(p, p + size); add_bytes(number_bytes, bytes); } extern void int16_t_to_bytes (const int16_t i, ByteSpan& bytes); extern void int32_t_to_bytes (const int32_t i, ByteSpan& bytes); extern void int64_t_to_bytes (const int64_t i, ByteSpan& bytes); extern void int_to_bytes (const int i, ByteSpan& bytes); extern void uint16_t_to_bytes (const uint16_t i, ByteSpan& bytes); extern void uint32_t_to_bytes (const uint32_t i, ByteSpan& bytes); extern void uint64_t_to_bytes (const uint64_t i, ByteSpan& bytes); extern void uint_to_bytes (const unsigned int i, ByteSpan& bytes); extern void float_to_bytes (const float f, ByteSpan& bytes); extern void double_to_bytes (const double d, ByteSpan& bytes); extern void bool_to_bytes (const bool b, ByteSpan& bytes); extern void long_to_bytes (const long l, ByteSpan& bytes); extern void ulong_to_bytes (const unsigned long l, ByteSpan& bytes); extern void long_long_to_bytes (const long long ll, ByteSpan& bytes); extern void ulong_long_to_bytes (const unsigned long long ll, ByteSpan& bytes); template <TriviallyCopyable T> T bytes_to_type(const ByteSpan& bytes) { T t; std::memcpy(&t, bytes.data(), sizeof(T)); return t; } } } #endif </DOCUMENT>
<DOCUMENT filename="byte_array.hpp">
#ifndef BYTE_ARRAY_HPP #define BYTE_ARRAY_HPP #include "constant.hpp" #include <memory> namespace pensar_digital { namespace cpplib { class ByteArray; using ByteArrayPtr = std::unique_ptr<ByteArray>; class ByteArray { private: Byte* mdata; size_t msize; public: ByteArray(const size_t size = 0) : mdata(new Byte[size]), msize(size) {} ByteArray(const ByteArray& other) : mdata(new Byte[other.msize]), msize(other.msize) { for (size_t i = 0; i < msize; ++i) mdata[i] = other.mdata[i]; } ByteArray(ByteArray&& other) noexcept : mdata(other.mdata), msize(other.msize) { other.mdata = nullptr; other.msize = 0; } ~ByteArray() { delete[] mdata; } Byte& operator[] (const size_t index) { return mdata[index]; } const Byte& operator[] (const size_t index) const { return mdata[index]; } ByteArray& operator= (const ByteArray& other) { if (this != &other) { delete[] mdata; mdata = new Byte[other.msize]; msize = other.msize; memcpy(mdata, other.mdata, msize); } return *this; } ByteArray& operator= (ByteArray&& other) noexcept { if (this != &other) { delete[] mdata; mdata = other.mdata; msize = other.msize; other.mdata = nullptr; other.msize = 0; } return *this; } ByteArray& copy (const ByteArray& ba, const size_t offset = 0) { if ((ba.size () + offset) > msize) { delete[] mdata; msize = ba.size() + offset; mdata = new Byte[msize]; } memcpy(mdata + offset, ba.data (), size); return *this; } ByteArray& append (const ByteArray& ba) { i Byte* new_data = new Byte[msize + ba.size()]; memcpy(new_data, mdata, msize); memcpy(new_data + msize, ba.data(), ba.size()); delete[] mdata; mdata = new_data; msize += ba.size(); return *this; } size_t size() const { return msize; } Byte* data() { return mdata; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="byte_order.hpp">
 #ifndef BYTE_ORDER_HPP #define BYTE_ORDER_HPP #include <span> #include <bit> namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; enum Invariance : bool { DATA_INVARIANCE = false, ADDRESS_INVARIANCE = true}; typedef int_fast8_t Word; constexpr Word WORD_SIZE = sizeof (Word); template <typename T> inline void swap (T& a, T& b) noexcept { T tmp = std::move (a); a = std::move (b); b = std::move (tmp); } struct ByteOrder { std::endian mendian = std::endian::native ; Invariance minvariance = ADDRESS_INVARIANCE ; Word maddress_size = sizeof (std::byte); ByteOrder (const std::endian endian = std::endian::native, const Invariance invariance = ADDRESS_INVARIANCE, const Word address_size = sizeof (Word)) noexcept : mendian (endian), minvariance (invariance), maddress_size (address_size) {} inline bool is_address_invariant () const noexcept { return minvariance == ADDRESS_INVARIANCE; } inline bool is_data_invariant () const noexcept { return minvariance == DATA_INVARIANCE; } inline bool is_little_endian () const noexcept { return mendian == std::endian::little; } inline bool is_big_endian () const noexcept { return mendian == std::endian::big ; } inline bool is_native_endian () const noexcept { return mendian == std::endian::native; } inline bool equals_invariance (const ByteOrder& other) const noexcept { return minvariance == other.minvariance; } inline bool equals_endian (const ByteOrder& other) const noexcept { return mendian == other.mendian ; } inline bool equals_address_size (const ByteOrder& other) const noexcept { return maddress_size == other.maddress_size; } inline bool only_endian_differs (const ByteOrder& other) const noexcept { return ((!equals_endian(other)) && (equals_invariance (other) && equals_address_size (other))); } inline bool equals (const ByteOrder& other) const noexcept { return equals_invariance (other) && equals_endian(other) && equals_address_size (other); } inline bool operator == (const ByteOrder& other) const noexcept { return equals (other); } inline bool operator != (const ByteOrder& other) const noexcept { return !equals (other); } }; inline const ByteOrder little_address_8_byte_order = ByteOrder (std::endian::little, ADDRESS_INVARIANCE, sizeof (std::byte) * 8); inline const ByteOrder big_address_8_byte_order = ByteOrder (std::endian::big , ADDRESS_INVARIANCE, sizeof (std::byte) * 8); inline const ByteOrder native_byte_order = ByteOrder (std::endian::native, ADDRESS_INVARIANCE, sizeof (std::byte) * 8); template < size_t sz = 18> void convert(std::span<std::byte>& data, size_t original_data_size, const ByteOrder& from, const ByteOrder& to) noexcept { if ((from != to) && (data.size() > 1) && from.only_endian_differs(to) && (original_data_size > 1)) { auto e = data.size() - original_data_size; for (std::span<std::byte>::size_type i = 0; i <= e; i += original_data_size) { auto x = original_data_size / 2; for (auto j = 0; j < x; ++j) { pd::swap<std::byte>(data[i + j], data[i - j + original_data_size - 1]); } } } } inline void convert(const std::span<std::byte>& from_data, std::span<std::byte>& to_data, const ByteOrder& from, const ByteOrder& to) noexcept { } } } #endif </DOCUMENT>
<DOCUMENT filename="clone_util.hpp">
#ifndef CLONE_UTIL_HPP #define CLONE_UTIL_HPP #include "factory.hpp" #include <memory> namespace pensar_digital { namespace cpplib { template<class T, typename... Args> static typename NewFactory<T, Args...>::P clone(const T& other, const Args& ... args) { NewFactory<T, Args...> factory; return factory.get(args...); } template <typename T> concept CloneableConcept = requires (T t) { { t.clone() } -> std::convertible_to<typename T::Ptr>; }; } } #endif </DOCUMENT>
<DOCUMENT filename="code_util.hpp">
#ifndef CODE_UTIL_HPP #define CODE_UTIL_HPP #include "cs.hpp" #include "bool.hpp" namespace pensar_digital { namespace cpplib { template <typename T> struct Result { using ErrorMessageType = CS<0, 256>; using ResultType = T; T mresult; Bool mok = Bool::T; ErrorMessageType merror_message = EMPTY; Result() = default; Result(const Result&) = default; Result(Result&&) = default; Result(ResultType rt, Bool ok = Bool::T, ErrorMessageType err = EMPTY) : mresult(rt), mok(ok), merror_message(err) {} Result(ErrorMessageType err, ResultType r = T{}) : mresult(r), mok(Bool::F), merror_message(err) {} Result& operator=(const Result&) = default; Result& operator=(Result&&) = default; ~Result() = default; Result(const ErrorMessageType& error_message) : merror_message(error_message), mok(Bool::F) {} Result(const C* error_message) : merror_message(CS<0, 256>(error_message)), mok(Bool::F) {} operator Bool() const { return mok; } operator T() const { return mresult; } operator ErrorMessageType() const { return merror_message; } bool operator==(const T& other) const { return mresult == other; } bool operator!=(const T& other) const { return !(*this == other); } bool operator<(const T& other) const { return mresult < other; } Result& operator=(const T& other) { mresult = other; return *this; } Result& operator=(const Bool& other) { mok = other; return *this; } Result& operator=(const ErrorMessageType& other) { merror_message = other; mok = Bool::F; return *this; } bool operator!() const { return !mok; } }; static_assert(std::is_trivially_copyable<Result<int>>::value, "Result<int> must be trivially copyable."); } } #endif </DOCUMENT>
<DOCUMENT filename="command.hpp">
#ifndef CPP_COMMAND_HPP #define CPP_COMMAND_HPP #include <iostream> #include <vector> #include <memory> #include <exception> #include <algorithm> #include <type_traits> #include <tuple> #include <concepts> #include "constant.hpp" #include "s.hpp" #include "object.hpp" #include "concept.hpp" #include "generator.hpp" #include "version.hpp" #include "factory.hpp" #include "bool.hpp" #include "memory_buffer.hpp" #include "clone_util.hpp" #include "equal.hpp" namespace pensar_digital { namespace cpplib { template<typename T> concept CommandConcept = requires(T t) { { t.run() } -> std::same_as<void>; }&& Identifiable<T> && CloneableConcept<T>; template<class T> concept DerivedCommandConcept = requires(T t) { { t._run() } -> std::same_as<void>; }&& CloneableConcept<T>; template<typename T> concept UndoableCommandConcept = CommandConcept<T> && requires(T t) { { t.undo() } -> std::same_as<void>; }; template<class T> concept DerivedUndoableCommandConcept = DerivedCommandConcept<T> && UndoableCommandConcept<T>; namespace pd = pensar_digital::cpplib; class Command : public Object { private: struct Data : public pd::Data { Bool mok = Bool::UNKNOWN; Data(const Bool ok = Bool::UNKNOWN) noexcept : mok (ok) {} }; static_assert(StdLayoutTriviallyCopyable<Data>, "Data must be a trivially copyable type"); Data mdata; public: using Ptr = std::shared_ptr<Command>; inline const static Data NULL_DATA = { Bool::UNKNOWN }; using DataType = Data; using Factory = pd::Factory<Command, Id, typename Command::DataType>; inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("Command"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } using FactoryType = Factory; virtual const pd::Data* data() const noexcept { return &mdata; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)data(); } virtual size_t data_size() const noexcept { return sizeof(mdata); } virtual size_t size() const noexcept { return data_size() + sizeof(ClassInfo) + Object::SIZE; } using G = Generator<Command, Id>; inline static constexpr size_t DATA_SIZE = sizeof(mdata); inline static constexpr size_t SIZE = Object::SIZE + DATA_SIZE + sizeof(ClassInfo) + G::SIZE; protected: inline static G mgenerator = G(); public: Command (const Id aid = NULL_ID, const Data& data = NULL_DATA) : Object(aid == NULL_ID ? mgenerator.get_id() : aid), mdata(data) {} Command (Command&&) = default; Command (const Command&) = default; Command (MemoryBuffer& mb) : Object (mb) { assign_without_object (mb); } Command& operator= (Command&&) = default; Command& operator= (const Command&) = default; virtual ~Command () = default; virtual bool initialize (const Id id, const Data& data) noexcept { this->set_id(id == NULL_ID ? mgenerator.get_id() : id); mdata = data; return true; } virtual bool equals(const Object& o) const noexcept { const Command* pother = dynamic_cast<const Command*>(&o); if (pother == nullptr) return false; return equal<Command> (*this, *pother); } virtual Command& assign_without_object(MemoryBuffer& mb) noexcept { INFO.test_class_name_and_version (mb); mb.read_known_size((BytePtr)&mdata, DATA_SIZE); mgenerator = G(mb); return *this; } virtual Command& assign(MemoryBuffer& mb) noexcept { Object::assign(mb); return assign_without_object(mb); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append (*Object::bytes()); mb->append (INFO.bytes()); mb->write((BytePtr(&mdata)), DATA_SIZE); mb->append (*(mgenerator.bytes())); return mb; } virtual std::ostream& child_binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { return os; } virtual std::istream& child_binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { return is; } inline virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write (os, byte_order); INFO.binary_write(os, byte_order); os.write((char*)&mdata, DATA_SIZE); mgenerator.binary_write(os, byte_order); child_binary_write(os, byte_order); return os; } inline virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read(is, byte_order); INFO.test_class_name_and_version(is, byte_order); is.read((char*)&mdata, DATA_SIZE); mgenerator.binary_read(is, byte_order); child_binary_read(is, byte_order); return is; } protected: inline virtual void _run() {} inline virtual void _undo() const {} public: using Ptr = std::shared_ptr<Command>; inline Ptr clone() const noexcept { return pd::clone<Command>(*this, id()); } virtual void run () { _run(); mdata.mok = true; } void undo() const { if (mdata.mok) { _undo(); } } bool ok() const { return mdata.mok; } /* inline static typename FactoryType::P get(const Id aid = NULL_ID, const Data& data = NULL_DATA) noexcept { return mfactory.get(aid, data); } */ }; class NullCommand : public Command { public: using Ptr = std::shared_ptr<NullCommand>; NullCommand () : Command(NULL_ID) { } NullCommand (MemoryBuffer& mb) : Command (mb) { } ~NullCommand() = default; void _run() { } void _undo() const { } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("NullCommand"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } Ptr clone() const noexcept { return pd::clone<NullCommand>(*this); } }; inline static const NullCommand NULL_CMD = NullCommand(); static_assert (Identifiable<NullCommand>); static_assert (CommandConcept<NullCommand>); static_assert (DerivedCommandConcept<NullCommand>); static_assert (UndoableCommandConcept<NullCommand>); static_assert (DerivedUndoableCommandConcept<NullCommand>); class CompositeCommand : public Command { public: inline static const size_t MAX_COMMANDS = 10; using Ptr = std::shared_ptr<CompositeCommand>; private: struct Data : public pd::Data { using CommandArray = std::array<Command*, MAX_COMMANDS>; CommandArray mcommands; size_t mindex = 0; void add(Command* cmd) { if (mindex >= MAX_COMMANDS) { log_and_throw("CompositeCommand::Data::add(Command* cmd) : Maximum number of commands reached."); } mcommands[mindex++] = cmd; } void free_commands() { for (size_t i = 0; i < mindex; ++i) { delete mcommands[i]; } } }; static_assert(StdLayoutTriviallyCopyable<Data>, "Data must be a standard layout and trivially copyable type"); Data mdata; public: inline const static Data NULL_DATA = { {}, 0 }; using DataType = Data; using Factory = pd::Factory<CompositeCommand, Id>; using Int = int_fast8_t; inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("CompositeCommand"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } using FactoryType = Factory; virtual const pd::Data* data() const noexcept { return &mdata; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)data(); } inline static constexpr size_t DATA_SIZE = sizeof(mdata); virtual size_t data_size() const noexcept { return sizeof(mdata); } virtual size_t size() const noexcept { size_t size = sizeof(mdata.mindex) + sizeof(ClassInfo); for (Int i = 0; i < mdata.mindex; ++i) { size += mdata.mcommands[i]->size(); } return size; } public: CompositeCommand(const Id aid = NULL_ID) : Command(aid), mdata (NULL_DATA) { } CompositeCommand (MemoryBuffer& mb) : Command(mb) { assign_without_parent(mb); } ~CompositeCommand() { mdata.free_commands(); } private: inline static Factory mfactory = { 3, 10, NULL_ID }; public: Command& assign_without_parent(MemoryBuffer& mb) noexcept { for (Int i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->assign(mb); } return *this; } virtual Command& assign(MemoryBuffer& mb) noexcept { Command::assign(mb); return assign_without_parent (mb); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size ()); mb->append(Command::bytes()); mb->append(INFO.bytes()); mb->append((BytePtr)(&mdata.mindex), sizeof(mdata.mindex)); for (Int i = 0; i < mdata.mindex; ++i) { mb->append(mdata.mcommands[i]->bytes()); }; return mb; } virtual bool initialize (const Id id) noexcept { this->set_id (id == NULL_ID ? this->mgenerator.get_id() : id); return true; } inline static typename FactoryType::P get (const Id aid = NULL_ID) noexcept { return mfactory.get (aid); } void _run() { for (Int i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->run(); } } void _undo() const { for (Int i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->undo(); } } void add (Command* cmd) { mdata.add (cmd); } Ptr clone () const noexcept { Ptr pcc = std::make_shared<CompositeCommand>(id()); pcc->mdata.mindex = mdata.mindex; for (size_t i = 0; i < mdata.mindex; ++i) { pcc->add((Command*)mdata.mcommands[i]->clone().get ()); } return pcc; } virtual bool equals(const Object& o) const noexcept { const CompositeCommand* pother = dynamic_cast<const CompositeCommand*>(&o); if (pother == nullptr) return false; if (o.id () != id ()) return false; for (size_t i = 0; i < mdata.mindex; ++i) { if (!mdata.mcommands[i]->equals(*pother->mdata.mcommands[i])) return false; } return true; } inline virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read(is, byte_order); info_ptr()->test_class_name_and_version (is, byte_order); is.read((char*)(&mdata), DATA_SIZE); for (size_t i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i] = new Command (); mdata.mcommands[i]->binary_read(is, byte_order); } return is; } inline virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); info_ptr()->binary_write(os, byte_order); for (size_t i = 0; i < mdata.mindex; ++i) { mdata.mcommands[i]->binary_write(os, byte_order); } return os; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="concept.hpp">
#ifndef CONCEPT #define CONCEPT #include "constant.hpp" #include "factory.hpp" #include <concepts> #include <iostream> #include <memory> #include <type_traits> #include <span> #include <cstddef> namespace pensar_digital { namespace cpplib { template <typename T, typename... Args> concept Checkable = requires (T t, Args&& ... args) { {t.ok(args ...)} -> std::convertible_to<bool>; }; template <typename T> concept Hashable = requires (T t) { {t.hash()} -> std::convertible_to<Hash>; }; template <typename T> concept RangeCheckable = requires (T t) { {t >= t} -> std::convertible_to<bool>; {t <= t} -> std::convertible_to<bool>; }; template <typename T> concept DefaultConstructible = requires { {T()} noexcept; }; template <typename T, typename... Args> concept Initializable = requires (T t, Args... args) { {T(std::forward<Args>(args) ...)} noexcept; {t.initialize(std::forward<Args>(args) ...)} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Factorable = requires { typename T::Factory; std::derived_from<typename T::Factory, NewFactory<T>>; }; template <class T, typename... Args> concept FactoryConstructible = Initializable<T, Args...>&& requires (Args... args) { {T::get(args ...)} noexcept -> std::convertible_to<typename T::Factory::P>; } && Factorable<T>; template <typename T, typename... Args> concept AFactory = requires (T t, Args... args) { {t.get(args ...)} noexcept -> std::convertible_to<std::shared_ptr<T>>; }; template <typename T> concept Container = requires (T t, size_t i) { typename T::value_type; { t.at(i) } -> std::convertible_to<typename T::value_type&>; { t[i] } -> std::convertible_to<typename T::value_type&>; { t.size() } -> std::convertible_to<size_t>; }; template <typename T, typename V> concept ContainerV = Container<T> && std::is_same<typename T::value_type, V>::value; template <typename T> concept Interfaceable = requires { typename T::I; typename T::I_RO; }; template <typename T> concept Negatable = requires (T t) { {!t} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Andable = requires (T t) { {t && t} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Orable = requires (T t) { {t || t} noexcept -> std::convertible_to<bool>; }; template <typename T> concept Xorable = requires (T t) { {t ^ t} noexcept -> std::convertible_to<bool>; }; template<typename T> concept NarrowOutputStreamable = requires(T a, std::ostream & os) { { os << a } -> std::same_as<std::ostream&>; }; template<typename T> concept WideOutputStreamable = requires(T a, std::wostream & os) { { os << a } -> std::same_as<std::wostream&>; }; template<typename T> concept OutputStreamable = NarrowOutputStreamable<T> || WideOutputStreamable<T>; template<typename T> concept NarrowInputStreamable = requires(T a, std::istream & is) { { is >> a } -> std::same_as<std::istream&>; }; template<typename T> concept WideInputStreamable = requires(T a, std::wistream & is) { { is >> a } -> std::same_as<std::wistream&>; }; template<typename T> concept InputStreamable = NarrowInputStreamable<T> || WideInputStreamable<T>; template<typename T> concept Streamable = OutputStreamable<T> && InputStreamable<T>; template <typename T> concept CharCastable = requires(T * t) { { reinterpret_cast<char*>(*t) } -> std::same_as<char*>; }; template <typename T> concept ByteCastable = requires(T * t) { { reinterpret_cast<std::byte*>(*t) } -> std::same_as<std::byte*>; }; template <typename T> concept Sizeofable = requires(T t) { { sizeof(t) } -> std::same_as<size_t>; }; template <typename T> concept Identifiable = requires(T t) { { t.id() } -> std::convertible_to<Id>; }; template <typename T> concept SizeableIdentifiable = Identifiable<T> && Sizeofable<T>; template <typename T> concept Countable = requires(T t) { { t.count() } -> std::convertible_to<size_t>; }; template <typename T> concept Sizeable = requires(T t) { { t.size() } -> std::convertible_to<size_t>; }; template <typename T> concept BinaryStreamable = CharCastable<T> && Sizeofable<T> && Streamable<T>; template <typename T> concept BinaryReadable = requires(T t, std::span<std::byte>& bytes) { { t.read (bytes) } -> std::convertible_to<void>; }; template <typename T, typename Obj> concept ObjectBinaryReadable = requires(T t, Obj* p) { { t.template read<Obj> (p) } -> std::convertible_to<void>; } && BinaryReadable<T>; template <typename T, typename Obj, typename... Args> concept FactoryObjBinaryReadable = requires(T t) { { t.template read<Obj, Args...> () } -> std::convertible_to<typename Obj::Factory::P>; } && ObjectBinaryReadable<T, Obj>&& FactoryConstructible<Obj, Args ...>; template<typename T> concept Pointable = requires(T t) { { t.operator->() } -> std::convertible_to<T*>; { *t } -> std::convertible_to<T&>; }; template<typename T> concept StandardLayout = std::is_standard_layout_v<T>; template<typename T> concept TriviallyCopyable = std::is_trivially_copyable_v<T>; template<typename T> concept StdLayoutTriviallyCopyable = StandardLayout<T> && TriviallyCopyable<T>; template <typename T> concept HasStdLayoutTriviallyCopyableData = requires (T t) { { t.data() } -> std::convertible_to<const Data*>; { t.data_size() } -> std::convertible_to<size_t>; { T::DATA_SIZE } -> std::convertible_to<size_t>; { T::SIZE } -> std::convertible_to<size_t>; }&& TriviallyCopyable<typename T::DataType>&& StdLayoutTriviallyCopyable<typename T::DataType>; template <class T> concept TriviallyPersistable = requires (T t) { {t.data() } -> std::convertible_to<const Data*>; {t.data_size()} -> std::convertible_to<size_t>; } && TriviallyCopyable<typename T::DataType> && Identifiable<T> && Hashable<T>; template<typename T> concept TriviallyDestructible = std::is_trivially_destructible_v<T>; template<typename T> concept TriviallyConstructible = std::is_trivially_constructible_v<T>; template<typename T, typename U> concept TriviallyAssignable = std::is_trivially_assignable_v<T, U>; template<typename T> concept TriviallyCopyAssignable = std::is_trivially_copy_assignable_v<T>; template<typename T> concept TriviallyMoveAssignable = std::is_trivially_move_assignable_v<T>; template<typename T> concept TriviallyMoveConstructible = std::is_trivially_move_constructible_v<T>; template<typename T> concept TriviallyCopyConstructible = std::is_trivially_copy_constructible_v<T>; template<typename T> concept TriviallyMovable = TriviallyMoveConstructible<T> && TriviallyMoveAssignable<T>; } } #endif </DOCUMENT>
<DOCUMENT filename="constant.hpp">
 #ifndef constantesHPP #define constantesHPP #define VISUAL_STUDIO #define _WINSOCKAPI_ #include <cstdint> #include <vector> #include <cstddef> #include <concepts> #include <iostream> #include <fstream> #include <string> #include <sstream> #include <filesystem> #include <algorithm> #include <functional> #include <memory> #include <map> #include <set> #include <list> #include <queue> #include <stack> #include <tuple> #include <variant> #include <optional> #include <any> #include <chrono> #include <thread> #include <mutex> #include <condition_variable> #include <atomic> #include <future> #include <type_traits> #include <typeinfo> #include <random> #include <functional> #include <cctype> #include <span> #include "string_def.hpp" namespace pensar_digital { namespace cpplib { #if defined(_WIN32) || defined(_WIN64) #define WINDOWS #endif struct Data { }; using Id = int_fast64_t; using Hash = int_fast64_t; using FileSize = int_fast64_t; inline const Id NULL_ID = -1; template <typename T> concept unsigned_integral = std::is_integral<T>::value && std::is_unsigned<T>::value; template <unsigned_integral T> constexpr T null_value() { return 0; } template <std::signed_integral T> constexpr T null_value() { return -1; } enum Alignment : int_fast16_t { NULL_ALIGNMENT = -1, BIT8 = 8, BIT16 = 16, BIT32 = 32, BIT64 = 64, BIT128 = 128, BIT256 = 256, BIT512 = 512, BIT1024 = 1024 }; using Byte = std::byte; using Bytes = std::vector<Byte>; using BytePtr = Byte*; using ByteSpan = std::span<Byte>; inline const bool PAD_RIGHT = true; inline const bool PAD_LEFT = false; inline const bool TRIM_ELEMENTS = true; inline const bool INCLUDE_EMPTY_FIELDS = true; inline static const bool ADD_NULL_AT_END = true; inline static const bool DO_NOT_ADD_NULL_AT_END = false; inline static const bool FILL_NULL_BEFORE_COPY = true; inline static const bool DO_NOT_FILL_NULL_BEFORE_COPY = false; inline static const C* CPPLIB_NAMESPACE = W("pensar_digital::cpplib"); using VersionInt = int16_t; } } namespace pd = pensar_digital::cpplib; #endif </DOCUMENT>
<DOCUMENT filename="constraint.hpp">
 #ifndef CONSTRAINT_HPP #define CONSTRAINT_HPP #include "object.hpp" #include "version.hpp" #include "constant.hpp" #include <cstdarg> #include <regex> #include <variant> namespace pensar_digital { namespace cpplib { static const S ONLY_DIGITS_REGEX = W("^[0-9]*$"); static const S AT_LEAST_ONE_DIGIT_REGEX = W("^[0-9]+$"); static const S ONLY_LETTERS_REGEX = W("^[a-zA-Z]*$"); static const S ONLY_LETTERS_AND_DIGITS_REGEX = W("^[a-zA-Z0-9]*$"); static const S ONLY_LETTERS_AND_DIGITS_AND_UNDERSCORES_REGEX = W("^[a-zA-Z0-9_]*$"); template <typename L, typename R, typename ResultType, class D> class Operand : public Object { public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); Operand (const Id aid = NULL_ID) : Object(aid) {} template <typename ... Args> ResultType operator () (L* left, R* right = nullptr, Args&& ... args) const { return static_cast<D*>(this)->::operator () (left, right, args ...); }; virtual ~Operand() {} }; template <typename T, typename ResultType, class D> class UnaryOperand : public Operand<T, T, ResultType, UnaryOperand<T, ResultType, D>> { private: typedef UnaryOperand<T, ResultType, D> UnaryOp; typedef Operand <T, T, ResultType, UnaryOp> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); UnaryOperand (const Id aid = NULL_ID) : Base(aid) {} virtual ~UnaryOperand() {} template <typename ... Args> ResultType operator () (T* ptr, const T* not_used = nullptr, Args&& ... args) const { return static_cast<D*>(this)->::operator () (ptr, args ...); }; }; template <Checkable T> class NotOperand : public UnaryOperand<T, bool, NotOperand<T>> { private: typedef UnaryOperand<T, bool, NotOperand<T>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); NotOperand (const Id aid = NULL_ID) : Base(aid) {} virtual ~NotOperand() {} template <typename ... Args> bool operator () (const T* ptr, Args&& ... args) const noexcept { return !ptr->ok (args ...); }; }; template <typename L, typename R, typename ResultType, class D> class BinaryOperand : public Operand<L, R, ResultType, BinaryOperand<L, R, ResultType, D>> { private: typedef Operand<L, R, ResultType, BinaryOperand<L, R, ResultType, D>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); BinaryOperand (const Id aid = NULL_ID) : Base (aid) {} virtual ~BinaryOperand() {} template <typename ... Args> ResultType operator () (const L* left, const R* right = nullptr, Args&& ... args) const { return static_cast<D*>(this)->operator () (left, right, args ...); }; }; template <Checkable L, Checkable R> class AndOperand : public BinaryOperand<L, R, bool, AndOperand<L, R>> { private: typedef BinaryOperand<L, R, bool, AndOperand<L, R>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); AndOperand (const Id aid = NULL_ID) noexcept : Base (aid) {} virtual ~AndOperand() {} template <typename ... Args> bool operator () (const L& left, const R& right, Args&& ... args) const noexcept { return (left.ok(args ...) && right.ok(args ...)); } }; template <Checkable L, Checkable R> class OrOperand : public BinaryOperand<L, R, bool, OrOperand<L, R>> { private: typedef BinaryOperand<L, R, bool, OrOperand<L, R>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get(1, 1, 1); OrOperand(const Id aid = NULL_ID) noexcept : Base(aid) {} virtual ~OrOperand() {} template <typename ... Args> bool operator () (const L& left = nullptr, const R& right = nullptr, Args&& ... args) const noexcept { return (left.ok(args ...) || right.ok(args ...)); } }; template <Checkable L, Checkable R> class XorOperand : public BinaryOperand<L, R, bool, XorOperand<L, R>> { private: typedef BinaryOperand<L, R, bool, XorOperand<L, R>> Base; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); XorOperand(const Id aid = NULL_ID) noexcept : Base(aid) {} virtual ~XorOperand() {} template <typename ... Args> bool operator () (const L& left = nullptr, const R& right = nullptr, Args&& ... args) const noexcept { return (left.ok(args ...) ^ right.ok(args ...)); } }; template <class D> class Constraint : public Object { private: S name; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); Constraint(const Id aid = NULL_ID, const S& aname = "") : Object(aid), name(aname) {} virtual ~Constraint () {} inline const S& get_name () const noexcept { return name; } inline void set_name (const S& aname) { name = aname; } virtual bool initialize(const Id& aid = NULL_ID, const S& aname = "") noexcept { Object::set_id(aid); name = aname; return true; } template <typename... Args> bool ok (Args&& ... args) const noexcept { static_assert (Checkable<D, Args>); return static_cast<D*>(this)->::ok (std::forward<Args>(args)...); }; template <typename... Args> bool Or (const Constraint<D>& other, Args& ... args) const noexcept { return ok (args ...) || other.ok (args ...); }; template <typename... Args> bool And (const Constraint<D>& other, Args& ... args) const noexcept { return ok(args ...) && other.ok(args ...); }; template <typename... Args> bool Xor (const Constraint<D>& other, Args& ... args) const noexcept { return ok(args ...) ^ other.ok(args ...); }; template <typename... Args> bool Not (Args& ... args) const noexcept { return !ok(args ...); }; }; template <Checkable L, Checkable R> class CompositeConstraint : public Constraint <CompositeConstraint<L, R>> { public: typedef std::variant <AndOperand <L, R>, OrOperand <L, R>, XorOperand <L, R>> OpType; typedef enum { AND, OR, XOR } OpIndex; private: typedef CompositeConstraint<L, R> C; typedef Constraint <C> Base; typedef std::shared_ptr<Base > BasePtr; typedef std::shared_ptr<L > LeftPtr; typedef std::shared_ptr<R > RightPtr; const L& left; const R& right; OpType op; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); CompositeConstraint (const L& aleft, const R& aright, const OpType aop, const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), left(aleft), right(aright), op (aop) { } virtual ~CompositeConstraint() {} template <typename ...Args> bool ok (Args&& ...args) const noexcept { switch (op.index ()) { case AND: return std::get<AND>(op) (left, right, args ...); case OR: return std::get<OR>(op) (left, right, args ...); case XOR: return std::get<XOR>(op) (left, right, args ...); } return false; }; }; template <Checkable L, Checkable R> CompositeConstraint<L, R> operator && (const L& left, const R& right) { typedef CompositeConstraint<L, R> C; return * new C (left, right); } template <Checkable L, Checkable R> CompositeConstraint<L, R> operator || (const L& left, const R& right) { typedef CompositeConstraint<L, R> C; return *new C(left, right, OrOperand<L,R>()); } class StringConstraint : public Constraint <StringConstraint> { private: typedef Constraint<StringConstraint> Base; const std::basic_regex <C> regex; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); StringConstraint (const S& aregex = W(""), const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), regex (aregex) { } virtual ~StringConstraint() {} bool ok(const S& s = W("")) const noexcept { return std::regex_search (s, regex); }; }; template <RangeCheckable T> class RangeConstraint : public Constraint <RangeConstraint<T>> { private: typedef Constraint<RangeConstraint<T>> Base; const T mmin; const T mmax; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); RangeConstraint (const T& amin, const T& amax, const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), mmin (amin), mmax (amax) { } RangeConstraint (const T& avalue, const Id aid = NULL_ID, const S& aname = W("")) : Base(aid, aname), mmin (avalue), mmax (avalue) { } virtual ~RangeConstraint() {} bool ok(const T& t = 0) const noexcept { return (t >= mmin) && (t <= mmax); }; }; } } #endif </DOCUMENT>
<DOCUMENT filename="country.hpp">
#ifndef COUNTRY_HPP #define COUNTRY_HPP #include "object.hpp" #include "s.hpp" #include "generator.hpp" namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; class Country : public Object { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); Country(Id aid = NULL_ID) : Object(aid == NULL_ID ? generator.get_id () : aid) {} virtual ~Country() {}; /** Copy constructor * \param other Object to copy from */ Country(const Country& other) : Object (other) {} /** Assignment operator * \param other Object to assign from * \return A reference to this */ Country& operator=(const Country& other) { Object::set_id(other.id()); } protected: private: static Generator<Country> generator; }; } } #endif </DOCUMENT>
<DOCUMENT filename="creator.hpp">
#ifndef CREATOR_HPP_INCLUDED #define CREATOR_HPP_INCLUDED template <class T> struct NewCreator { static T* = Create () { return new T; } }; template <class T> struct MallocCreator { static T* = Create () { void* buffer = std::malloc (sizeof (T)); return (buffer ? new (buf) T : 0); } }; template <class T> struct CloneCreator { CloneCreator (T* a_obj = nullptr; bool owns_template_obj = true) : obj (a_obj), owns(owns_template_obj) {} T* Create () { return obj ? obj->clone () : nullptr; } T* get_template_object () const {return obj;} void set_template_object (const T* a_obj) { if (owns) delete obj; obj = a_obj; } protected: ~CloneCreator () {if (owns) delete obj;} private: T* obj; bool owns; }; template <class T> struct MockupCreator { MockupCreator (T* a_obj = nullptr; bool owns_template_obj = true) : obj (a_obj), owns(owns_template_obj) {} T* Create () { return obj; } T* get_mockup_object () const {return obj;} void set_mockup_object (const T* a_obj) { if (owns) delete obj; obj = a_obj; } protected: ~MockupCreator () {if (owns) delete obj;} private: T* obj; bool owns; }; #endif </DOCUMENT>
<DOCUMENT filename="cs.hpp">
#ifndef CS_HPP #define CS_HPP #include <array> #include <cstring> #include <string> #include <stdexcept> #include <string_view> #include <iostream> #include <sstream> #include "string_def.hpp" namespace pensar_digital { namespace cpplib { using S = std::basic_string<C>; using SView = std::basic_string_view<C>; using SIter = std::basic_string<C>::iterator; using SConstIter = std::basic_string<C>::const_iterator; using InStream = std::basic_istream<C>; using OutStream = std::basic_ostream<C>; using SStream = std::basic_stringstream<C>; using InStreamBuf = std::basic_streambuf<C>; using OutStreamBuf = std::basic_streambuf<C>; using InStreamBufIter = std::istreambuf_iterator<C>; using OutStreamBufIter = std::ostreambuf_iterator<C>; using InStringStream = std::basic_istringstream<C>; using OutStringStream = std::basic_ostringstream<C>; using InFStream = std::basic_ifstream<C>; using OutFStream = std::basic_ofstream<C>; using FStream = std::basic_fstream<C>; using InFileBuf = std::basic_filebuf<C>; using InFileBufIter = std::istreambuf_iterator<C>; using OutFileBuf = std::basic_filebuf<C>; using OutFileBufIter = std::ostreambuf_iterator<C>; inline void remove_accent(C* c) noexcept { switch (*c) { case W('á'): case W('à'): case W('ã'): case W('ä'): case W('â'): *c = W('a'); break; case W('é'): case W('è'): case W('ë'): case W('ê'): *c = W('e'); break; case W('í'): case W('ì'): case W('ï'): case W('î'): *c = W('i'); break; case W('ó'): case W('ò'): case W('õ'): case W('ö'): case W('ô'): *c = W('o'); break; case W('ú'): case W('ù'): case W('ü'): case W('û'): *c = W('u'); break; case W('ç'): *c = W('c'); break; case W('Á'): case W('À'): case W('Ã'): case W('Ä'): case W('Â'): *c = W('A'); break; case W('É'): case W('È'): case W('Ë'): case W('Ê'): *c = W('E'); break; case W('Í'): case W('Ì'): case W('Ï'): case W('Î'): *c = W('I'); break; case W('Ó'): case W('Ò'): case W('Õ'): case W('Ö'): case W('Ô'): *c = W('O'); break; case W('Ú'): case W('Ù'): case W('Ü'): case W('Û'): *c = W('U'); break; case W('Ç'): *c = W('C'); break; default: break; } } inline C copy_remove_accent(const C c) noexcept { C ch = c; remove_accent(&ch); return ch; } inline bool equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { if (case_sensitive) { if (accent_sensitive) { return c == c2; } else { return copy_remove_accent(c) == copy_remove_accent(c2); } } else { if (accent_sensitive) { return std::tolower(c) == std::tolower(c2); } else { return std::tolower(copy_remove_accent(c)) == std::tolower(copy_remove_accent(c2)); } } } inline bool less(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { if (case_sensitive) { if (accent_sensitive) { return c < c2; } else { return copy_remove_accent(c) < copy_remove_accent(c2); } } else { if (accent_sensitive) { return std::tolower(c) < std::tolower(c2); } else { return std::tolower(copy_remove_accent(c)) < std::tolower(copy_remove_accent(c2)); } } } inline bool not_equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return !equal(c, c2, case_sensitive, accent_sensitive); } template <typename C = char> inline bool greater(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return !less(c, c2, case_sensitive, accent_sensitive) && !equal(c, c2, case_sensitive, accent_sensitive); } inline bool less_equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return less(c, c2, case_sensitive, accent_sensitive) || equal(c, c2, case_sensitive, accent_sensitive); } inline bool greater_equal(const C c, const C c2, bool case_sensitive = false, bool accent_sensitive = false) noexcept { return greater(c, c2, case_sensitive, accent_sensitive) || equal(c, c2, case_sensitive, accent_sensitive); } template<size_t MIN = 0, size_t MAX = 20> class CS { public: using value_type = C; std::array<C, MAX> data; bool case_sensitive = false; bool accent_sensitive = false; inline static const size_t MAX_SIZE = MAX; inline static const size_t MAX_LENGTH = MAX - 1; inline static const size_t MIN_SIZE = MIN; const constexpr inline size_t size() const noexcept { return MAX; } void inline fill(C c) noexcept { data.fill(c); } void fill_null() noexcept { fill(NULL_CHAR); } CS() { fill_null(); } inline bool is_null_char(size_t index) const noexcept { return (data[index] == NULL_CHAR); } inline size_t length() const noexcept { return std::char_traits<C>::length(data.data()); } inline void copy(const C* s, size_t s_length, bool add_null_at_end = true, bool fill_null_before_copy = true) { if (s_length >= MAX) { std::string error = "String is too long. Max size is "; error += std::to_string(MAX); throw std::runtime_error(error); } if (s_length < MIN) { std::string error = "String is too short. Min size is "; error += std::to_string(MIN); throw std::runtime_error(error); } if (fill_null_before_copy) fill_null(); if (s_length > 0) std::memcpy(data.data(), s, s_length * sizeof(C)); if (add_null_at_end and (s_length >= 0)) data[s_length] = NULL_CHAR; } inline void copy(const C* str) { auto strlen = std::char_traits<C>::length(str); copy(str, strlen); } inline void copy(const S& str) { copy(str.c_str(), str.length()); } CS(const C* str) { copy(str); } CS(const S& str) { copy(str.c_str(), str.length()); } operator C* () const noexcept { size_t size = length() + 1; C* c = new C[size]; std::memcpy(c, data.data(), size); return c; } inline S to_string() const noexcept { return S(data.data()); } inline S str() const noexcept { return S(data.data()); } operator S() const noexcept { return to_string(); } inline size_t cmp_strlen(const CS& other) const noexcept { return length() - other.length(); } inline bool eq_strlen(const CS& other) const noexcept { return length() == other.length(); } inline bool empty() const noexcept { return length() == 0; } inline C& operator[] (const size_t index) const noexcept { return const_cast<C&>(data[index]); } inline C& at(const size_t index) const noexcept { return operator[](index); } bool operator== (const CS& other) const noexcept { bool result = eq_strlen(other); if (result) { auto strlen = length(); for (size_t i = 0; i < strlen; ++i) { if (!equal(data[i], other.data[i], case_sensitive, accent_sensitive)) { result = false; break; } } } return result; } bool operator!=(const CS& other) const noexcept { return !(*this == other); } bool operator<(const CS& other) const noexcept { bool result = less(data[0], other.data[0], case_sensitive, accent_sensitive); if (result) { auto strlen = length(); for (size_t i = 1; i < strlen; ++i) { if (!less(data[i], other.data[i], case_sensitive, accent_sensitive)) { result = false; break; } } } return result; } bool operator>(const CS& other) const noexcept { return other < *this; } bool operator<=(const CS& other) const noexcept { return !(other < *this); } bool operator>=(const CS& other) const noexcept { return !(*this < other); } CS& operator= (const S& str) noexcept { copy(str); return *this; } CS& operator= (const C* str) { copy(str); return *this; } CS& operator= (const std::array<C, MAX>& arr) noexcept { std::memcpy(data.data(), arr.data(), MAX * sizeof(C)); return *this; } CS& assign(const CS& other) { copy(other.data.data(), other.length(), ADD_NULL_AT_END); return *this; } CS& operator+= (const CS& other) { auto strlen = length(); auto other_strlen = other.length(); if (strlen + other_strlen > MAX) { std::string error = "CString is too long. Max size is "; error += std::to_string(MAX); throw std::runtime_error(error); } std::memcpy(data.data() + strlen, other.data.data(), other_strlen * sizeof(C)); data[strlen + other_strlen] = NULL_CHAR; return *this; } CS operator+ (const CS& other) { CS result = *this; result += other; return result; } OutStream& write(OutStream& os) const noexcept { os << data.data(); return os; } InStream& read(InStream& is) { S s; is >> s; copy(s); return is; } }; template <size_t MIN = 0, size_t MAX> OutStream& operator<< (OutStream& os, const CS<MIN, MAX>& cs) { return cs.write(os); } template <size_t MIN = 0, size_t MAX> InStream& operator>> (InStream& is, CS<MIN, MAX>& cs) { return cs.read(is); } template<int N, int N2> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const CS<0, N2>& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const CS<N>& rhs) - lhs must be of size N > 0")); CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs.data.begin(), rhs.data.end(), result.data.begin() + N); return result; } template<int N, int N2, typename Char = char> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const S& rhs) { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const S& rhs) - lhs must be of size N > 0")); if (rhs.size() != N2) { throw std::runtime_error(W("CS<N> operator+ (const CS<N>& lhs, const std::basic_string<Char>& rhs) - rhs must be of size N2")); } CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs.begin(), rhs.end(), result.data.begin() + N); return result; } template<int N, int N2> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const C* rhs) { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const Char* rhs) - lhs must be of size N > 0")); if (std::char_traits<C>::length(rhs) != N2) { throw std::runtime_error(W("CS<N> operator+ (const CS<N>& lhs, const Char* rhs) - rhs must be of size N2")); } CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs, rhs + N, result.data.begin() + N); return result; } template<int N, size_t N2> CS<0, N + N2> operator+ (const CS<0, N>& lhs, const std::array<C, N2>& rhs) noexcept { static_assert (N2 > 0, W("CS<N> operator+ (const CS<N>& lhs, const std::array<Char, N2>& rhs) - rhs must be of size > 0")); static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const std::array<Char, N2>& rhs) - lhs must be of size > 0")); CS<0, N + N2> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); std::copy(rhs.begin(), rhs.end(), result.data.begin() + N); return result; } template<size_t N> CS<0, N + 1> operator+ (const S& lhs, const CS<0, N>& rhs) { size_t min_size = lhs.length() + rhs.length() + 1; if (N < min_size) std::runtime_error("CS<N> operator+ (const std::basic_string<Char>& lhs, const CS<N>& rhs) - rhs must be of size > " + std::to_string(min_size)); CS<0, N + 1> result; std::copy(lhs.begin(), lhs.end(), result.data.begin()); std::copy(rhs.data.begin(), rhs.data.begin() + rhs.length(), result.data.begin() + lhs.length()); return result; } template<int N, int N2> CS<0, N + N2> operator+ (const std::array<C, N>& lhs, const CS<0, N2>& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const std::array<Char, N>& lhs, const CS<N2>& rhs) - lhs must be of size > 0")); CS<0, N + N2> result; std::copy(lhs.begin(), lhs.end(), result.data.begin()); std::copy(rhs.data.begin(), rhs.data.end(), result.data.begin() + N); return result; } template<int N> CS<0, N + sizeof(C)> operator+ (const CS<0, N>& lhs, const C& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const CS<N>& lhs, const Char& rhs) - lhs must be of size > 0")); CS<0, N + sizeof(C)> result; std::copy(lhs.data.begin(), lhs.data.end(), result.data.begin()); result.data[N] = rhs; return result; } template<int N> CS<0, N + sizeof(C)> operator+ (const C& lhs, const CS<0, N>& rhs) noexcept { static_assert (N > 0, W("CS<N> operator+ (const Char& lhs, const CS<N>& rhs) - lhs must be of size > 0")); CS<0, N + sizeof(C)> result; result.data[0] = lhs; std::copy(rhs.data.begin(), rhs.data.end(), result.data.begin() + 1); return result; } template<int N> std::array<C, N>& assign(std::array<C, N>& lhs, const std::array<C, N>& rhs) noexcept { std::memcpy(lhs.data(), rhs.data(), N); return lhs; } } } #endif </DOCUMENT>
<DOCUMENT filename="defines.hpp">
#ifndef DEFINES_HPP #define DEFINES_HPP #define WINDOWS #ifdef WINDOWS #define VISUAL_STUDIO #endif namespace pensar_digital { namespace cpplib { } } #endif </DOCUMENT>
<DOCUMENT filename="distance.hpp">
#ifndef DISTANCE_HPP_INCLUDED #define DISTANCE_HPP_INCLUDED #undef min #include <algorithm> #include "s.hpp" namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; #include <algorithm> #include <vector> inline size_t distance(const S& source, const S& target) { const size_t n = source.length(); const size_t m = target.length(); if (n == 0) return m; if (m == 0) return n; std::vector<size_t> row1(m + 1); std::vector<size_t> row2(m + 1); std::vector<size_t> row3(m + 1); for (size_t j = 0; j <= m; j++) { row2[j] = j; } for (size_t i = 1; i <= n; i++) { row3[0] = i; for (size_t j = 1; j <= m; j++) { const char s_i = source[i - 1]; const char t_j = target[j - 1]; size_t cost = (s_i == t_j) ? 0 : 1; row3[j] = std::min(std::min(row3[j - 1] + 1, row2[j] + 1), row2[j - 1] + cost); if (i > 1 && j > 1 && s_i == target[j - 2] && t_j == source[i - 2]) { row3[j] = std::min(row3[j], row1[j - 2] + 1); } } row1 = row2; row2 = row3; } return row2[m]; } #ifndef LESS_DIFF #define LESS_DIFF struct LessDistance { S reference; LessDistance (const S& s) : reference(s) {} bool operator () (const S& left, const S& right) { return pd::distance (left, reference) < pd::distance (right, reference); } }; #endif template <class Container = std::vector<S>> typename Container::value_type min_distance (const S& s, const Container& c) { INVALID_ARGUMENT(c.size () == 0, "c.size () = 0"); typename Container::const_iterator it = c.begin (); typename Container::value_type min = *it; int min_dist = pd::distance (min, s); for (const auto& it : c) { int dist = pd::distance (it, s); if (dist < min_dist) { min = it; min_dist = dist; } } return min; } template <class Container = std::vector<C*>> typename Container::value_type min_distance (const C* s, const Container& c) { return min_distance (S(s), c); } template <class Container = std::map<S, S>> typename Container::value_type min_distance_map_key (const S& s, const Container& c, int max_distance = std::numeric_limits<int>::max()) { INVALID_ARGUMENT(c.size () == 0, "c.size () = 0"); typename Container::const_iterator it = c.begin (); std::pair<typename Container::key_type, typename Container::mapped_type> minimum(it->first, it->second); int min_dist = pd::distance (minimum.first, s); for (; it != c.end (); ++it) { int dist = pd::distance (it->first, s); if (dist < min_dist) { minimum = *it; min_dist = dist; } } std::pair<typename Container::key_type, typename Container::mapped_type> nope; return (min_dist <= max_distance) ? minimum : nope; } template <class Container = std::vector<S>, class OutContainer = std::vector<S>> void min_distance (const S& s, const Container& c, OutContainer& out, unsigned max_elements = 0) { INVALID_ARGUMENT(c.size () == 0, "c.size () = 0"); LessDistance ld (s); using MSet = std::multiset<S, LessDistance>; MSet mset (ld); for (const auto& it : mset) { mset.insert (it); } if (max_elements == 0) std::copy (mset.begin (), mset.end (), std::back_inserter(out)); else { typename MSet::iterator fim = mset.begin (); while (max_elements--) ++fim; std::copy (mset.begin (), fim, std::back_inserter(out)); } } template <class Container = std::vector<C*>, class OutContainer = std::vector<C*>> void min_distance (const C* s, const Container& c, OutContainer& out, unsigned max_elements = 0) { min_distance (S(s), c, out, max_elements); } } } #endif </DOCUMENT>
<DOCUMENT filename="encoding.hpp">
#ifndef ENCODE_HPP #define ENCODE_HPP #include "cs.hpp" #include "bool.hpp" #include "array.hpp" #include "endian.hpp" namespace pensar_digital { namespace cpplib { using BomBytes = CArray<4>; inline static BomBytes NO_BOM = { 0, 0, 0, 0 }; inline static BomBytes BOM_UTF_8 = { 0xEF, 0xBB, 0xBF, 0x00 }; inline static BomBytes BOM_UTF_16_BE = { 0xFE, 0xFF, 0x00, 0x00 }; inline static BomBytes BOM_UTF_16_LE = { 0xFF, 0xFE, 0x00, 0x00 }; inline static BomBytes BOM_UTF_32_BE = { 0x00, 0x00, 0xFE, 0xFF }; inline static BomBytes BOM_UTF_32_LE = { 0xFF, 0xFE, 0x00, 0x00 }; inline static void init_bom () { NO_BOM._data_size = 0; BOM_UTF_8._data_size = 3; BOM_UTF_16_BE._data_size = 2; BOM_UTF_16_LE._data_size = 2; BOM_UTF_32_BE._data_size = 4; BOM_UTF_32_LE._data_size = 4; } struct Encoding {}; template <size_t NameSize, Bool HasBOM = Bool::T> struct EncodingBase : public Encoding { CS<NameSize> name; Endian endian; BomBytes bom; }; const EncodingBase< 5, Bool::F> ASCII = { Encoding (), "ASCII" , Endian::NOT_APPLICABLE, NO_BOM }; const EncodingBase< 5, Bool::F> UTF_8 = { Encoding (), "UTF-8" , Endian::NOT_APPLICABLE, NO_BOM }; const EncodingBase< 9, Bool::T> UTF_8_BOM = { Encoding (), "UTF-8-BOM" , Endian::NOT_APPLICABLE, BOM_UTF_8 }; const EncodingBase< 9, Bool::F> UTF_16_BE = { Encoding (), "UTF-16-BE" , Endian::BIG , NO_BOM }; const EncodingBase<13, Bool::T> UTF_16_BE_BOM = { Encoding (), "UTF-16-BE-BOM", Endian::BIG , BOM_UTF_16_BE }; const EncodingBase< 9, Bool::F> UTF_16_LE = { Encoding (), "UTF-16-LE" , Endian::LITTLE , NO_BOM }; const EncodingBase<13, Bool::T> UTF_16_LE_BOM = { Encoding (), "UTF-16-LE-BOM", Endian::LITTLE , BOM_UTF_16_LE }; const EncodingBase< 9, Bool::F> UTF_32_BE = { Encoding (), "UTF-32-BE" , Endian::BIG , NO_BOM }; const EncodingBase<13, Bool::T> UTF_32_BE_BOM = { Encoding (), "UTF-32-BE-BOM", Endian::BIG , BOM_UTF_32_BE }; const EncodingBase< 9, Bool::F> UTF_32_LE = { Encoding (), "UTF-32-LE" , Endian::LITTLE , NO_BOM }; const EncodingBase<13, Bool::T> UTF_32_LE_BOM = { Encoding (), "UTF-32-LE-BOM", Endian::LITTLE , BOM_UTF_32_LE }; }; } #endif </DOCUMENT>
<DOCUMENT filename="endian.hpp">
#ifndef ENDIAN_HPP #define ENDIAN_HPP #include "concept.hpp" #include <cstdint> namespace pensar_digital { namespace cpplib { struct Endian; struct Endian { int8_t _value; static const int8_t NOT_APPLICABLE = -2; static const int8_t UNKNOWN = -1; static const int8_t LITTLE = static_cast<int8_t> (std::endian::little); static const int8_t BIG = static_cast<int8_t> (std::endian::big ); static const int8_t NATIVE = static_cast<int8_t> (std::endian::native); Endian() = default; constexpr Endian (int_fast8_t value) : _value(value) {} constexpr Endian (std::endian value) : _value(value == std::endian::little ? LITTLE : (value == std::endian::big ? BIG : NATIVE)) {} constexpr operator Endian() const { return static_cast<std::endian>(_value); } constexpr operator int_fast8_t() const { return _value; } }; static_assert(std::is_trivially_copyable<Endian>::value, "Endian must be trivially copyable."); } } #endif </DOCUMENT>
<DOCUMENT filename="equal.hpp">
#ifndef EQUAL_HPP #define EQUAL_HPP #include "concept.hpp" #include "constant.hpp" #include <type_traits> #include <cstring> namespace pensar_digital { namespace cpplib { template <class T> concept TriviallyHashComparable = HasStdLayoutTriviallyCopyableData<T> && pensar_digital::cpplib::Hashable<T>; struct HashComparableTag {}; struct DataComparableTag {}; struct TriviallyComparableTag {}; struct StdLayoutTriviallyCopyableTag {}; template <class T> using EqualDispatchTag = std::conditional_t< pensar_digital::cpplib::TriviallyHashComparable<T>, pensar_digital::cpplib::HashComparableTag, std::conditional_t< pensar_digital::cpplib::HasStdLayoutTriviallyCopyableData<T>, pensar_digital::cpplib::DataComparableTag, std::conditional_t< std::is_trivially_copyable_v<T>, pensar_digital::cpplib::StdLayoutTriviallyCopyableTag, pensar_digital::cpplib::TriviallyComparableTag > > >; template <TriviallyHashComparable T> bool equal_impl(const T& l, const T& r, HashComparableTag) { if (l.hash() != r.hash()) return false; return equal_impl(l, r, DataComparableTag{}); } template <HasStdLayoutTriviallyCopyableData T> bool equal_impl(const T& l, const T& r, DataComparableTag) { if (&l == &r) return true; return std::memcmp(l.data(), r.data(), l.data_size()) == 0; } bool equal_impl(const auto& l, const auto& r, TriviallyComparableTag) { return l == r; } template <StdLayoutTriviallyCopyable T> bool equal_impl(const T& l, const T& r, StdLayoutTriviallyCopyableTag) { if (&l == &r) return true; return std::memcmp(&l, &r, sizeof(l)) == 0; } template <typename T> bool equal(const T& l, const T& r) { return equal_impl(l, r, EqualDispatchTag<T>{}); } } } #endif </DOCUMENT>
<DOCUMENT filename="error.hpp">
 #ifndef ERROR_HPP_INCLUDED #define ERROR_HPP_INCLUDED #include "string_def.hpp" #include "object.hpp" #include "version.hpp" #include "log.hpp" #include <stdexcept> #include <sstream> namespace pensar_digital { namespace cpplib { class Exception : public std::exception { public: Exception (const S& message): message (message) {} const S what_error () const noexcept { #ifdef WIDE_CHAR std::string s = what(); return to_wstring (s); #else return what (); #endif } private: S message; }; #define INVALID_ARGUMENT(condition,message) \ if (condition)\ {\ SStream ss;\ ss << __FILE__ << '\t' << __LINE__ << '\t' << message << std::endl;\ std::cerr << ss.str ();\ std::cerr.flush ();\ throw std::invalid_argument (ss.str ());\ }; #define WINVALID_ARGUMENT(condition,message) \ if (condition)\ {\ std::wstringstream ss;\ ss << WFILE << L'\t' << WLINE << L'\t' << message << std::endl;\ std::wcerr << ss.str ();\ std::wcerr.flush ();\ throw std::invalid_argument (ss.str ());\ }; class Error : public Object { public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); Error (const S& error_msg, const Id aid = 0): Object (aid), error_message (error_msg) {} const S& get_error_message () const { return error_message; } ; void set_error_message (const S& error_msg) { error_message = error_msg; }; void append_error_message (const S& error_msg) { error_message = error_message + error_msg; }; virtual InStream& read (InStream& is) { Id id; is >> id >> error_message; set_id (id); return is; }; virtual OutStream& write (OutStream& os) const { os << error_message << id (); return os; }; private: S error_message; }; inline OutStream& operator<< (OutStream& os, const Error& e) { return e.write (os); } inline InStream& operator>> (InStream& is, Error& e) { return e.read (is); } class UnsupportedVersion : public Error { public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); UnsupportedVersion (const Version v): Error (W("Unsupported version number: ") + v.to_string ()){}; }; inline static void log_and_throw(const S& error_msg = W("")) { LOG(error_msg); throw Error(error_msg); } } } #endif </DOCUMENT>
<DOCUMENT filename="factory.hpp">
 #ifndef FACTORY_HPP_INCLUDED #define FACTORY_HPP_INCLUDED #include <memory> #include <type_traits> #include <vector> #include <cassert> namespace pensar_digital { namespace cpplib { template <class T, typename... Args> class NewFactory { public: typedef typename std::shared_ptr<T> P; virtual ~NewFactory (){} virtual P get(const Args& ... args) const { return std::make_shared<T> (args ...); } private: }; template <class T, typename... Args> class MockupFactory: public NewFactory <T, Args...> { public: using P = NewFactory<T, Args...>::P; MockupFactory(T* amockup_pointer) : mockup_pointer(amockup_pointer) { }; virtual ~MockupFactory() {} virtual P get(const Args& ... args) const { std::shared_ptr<T> ptr(mockup_pointer); return ptr; } private: T* mockup_pointer; }; template <class T, typename... Args> class PoolFactory : public NewFactory <T, Args...> { private: using P = NewFactory<T, Args...>::P; void fill_pool (const size_t& pool_size, const Args& ... args) { for (size_t i = 0; i < pool_size; ++i) { std::shared_ptr<T>&& ptr = std::make_shared<T>(args ...); pool.push_back(std::move(ptr)); } available_count = pool_size; } void add (const size_t& count, const Args& ... args) { for (size_t i = 0; i < count; ++i) { std::shared_ptr<T>&& ptr = std::make_shared<T>(args ...); pool.push_back(ptr); } available_count += count; } public: PoolFactory (const size_t initial_pool_size, const size_t a_refill_size, const Args& ... args) : available_count (0), refill_size(a_refill_size) { fill_pool(initial_pool_size, args ...); }; PoolFactory(const Args& ... args) : PoolFactory (10, 10, args ...) { }; virtual ~PoolFactory() {} virtual P get(const Args& ... args) { for (auto& ptr : pool) { if (ptr.use_count () < 2) { ptr->initialize (args ...); available_count--; return * new (std::shared_ptr<T>) (ptr); } } assert(available_count <= 0); add (refill_size, args ...); return get (args ...); } size_t get_available_count() const { return available_count; } size_t get_pool_size() const { return pool.size(); } size_t get_refill_size() const { return refill_size; } void set_refill_size(const size_t& value) { refill_size = value; } void reset(const size_t& initial_pool_size, const size_t& a_refill_size, const Args& ... args) { pool.clear(); fill_pool(initial_pool_size, args ...); available_count = initial_pool_size; refill_size = a_refill_size; } private: std::vector<typename std::shared_ptr<T>> pool; size_t available_count; size_t refill_size; }; template <class T, typename... Args> class SingletonFactory : public NewFactory <T, Args...> { private: using P = NewFactory<T, Args...>::P; public: SingletonFactory (const Args& ... args) : singleton (std::make_shared<T>(args ...)) { }; virtual ~SingletonFactory () {} virtual P get (const Args& ... args) const { return singleton; } private: std::shared_ptr<T> singleton; }; template <class T, typename... Args> class Factory { public: using P = NewFactory<T, Args...>::P; Factory (const size_t pool_size, const size_t refill_size, const Args& ... args) { mfactory_ptr = std::make_shared<PoolFactory<T, Args...>>(pool_size, refill_size, args ...); }; virtual ~Factory() { } virtual P get (const Args& ... args) { return mfactory_ptr->get(args ...); } NewFactory<T, Args...>& get_factory () const { return *mfactory_ptr.get(); } void set_factory (const NewFactory<T, Args...>* afactory) { mfactory_ptr = afactory; } private: std::shared_ptr<NewFactory<T, Args...>> mfactory_ptr; }; } } #endif </DOCUMENT>
<DOCUMENT filename="field.hpp">
 #ifndef FIELD_HPP #define FIELD_HPP #include "object.hpp" #include "generator.hpp" namespace pensar_digital { namespace cpplib { template <typename T> class Field : public virtual Object { private: T mvalue; bool misnull; S mname; S mdisplay_name; S mdescription; static Generator<Field<T>> mgenerator; public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); Field(S name, S display_name, S description, bool isnull = true, Id id = NULL_ID) : Object (id == NULL_ID ? mgenerator.get () : id), mname (name ), mdisplay_name (display_name), mdescription (description ), misnull (isnull ) { } Field(S name, S display_name, S description, T value, bool is_null = false) : Object (), Field (name, display_name, description, is_null), mvalue (value) { } Field (const Field &other) : Object(other) { assign (other); } Field (Field &&other) : Object(std::move(other)) { assign (other); } virtual Field & assign (const Field &other) { if (this != &other) { Object::operator=(other); mvalue = other.value; misnull = other.misnull; mname = other.name; mdisplay_name = other.display_name; mdescription = other.description; } return *this; } virtual Field& assign (Field &&other) { if (this != &other) { Object::operator=(std::move (other) ); mvalue = std::move (other.value ); misnull = std::move (other.misnull ); mname = std::move (other.name ); mdisplay_name = std::move (other.display_name); mdescription = std::move (other.description ); } return *this; } virtual Field & operator= (const Field &other) { return assign (other); } virtual Field & operator= (Field &&other) { return assign(other); } virtual ~Field() {} virtual T value() const { return value; } virtual void set_value(const T& value) { this->mvalue = value; } virtual bool is_null() const { return misnull; } operator T() const { return value; } virtual S name() const { return mname; } virtual S display_name() const { return mdisplay_name; } virtual S description() const { return mdescription; } virtual S to_string() const noexcept { return value.to_string(); } operator S() const { return to_string(); } virtual bool operator==(const Field& other) const { return mvalue == other.mvalue; } virtual bool operator!=(const Field& other) const { return mvalue != other.mvalue; } virtual bool operator<(const Field& other) const { return mvalue < other.mvalue; } virtual bool operator<=(const Field& other) const { return mvalue <= other.mvalue; } virtual bool operator>(const Field& other) const { return mvalue > other.mvalue; } virtual bool operator>=(const Field& other) const { return mvalue >= other.mvalue; } Field& operator=(const T& value) { this->mvalue = value; return *this; } }; class StringField : public virtual Field<S> { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); StringField(S name, S display_name, S description, bool is_null = true) : Field<S>(name, display_name, description, is_null) { } StringField(S name, S display_name, S description, S value, bool is_null = false) : Field<S>(name, display_name, description, value, is_null) { } StringField(const StringField& other) : Field<S>(other) { assign (other); } StringField(StringField&& other) : Field<S>(std::move(other)) { assign (other); } virtual StringField& assign(const StringField& other) { if (this != &other) { Field<S>::assign(other); } return *this; } virtual ~StringField() {} virtual StringField& operator=(const StringField& other) { return assign(other); } virtual StringField& operator=(StringField&& other) { return assign(other); } }; } } #endif </DOCUMENT>
<DOCUMENT filename="file.cpp">
 #include "file.hpp" #include "s.hpp" namespace pensar_digital { namespace cpplib { InStream& operator >> (InStream& is, File& file) { return file.read (is); } OutStream& operator << (OutStream& os, const File& file) { return file.write (os); } } } </DOCUMENT>
<DOCUMENT filename="file.hpp">
 #ifndef FILE_HPP #define FILE_HPP #ifdef CODE_GEAR #pragma hdrstop #endif #include <fstream> #include <string> #include <filesystem> #include <cstdio> #include <cerrno> #include <cstring> #include <functional> #include "s.hpp" #include "object.hpp" #include "path.hpp" #include "version.hpp" #include "generator.hpp" #include "memory_buffer.hpp" #include "random_util.hpp" #include "log.hpp" #include "error.hpp" #include "icu_util.hpp" #include "constant.hpp" #include "encoding.hpp" namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; namespace fs = std::filesystem; class TextMode; class BinMode; class OpenMode { public: using Mode = std::ios::openmode; private: Mode _mode; public: OpenMode(const std::ios::openmode mode) : _mode(mode) {} inline bool is_bin_mode (const Mode mode) const noexcept { return mode & std::ios::binary; } inline bool is_bin_mode ( ) const noexcept { return is_bin_mode (_mode) ; } inline bool is_text_mode (const Mode mode) const noexcept { return ! is_bin_mode (mode) ; } inline bool is_text_mode ( ) const noexcept { return !is_bin_mode () ; } inline const Mode mode() const noexcept { return _mode; } inline S to_string () const noexcept { S s; if (_mode & std::ios::in ) s += W("in"); if (_mode & std::ios::out ) s += (s.empty() ? W("out" ) : W(" | out" )); if (_mode & std::ios::binary ) s += (s.empty() ? W("binary") : W(" | binary")); if (_mode & std::ios::app ) s += (s.empty() ? W("app" ) : W(" | app" )); if (_mode & std::ios::ate ) s += (s.empty() ? W("ate" ) : W(" | ate" )); if (_mode & std::ios::trunc ) s += (s.empty() ? W("trunc" ) : W(" | trunc" )); } inline const C* c_str() const noexcept { C* buffer = new C[to_string().size() + 1]; return buffer; } inline bool operator == (const OpenMode& mode) const noexcept { return _mode == mode._mode; } inline bool operator != (const OpenMode& mode) const noexcept { return _mode != mode._mode; } inline bool operator == (const Mode mode) const noexcept { return _mode == mode; } inline bool operator != (const Mode mode) const noexcept { return _mode != mode; } inline operator Mode() const noexcept { return _mode; } inline operator S() const noexcept { return to_string(); } inline operator const C* () const noexcept { return c_str(); } static const BinMode BIN_READ; static const BinMode BIN_WRITE; static const BinMode BIN_APPEND; static const BinMode BIN_ATE; static const BinMode BIN_RW; static const BinMode BIN_RW_ATE; static const TextMode TEXT_READ; static const TextMode TEXT_WRITE; static const TextMode TEXT_APPEND; static const TextMode TEXT_ATE; static const TextMode TEXT_RW; static const TextMode TEXT_RWA; static const TextMode TEXT_RW_ATE; static const BinMode DEFAULT_BIN_MODE; static const TextMode DEFAULT_TEXT_MODE; static const OpenMode DEFAULT_OPEN_MODE; }; class BinMode : public OpenMode { public: BinMode (const OpenMode::Mode mode) : OpenMode (mode) { if (!is_bin_mode (mode)) throw Error(W("BinMode::BinMode (): Error: Invalid binary mode: ") + mode); } }; class TextMode : public OpenMode { public: TextMode (const Mode mode) : OpenMode(mode) { if (!is_text_mode(mode)) throw Error(W("TextMode::TextMode(): Error: Invalid text mode: ") + mode); } }; inline const BinMode OpenMode::BIN_READ = BinMode(std::ios::binary | std::ios::in); inline const BinMode OpenMode::BIN_WRITE = BinMode(std::ios::binary | std::ios::out); inline const BinMode OpenMode::BIN_APPEND = BinMode(std::ios::binary | std::ios::app); inline const BinMode OpenMode::BIN_ATE = BinMode(std::ios::binary | std::ios::ate); inline const BinMode OpenMode::BIN_RW = BinMode(std::ios::binary | std::ios::in | std::ios::out); inline const BinMode OpenMode::BIN_RW_ATE = BinMode(std::ios::binary | std::ios::in | std::ios::out | std::ios::ate); inline const TextMode OpenMode::TEXT_READ = TextMode(std::ios::in); inline const TextMode OpenMode::TEXT_WRITE = TextMode(std::ios::out); inline const TextMode OpenMode::TEXT_APPEND = TextMode(std::ios::app); inline const TextMode OpenMode::TEXT_ATE = TextMode(std::ios::ate); inline const TextMode OpenMode::TEXT_RW = TextMode(std::ios::in | std::ios::out); inline const TextMode OpenMode::TEXT_RWA = TextMode(std::ios::in | std::ios::out | std::ios::app); inline const TextMode OpenMode::TEXT_RW_ATE = TextMode(std::ios::in | std::ios::out | std::ios::ate); inline const BinMode OpenMode::DEFAULT_BIN_MODE = BIN_RW; inline const TextMode OpenMode::DEFAULT_TEXT_MODE = TEXT_RWA; inline const OpenMode OpenMode::DEFAULT_OPEN_MODE = DEFAULT_BIN_MODE; class File : public Object { protected: OpenMode _mode; Path _fullpath; std::fstream* _file; public: inline static const size_t MAX_BUFFER_SIZE = 1024 ^ 3; enum Seek { SET = SEEK_SET, CUR = SEEK_CUR, END = SEEK_END }; inline S s_io_error_msg (const errno_t error) const { C msg[icu::BUFFER_SIZE]; #ifdef WIDE_CHAR strerror_s(msg, icu::BUFFER_SIZE, error); icu::utf8_char_ptr_to_wchar_t_ptr(msg, sys_err_msg); #else if (msg == nullptr) log_and_throw(W("File::s_io_error_msg(): Error: Could not convert error message to wide char.")); else strerror_s(msg, icu::BUFFER_SIZE, error); #endif msg[icu::BUFFER_SIZE - 1] = 0; return S(msg); } decltype(File::_file)& file_open (const Path& file_name, OpenMode mode) { #ifdef WIDE_CHAR err = _wfopen_s(&_file, file_name.c_str(), mode.c_str()); #else _file->open (_fullpath.str (), mode); #endif if (_file->fail ()) log_and_throw(S(W("File::file_open(): Error: Could not open file "))); return _file; } public: inline File(const Path& full_path = W("."), const Id id = NULL_ID, const OpenMode mode = OpenMode::DEFAULT_BIN_MODE) : _fullpath(full_path), Object(id), _mode(mode) { _fullpath.create_dir (); _file = new std::fstream (); file_open (_fullpath, mode); } inline virtual ~File() noexcept { close(); free(_file); } inline void close() noexcept { if (is_open()) { _file->close (); if (_file->fail ()) { log_and_throw (S("File::~File(): Error: Could not close file ") + _fullpath.str()); } } } inline bool exists() const { return _fullpath.exists(); } inline const Path& fullpath() const noexcept { return _fullpath; } inline bool is_open() const noexcept { return _file->is_open (); } inline bool is_bin_read () const noexcept { return _mode == OpenMode::BIN_READ ; } inline bool is_bin_write () const noexcept { return _mode == OpenMode::BIN_WRITE ; } inline bool is_bin_rw () const noexcept { return _mode == OpenMode::BIN_RW_ATE; } inline bool is_text_read () const noexcept { return _mode == OpenMode::TEXT_READ ; } inline bool is_text_write () const noexcept { return _mode == OpenMode::TEXT_WRITE ; } inline bool is_text_rw () const noexcept { return _mode == OpenMode::TEXT_RW_ATE; } inline bool eof () const noexcept { return _file->eof () != 0; } inline bool fail () const noexcept { return _file->fail () != 0; } inline const C* c_str() const noexcept { S s = _fullpath.str(); } inline bool remove() { if (is_open()) close(); return fs::remove(_fullpath); } inline virtual bool initialize(const Path& afull_path = CURRENT_DIR, const Id id = NULL_ID, const OpenMode mode = OpenMode::DEFAULT_OPEN_MODE) noexcept { _fullpath = afull_path; _mode = mode; Object::set_id(id); return true; } inline virtual OpenMode get_mode() const noexcept { return _mode; } inline virtual S debug_string() const noexcept { return Object::debug_string() + W(" path = ") + _fullpath.str(); } inline void log_if_error (const errno_t error, const S& error_msg = W("")) const noexcept { if (error != 0) { S errmsg = error_msg + W(" in file ") + _fullpath.to_string() + W (" ") + s_io_error_msg (error); LOG(errmsg); } } inline void log_and_throw_if_error(const errno_t error, const S& error_msg = W("")) const { if (error != 0) { S errmsg = error_msg + W(" in file ") + _fullpath.to_string() + W(" ") + s_io_error_msg(error); LOG(errmsg); throw Error (errmsg); } } inline void move_cursor (FILE* f, const long pos, const Seek seek = Seek::SET) const { errno_t err = fseek (f, pos, seek); if (err != 0) { S error_msg = W("File::move_cursor(): Error: Could not move cursor to position."); log_and_throw_if_error(err, error_msg); } } inline void move_to_start (FILE* f) const { move_cursor (f, 0, Seek::SET); } inline void move_to_end (FILE* f) const { move_cursor (f, 0, Seek::END); } long position (FILE* f) const { long pos = ftell (f); if (pos == -1) { S error_msg = W("File::position(): Error: Could not get file position "); log_and_throw_if_error(errno, error_msg); } return pos; } inline void set_binary_mode (FILE* f) noexcept { long pos = 0; if (is_open()) { long pos = position (f); close(); } _mode = OpenMode::BIN_RW; open(); if (pos > 0) move_cursor (f, pos); } inline void set_text_mode (FILE* f) { long pos = 0; if (is_open()) { long pos = position (f); close(); } _mode = OpenMode::TEXT_RW; open(); if (pos > 0) move_cursor (f, pos); } inline decltype(_file)& open (const OpenMode& mode = OpenMode::DEFAULT_OPEN_MODE) { _mode = mode; if (!is_open()) { _file->open (_fullpath, _mode); } return _file; } inline size_t size() const noexcept { return fs::file_size(_fullpath); } inline size_t size (FILE* f) const noexcept { move_to_end (f); long size = ftell(f); if (size == -1) { S error_msg = W("TextFile::read(): Error: Could not get file size "); LOG(error_msg); } return size; } decltype(_file)& get_stream() { open(); return _file; } }; class TextFile : public File { private: public: inline static const Version::Ptr VERSION = Version::get(1, 1, 1); TextFile(const Path& full_path, const S& content = EMPTY, const TextMode mode = OpenMode::DEFAULT_TEXT_MODE, const Id id = NULL_ID) : File(full_path, id, mode) { if (File::exists()) { if (content != EMPTY) append(content); else { open (mode); } } else { open (mode); write(content); File::close(); } } inline virtual ~TextFile() = default; virtual bool get_char(C* c) { if (!is_open() || !_mode.is_text_mode()) return false; *c = _file->get(); return *c != EOF; } inline bool read_line(std::string& line) { if (!is_open() || !_mode.is_text_mode ()) return false; std::ifstream file_stream(_fullpath.str()); if (!file_stream.is_open()) return false; if (std::getline(file_stream, line)) return true; return false; } inline TextFile& write (const S& content, bool flushes = true) { if (! File::is_open()) File::open (); _file->write(content.c_str(), content.size()); if (fail ()) { log_and_throw (S(W("TextFile::write(): Error: Could not write to the file "))); } if (flushes) { _file->flush(); if (fail()) { log_and_throw(S(W("TextFile::write(): Error: Could not flush the file "))); } } return *this; } inline TextFile& append (const S& content) { if (! File::is_open()) File::open (); write (content); return *this; } inline S fullpath_to_string() const noexcept { return File::_fullpath.to_string (); } inline operator S() const noexcept { return to_string(); } inline S read() { if (! File::is_open()) open (OpenMode::TEXT_READ); size_t file_size = size (); size_t count = file_size / sizeof(C); C* content = new C[count + 1]; memset(content, 0, count + 1); _file->seekg(0, std::ios::beg); size_t read_count = _file->read(content, count).gcount(); if (read_count != count) { delete[] content; S error_msg = W("TextFile::read(): Error: Could not read the file "); log_and_throw (error_msg); } #pragma warning(suppress:6001) return S(content); } }; class RandomFileNameGenerator { private: inline static const size_t DEFAULT_LENGTH = 8; inline static const S DEFAULT_TEXT_FILE_EXTENSION = W("txt"); inline static const S DEFAULT_BINARY_FILE_EXTENSION = W("bin"); enum class ExtensionType { FIXED, RANDOM, NONE, NUMERIC_SEQUENCE, CHAR_SEQUENCE, FUNCTION }; inline static const ExtensionType DEFAULT_EXTENSION_TYPE = ExtensionType::FIXED; typedef std::function<S()> CUSTOM_EXT_FUNCTION; inline static const CUSTOM_EXT_FUNCTION NULL_CUSTOM_EXT_FUNCTION = []() { return EMPTY; }; ExtensionType mextension_type; S mextension; inline static const size_t MAX_FULL_NAME_LENGTH = 255; typedef Generator<RandomFileNameGenerator, size_t> G; G generator; CUSTOM_EXT_FUNCTION mcustom_ext_function; inline static S random_string(const size_t len) { static const S CHARS = W("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"); Random<size_t> r(0, CHARS.size() - 1); S s; size_t i = len; s.reserve(i); typename S::value_type c = CHARS[r()]; size_t count = 1000; while (c >= '0' && c <= '9') { c = CHARS[r()]; if (--count == 0) { S error_msg = W("RandomFileNameGenerator::random_string(): Error: Could not generate a random string after 1000 tries."); LOG(error_msg); runtime_error(error_msg); } } s += c; --i; while (i--) s += CHARS[r ()]; return s; } inline S get_extension() const { switch (mextension_type) { case ExtensionType::FIXED: return mextension; case ExtensionType::RANDOM: return random_string(DEFAULT_LENGTH); case ExtensionType::NONE: return EMPTY; case ExtensionType::CHAR_SEQUENCE: return EMPTY; case ExtensionType::FUNCTION: return mcustom_ext_function(); default: return EMPTY; } } public: inline RandomFileNameGenerator (const ExtensionType ext_type = DEFAULT_EXTENSION_TYPE, const S& extension = DEFAULT_TEXT_FILE_EXTENSION, const CUSTOM_EXT_FUNCTION& custom_ext_function = NULL_CUSTOM_EXT_FUNCTION) : mextension_type(ext_type), mextension(extension), mcustom_ext_function(custom_ext_function) { } inline Path operator() (const S& name_prefix = W(""), const S& name_suffix = W(""), const S& extension = DEFAULT_TEXT_FILE_EXTENSION, const Path& path = TMP_DIR) { return path / (name_prefix + random_string(DEFAULT_LENGTH) + name_suffix + W(".") + get_extension()); } }; class TmpTextFile : public TextFile { public: inline static const Version::Ptr VERSION = Version::get(1, 1, 1); inline TmpTextFile (const S& file_name = EMPTY, const S& content = EMPTY, const Id id = null_value<Id>()) : TextFile(TMP_PATH / file_name, content, OpenMode::DEFAULT_TEXT_MODE, id) { } inline TmpTextFile (const C* file_name = EMPTY, const C* content = EMPTY, const Id id = null_value<Id>()) : TextFile (S(file_name), S(content), OpenMode::DEFAULT_TEXT_MODE, id) {} inline void log_error() { LOG(W("Failed to remove temporary file ") + File::_fullpath.s ()); } inline virtual ~TmpTextFile() { if (!File::remove()) { log_error(); } } }; class BinaryFile : public File { private: public: inline static const Version::Ptr VERSION = Version::get(1, 1, 1); private: inline BinaryFile (const Path& full_path, const OpenMode mode = OpenMode::DEFAULT_BIN_MODE, const BytePtr data = nullptr, const size_t size = 0, const Id id = null_value<Id>() ) : File (full_path, id, mode) { append (data, size); } inline BinaryFile (const Path& full_path, const BytePtr data = nullptr, const size_t size = 0, const Id id = null_value<Id>()) : BinaryFile(full_path, OpenMode::DEFAULT_BIN_MODE, data, size, id) { } inline virtual ~BinaryFile() { close(); } inline BinaryFile& append(const BytePtr data = nullptr, const size_t size = 0) { static_assert (sizeof(char) == sizeof(std::byte), W("sizeof(char) != sizeof(Byte)")); if ((data != nullptr) && (size > 0)) { if (! is_open()) open (OpenMode::BIN_RW_ATE); _file->write(reinterpret_cast<const char*>(data), size); if (_file->fail ()) { S error_msg = W("BinaryFile::append(): Error: Could not append data to the file "); log_and_throw_if_error(errno, error_msg); } } return *this; } private: MemoryBuffer data; }; extern InStream& operator >> (InStream& is, File& file); extern OutStream& operator << (OutStream& os, const File& file); } } #endif </DOCUMENT>
<DOCUMENT filename="file_factory.hpp">
 #ifndef FILE_FACTORY_HPP #define FILE_FACTORY_HPP #include "factory.hpp" #include "io_util.hpp" #include "version.hpp" #include "json_util.hpp" namespace pensar_digital { namespace cpplib { typedef Factory<File, Path, std::ios_base::openmode, Id> FileFactoryBase; class FileFactory : public FileFactoryBase { public: inline static const VersionPtr VERSION = pd::Version::get(1, 1, 1); FileFactory(const Path& afull_path = ".", const std::ios_base::openmode amode = File::IN_OUT_ATE_BIN_MODE, const Id aid = NULL_ID) : FileFactoryBase(3, 10, afull_path, amode, aid) { }; virtual ~FileFactory() { }; using P = FileFactoryBase::P; virtual P get(const Path& afull_path = ".", const std::ios_base::openmode amode = File::IN_OUT_ATE_BIN_MODE, const Id aid = NULL_ID) { return FileFactoryBase::get (afull_path, amode, aid); }; P clone(const File& afile) { return get(afile.get_full_path(), afile.get_mode (), afile.get_id ()); } P clone(const FilePtr& ptr) { return clone(*ptr); } P parse_json(const String& sjson) { Json j; P ptr = get(); std::stringstream ss(sjson); ss >> *ptr; return ptr; }; }; extern FileFactory filef; } } #endif </DOCUMENT>
<DOCUMENT filename="generator - Copy.hpp">
#ifndef GENERATOR_HPP_INCLUDED #define GENERATOR_HPP_INCLUDED #include "object.hpp" #include "error.hpp" namespace pensar_digital { namespace cpplib { template <class T> class Generator : public Object { public: Generator(Id aid = NULL_ID, Id initial_value = 0, Id astep = 1) : Object(aid), value(initial_value), step(astep) {}; virtual ~Generator(){}; Id get () { value += step; return value; } Id get_next () const { return (value + step); } Id get_current () const { return value; } void set_value(Id val) { value = val; } virtual std::istream& ReadFromStream (std::istream& is, const Version v) { Version version; is >> version; switch (version) { case 0: is >> step >> value; default: throw UnsupportedVersion (version); }; return is; }; virtual std::ostream& WriteToStream (std::ostream& os, const Version v) const { switch (v) { case 0: os << value << step << v; default: throw UnsupportedVersion (v); }; return os; }; private: Id value; Id step; }; } } #endif </DOCUMENT>
<DOCUMENT filename="generator.cpp">
 #include "generator.hpp" namespace pensar_digital { namespace cpplib { } } </DOCUMENT>
DOCUMENT filename="generator.hpp">
 #ifndef GENERATOR_HPP_INCLUDED #define GENERATOR_HPP_INCLUDED #include "object.hpp" #include "constant.hpp" #include "string_def.hpp" #include "s.hpp" #include "factory.hpp" #include "error.hpp" #include <memory> #include <iosfwd> #include <bit> #include <concepts> namespace pensar_digital { namespace cpplib { template <typename Type = Id, typename T = Id> class Generator : public Object { public: using UsedByType = Type; using IdType = T; using G = Generator<Type, T>; using GeneratorPtr = std::shared_ptr<G>; using Factory = pd::Factory<G, T, T, T>; inline static Factory mfactory = { 3, 10, null_value<T>(), 0, 1}; private: struct Data : public pd::Data { T minitial_value; T mvalue; T mstep; Data(T initial_value = 0, T step = 1) : minitial_value(initial_value), mvalue(initial_value), mstep(step) {} }; Data mdata; public: inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("Generator"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } using DataType = Data; inline static constexpr size_t DATA_SIZE = sizeof(mdata); inline static constexpr size_t SIZE = DATA_SIZE + sizeof(INFO) + Object::SIZE; inline const pd::Data* generator_data () const noexcept { return &mdata ; } virtual const pd::Data* data() const noexcept { return &mdata; } virtual size_t data_size() const noexcept { return DATA_SIZE; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)&mdata; } inline const BytePtr generator_data_bytes() const noexcept { return (BytePtr)&mdata; } inline static const Data NULL_DATA = { null_value<T>(), null_value<T>() }; inline virtual pd::Data* get_null_data() const noexcept { return (pd::Data*)(&NULL_DATA); } Generator (T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept : Object(aid == null_value<T>() ? 0 : aid), mdata(initial_value, step) {}; Generator(MemoryBuffer& mb) noexcept : Object(mb) { assign_without_parent (mb); } virtual ~Generator () = default; inline G& assign_without_parent (MemoryBuffer& mb) noexcept { INFO.test_class_name_and_version(mb); mb.read_known_size((BytePtr)(&mdata), DATA_SIZE); return *this; } inline G& generator_assign(MemoryBuffer& mb) noexcept { object_assign (mb); return assign_without_parent (mb); } inline virtual Object& assign(MemoryBuffer& mb) noexcept { return generator_assign (mb); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append (object_bytes ()); mb->append (INFO.bytes()); mb->write ((BytePtr)data (), data_size ()); return mb; } inline MemoryBuffer::Ptr generator_bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append(object_bytes()->data (), Object::SIZE); mb->append(INFO.bytes ()); mb->write(generator_data_bytes (), DATA_SIZE); return mb; } inline virtual T get_id () { mdata.mvalue += mdata.mstep; return mdata.mvalue; } inline virtual const T next() { return (mdata.mvalue + mdata.mstep); } inline virtual const T current () const { return mdata.mvalue; } virtual bool initialize (T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept { bool ok = Object::initialize(aid == null_value<T>() ? 0 : aid); mdata.minitial_value = initial_value; mdata.mvalue = initial_value; mdata.mstep = step; return ok; } inline virtual void set_value(T val) { mdata.mvalue = val; } /* virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read (is, byte_order); read_bin_version(is, *VERSION, byte_order); is.read((char*)data(), data_size()); return is; }; virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); VERSION->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; }; */ void set_id (const T& aid) { Object::set_id (aid); } static inline Factory::P get (T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept { return mfactory.get (aid, initial_value, step); }; Factory::P clone() { return get (get_id (), mdata.minitial_value, mdata.mstep); }; inline virtual InStream& read(InStream& is) { Object::read(is); is >> mdata.minitial_value; is >> mdata.mstep; is >> mdata.mvalue; return is; } inline virtual OutStream& write (OutStream& os) const { Object::write(os); return os << mdata.minitial_value << mdata.mstep << W(" ") << mdata.mvalue; } }; template <class Type, typename T> OutStream& operator << (OutStream& os, const Generator<Type, T>& g) { return g.write (os); } template <class Type, typename T> InStream& operator >> (InStream& is, Generator<Type, T>& g) { return g.read (is); } } } #endif </DOCUMENT>
<DOCUMENT filename="global_types.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include "global_types.h" #ifdef BORLAND #pragma package(smart_init) #endif </DOCUMENT>
<DOCUMENT filename="html_util.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #ifdef CODE_GEAR #pragma hdrstop #endif #include "html_util.h" #include <string> #ifdef CODE_GEAR #pragma package(smart_init) #endif namespace pensar_digital { namespace cpplib { std::string escape_html (const std::string& s) { std::string t; std::string::const_iterator i; for(i = s.begin (); i != s.end (); ++i) { switch (*i) { case '<': t += "&lt;"; break; case '>': t += "&gt;"; break; case '&': t += "&amp;"; break; default: t += *i; break; } } return t; } std::string unescape_html (const std::string& s) { std::string t; enum _state {START, E, EL, EG, EA, ELT, EGT, EAM, EAMP} state = START; for(std::string::const_iterator i = s.begin (); i != s.end (); ++i) { switch (state) { case START: if (*i == '&') state = E; else t += *i; break; case E: switch (*i) { case 'l': state = EL; break; case 'g': state = EG; break; case 'a': state = EA; break; case '&': break; default: t += '&'; t += *i; state = START; break; } break; case EL: switch (*i) { case 't': state = ELT; break; case '&': state = E; break; default: t += "&l"; t += *i; state = START; break; } break; case EG: switch (*i) { case 't': state = EGT; break; case '&': state = E; break; default: t += "&g"; t += *i; state = START; break; } break; case EA: switch (*i) { case 'm': state = EAM; break; case '&': state = E; break; default: t += "&a"; t += *i; state = START; break; } break; case ELT: switch (*i) { case ';': t += '<'; state = START; break; case '&': t += "&lt"; state = E; break; default: t += "&lt"; t += *i; state = START; break; } break; case EGT: switch (*i) { case ';': t += '>'; state = START; break; case '&': t += "&gt"; state = E; break; default: t += "&gt"; t += *i; state = START; break; } break; case EAM: switch (*i) { case 'p': state = EAMP; break; case '&': t += "&am"; state = E; break; default: t += "&am"; t += *i; state = START; break; } break; case EAMP: switch (*i) { case ';': t += '&'; state = START; break; case '&': t += "&amp"; state = E; break; default: t += "&amp"; t += *i; state = START; break; } break; default: break; } } return t; } #ifdef CODE_GEAR AnsiString escape_html(AnsiString s) { AnsiString t; for(int i = 1; i <= s.Length(); i++) { char c = s[i]; switch(c) { case '<': t+="&lt;"; break; case '>': t+="&gt;"; break; case '&': t+="&amp;"; break; default: t+=c; break; } } return t; } AnsiString unescape_html (AnsiString s) { AnsiString t; enum _state {START, E, EL, EG, EA, ELT, EGT, EAM, EAMP} state = START; for(int i = 1; i <= s.Length (); ++i) { char c = s[i]; switch (state) { case START: if (c == '&') state = E; else t += c; break; case E: switch (c) { case 'l': state = EL; break; case 'g': state = EG; break; case 'a': state = EA; break; case '&': break; default: t += '&'; t += c; state = START; break; } break; case EL: switch (c) { case 't': state = ELT; break; case '&': state = E; break; default: t += "&l"; t += c; state = START; break; } break; case EG: switch (c) { case 't': state = EGT; break; case '&': state = E; break; default: t += "&g"; t += c; state = START; break; } break; case EA: switch (c) { case 'm': state = EAM; break; case '&': state = E; break; default: t += "&a"; t += c; state = START; break; } break; case ELT: switch (c) { case ';': t += '<'; state = START; break; case '&': t += "&lt"; state = E; break; default: t += "&lt"; t += c; state = START; break; } break; case EGT: switch (c) { case ';': t += '>'; state = START; break; case '&': t += "&gt"; state = E; break; default: t += "&gt"; t += c; state = START; break; } break; case EAM: switch (c) { case 'p': state = EAMP; break; case '&': t += "&am"; state = E; break; default: t += "&am"; t += c; state = START; break; } break; case EAMP: switch (c) { case ';': t += '&'; state = START; break; case '&': t += "&amp"; state = E; break; default: t += "&amp"; t += c; state = START; break; } break; default: break; } } return t; } #endif } } </DOCUMENT>
<DOCUMENT filename="iconstraint.hpp">
 #ifndef ICONSTRAINT_HPP #define ICONSTRAINT_HPP #include "iobject.hpp" #include "constraint.hpp" #include "concept.hpp" #include "version_factory.hpp" namespace pensar_digital { namespace cpplib { template <Checkable Derived> class IConstraintRO : public virtual Object { public: inline static const VersionPtr VERSION = pd::versionf.get (1, 1, 1); ~IConstraintRO () noexcept = default; virtual const String& get_name() const noexcept = 0; }; template <Checkable Derived> class IConstraint : public virtual IConstraintRO<Derived>, public virtual Object { public: inline static const VersionPtr VERSION = pd::versionf.get (1, 1, 1); ~IConstraint () noexcept = default; virtual const String& get_name() const noexcept = 0; virtual bool initialize(const Id& aid = NULL_ID, const String& aname = "") noexcept = 0; }; } } #endif </DOCUMENT>
<DOCUMENT filename="icu_util.hpp">
 #ifndef ICU_UTIL_HPP #define ICU_UTIL_HPP #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/ucsdet.h" #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/utypes.h" #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/ucnv.h" #include "C:/vcpkg/packages/icu_x64-windows/include/unicode/ustring.h" #include <string> #include <fstream> #include <vector> #include <iostream> #include <exception> #include <stdio.h> #include <string.h> #include "string_def.hpp" #include "log.hpp" #include "encoding.hpp" namespace pensar_digital { namespace cpplib { namespace icu { inline static const size_t BUFFER_SIZE = 1024; #undef max static inline constexpr size_t max_int32_t = std::numeric_limits<int32_t>::max(); inline void convert_utf8_to_uchar(const char* src, UChar* dest, int32_t destCapacity) { UErrorCode status = U_ZERO_ERROR; int32_t destLen = ucnv_toUChars(NULL, NULL, 0, src, -1, &status); status = U_ZERO_ERROR; if (destLen <= destCapacity) { ucnv_toUChars(NULL, dest, destLen, src, -1, &status); if (U_FAILURE(status)) { std::basic_string<C> msg = W("convert_utf8_to_uchar: Failed to convert error message"); LOG(msg); throw msg; } } else { std::stringstream msg; msg << "convert_utf8_to_uchar: destination buffer is too small. Required size = " << destLen << " but it was " << destCapacity; std::basic_string<C> error = W(msg.str()); LOG(error); throw error; } } inline void char_ptr_to_uchar_ptr(const char* msg, UChar* out) { if (strlen(msg) > BUFFER_SIZE) { std::stringstream msg; msg << "char_ptr_to_uchar_ptr: Message is too big to be converted to UChar string. Max. size = " << BUFFER_SIZE; std::basic_string<C> error = W(msg.str()); LOG(error); throw error; } convert_utf8_to_uchar (msg, out, BUFFER_SIZE); } inline void utf8_char_ptr_to_wchar_t_ptr (const char* msg, wchar_t* out) { UChar uMsg[BUFFER_SIZE]; convert_utf8_to_uchar (msg, uMsg, BUFFER_SIZE); UErrorCode status = U_ZERO_ERROR; wchar_t wcharMsg[BUFFER_SIZE]; u_strToWCS(wcharMsg, BUFFER_SIZE, NULL, uMsg, -1, &status); if ( !U_SUCCESS(status)) { std::basic_string<C> error = W("char_ptr_to_wchar_ptr: Error converting UChar to wchar_t"); LOG(error); throw error; } } inline std::wstring to_wstring(const std::string& s) { UErrorCode status = U_ZERO_ERROR; UConverter* conv = ucnv_open("utf-8", &status); if (U_FAILURE(status)) { wprintf(L"Failed to open the converter\n"); } int32_t destLen = ucnv_toUChars(conv, NULL, 0, s.c_str(), -1, &status); status = U_ZERO_ERROR; UChar* dest = new UChar[destLen]; ucnv_toUChars(conv, dest, destLen, s.c_str(), -1, &status); if (U_FAILURE(status)) { wprintf(L"Failed to convert error message\n"); } wchar_t wcharMsg[BUFFER_SIZE]; u_strToWCS(wcharMsg, BUFFER_SIZE, NULL, dest, -1, &status); if (!U_SUCCESS(status)) { } return std::wstring(wcharMsg); } inline std::string utf16_to_utf8 (const std::wstring& s) { UErrorCode status = U_ZERO_ERROR; UConverter* conv = ucnv_open("utf-8", &status); if (U_FAILURE(status)) { std::basic_string<C> error = W("pd::icu::utf16_to_utf8: Error getting converter."); LOG(error); throw error; } const UChar* source = reinterpret_cast<const UChar*>(s.c_str()); size_t slen = s.length(); if (slen > max_int32_t) { std::basic_string<C> error = W("pd::icu::utf16_to_utf8: Error converting string. Buffer size is too big."); LOG(error); throw error; } uint32_t len = static_cast<uint32_t>(slen); int32_t destLen = ucnv_fromUChars(conv, NULL, 0, source, len, &status); status = U_ZERO_ERROR; char* dest = new char[destLen + 1]; ucnv_fromUChars(conv, dest, destLen + 1, source, len, &status); if (U_FAILURE(status)) { S error = W("pd::icu::utf16_to_utf8: Error converting string."); LOG(error); throw error; } std::string result(dest, destLen); delete[] dest; ucnv_close(conv); return result; } #ifdef Windows std::string to_string(const std::wstring& s) { return utf16_to_utf8(s); } #endif inline std::string utf32_to_utf8(const std::wstring& s) { UErrorCode status = U_ZERO_ERROR; UConverter* convToUTF8 = ucnv_open("UTF-8", &status); if (U_FAILURE(status)) { S error = W("1. pd::icu::utf32_to_utf8: Failed to open UTF-8 converter."); LOG(error); throw error; } UConverter* convFromUTF32 = ucnv_open("UTF-32", &status); if (U_FAILURE(status)) { ucnv_close(convToUTF8); S error = W("2. pd::icu::utf32_to_utf8: Failed to open UTF-32 converter."); LOG(error); throw error; } size_t slen = s.length(); if (slen > max_int32_t) { S error = W("pd::icu::utf32_to_utf8: Error converting string. Buffer size is too big."); LOG(error); throw error; } int32_t srcLength = static_cast<int32_t>(slen); const UChar* source = reinterpret_cast<const UChar*>(s.c_str()); int32_t utf8Length = ucnv_fromUChars(convToUTF8, NULL, 0, source, srcLength, &status); if (U_FAILURE(status)) { ucnv_close(convToUTF8); ucnv_close(convFromUTF32); S error = W("pd::icu::utf32_to_utf8: Failed to calculate buffer size for UTF-8 string."); LOG(error); throw error; } char* utf8String = new char[utf8Length + 1]; status = U_ZERO_ERROR; ucnv_fromUChars(convToUTF8, utf8String, utf8Length + 1, source, srcLength, &status); if (U_FAILURE(status)) { delete[] utf8String; ucnv_close(convToUTF8); ucnv_close(convFromUTF32); S error = W("pd::icu::to_string: Failed to convert string from UTF-32 to UTF-8."); LOG(error); throw error; } std::string result(utf8String, utf8Length); delete[] utf8String; ucnv_close(convToUTF8); ucnv_close(convFromUTF32); return result; } inline bool check_bom (const std::vector<char>& buffer, Encoding& encoding) { bool detected = true; if (buffer.size () >= 4) { if (buffer[0] == 0x00 && buffer[1] == 0x00 && buffer[2] == 0xFE && buffer[3] == 0xFF) { encoding = UTF_32_BE_BOM; } else if (buffer[0] == 0xFF && buffer[1] == 0xFE && buffer[2] == 0x00 && buffer[3] == 0x00) { encoding = UTF_32_LE_BOM; } } else if (buffer.size() >= 3) { if (buffer[0] == 0xEF && buffer[1] == 0xBB && buffer[2] == 0xBF) { encoding = UTF_8_BOM; } } else if (buffer.size() >= 2) { if (buffer[0] == 0xFE && buffer[1] == 0xFF) { encoding = UTF_16_BE_BOM; } else if (buffer[0] == 0xFF && buffer[1] == 0xFE) { encoding = UTF_16_LE_BOM; } } else detected = false; return detected; } inline Encoding s_encoding_to_encoding(const std::string& s_encoding) { if (s_encoding == "ASCII") { return ASCII; } else if (s_encoding == "UTF-8") { return UTF_8; } else if (s_encoding == "UTF-8-BOM") { return UTF_8_BOM; } else if (s_encoding == "UTF-16-BE") { return UTF_16_BE; } else if (s_encoding == "UTF-16-BE-BOM") { return UTF_16_BE_BOM; } else if (s_encoding == "UTF-16-LE") { return UTF_16_LE; } else if (s_encoding == "UTF-16-LE-BOM") { return UTF_16_LE_BOM; } else if (s_encoding == "UTF-32-BE") { return UTF_32_BE; } else if (s_encoding == "UTF-32-BE-BOM") { return UTF_32_BE_BOM; } else if (s_encoding == "UTF-32-LE") { return UTF_32_LE; } else if (s_encoding == "UTF-32-LE-BOM") { return UTF_32_LE_BOM; } else { throw std::runtime_error("Error: Unknown encoding " + s_encoding); } } inline Encoding detect_encoding (const std::string& file_name) { std::ifstream file_stream(file_name, std::ios::binary); if (!file_stream.is_open()) { throw std::runtime_error("Error: Could not open file " + file_name); } constexpr size_t MAX_BYTES = 10000; std::vector<char> buffer(MAX_BYTES); file_stream.read(buffer.data(), MAX_BYTES); std::streamsize bytes_read = file_stream.gcount(); if (file_stream.bad()) { file_stream.close(); throw std::runtime_error("Error: Could not read file " + file_name); } file_stream.close(); Encoding bom_encoding; if (check_bom (buffer, bom_encoding)) { return bom_encoding; } UErrorCode error = U_ZERO_ERROR; UCharsetDetector* csd = ucsdet_open(&error); if (U_FAILURE(error)) { throw std::runtime_error("Error: Could not open ICU charset detector"); } ucsdet_setText(csd, buffer.data(), static_cast<int32_t>(buffer.size()), &error); if (U_FAILURE(error)) { ucsdet_close(csd); throw std::runtime_error("Error: Could not set text for ICU charset detector"); } const UCharsetMatch* match = ucsdet_detect(csd, &error); if (U_FAILURE(error)) { ucsdet_close(csd); throw std::runtime_error("Error: Could not detect charset"); } const char* detected_encoding = ucsdet_getName(match, &error); if (U_FAILURE(error)) { ucsdet_close(csd); throw std::runtime_error("Error: Could not get detected charset name"); } std::string s_encoding(detected_encoding); ucsdet_close(csd); return s_encoding_to_encoding (detected_encoding); } } } } #endif </DOCUMENT>
<DOCUMENT filename="id-generator - Copy.hpp">
#ifndef IDGENERATOR_HPP #define IDGENERATOR_HPP template <class T, typename Id = int64_t> class IdGenerator { public: IdGenerator() {} virtual ~IdGenerator() {} static Id get_id () { return ++id;} private: static Id id; }; #endif </DOCUMENT>
<DOCUMENT filename="id.hpp">
#ifndef ID_HPP_INCLUDED #define ID_HPP_INCLUDED #include "version.hpp" namespace pensar_digital { namespace cpplib { template <class T = int64_t> class ReadOnlyId : public Version { protected: ~ReadOnlyId() {} public: typedef T value_type; ReadOnlyId (const T aid = -1): Version(0), id(aid) {} T get_id () const { return id;} bool operator == (const ReadOnlyId<T>& aid) const {return (aid.id == id);} bool operator != (const ReadOnlyId<T>& aid) const {return (aid.id != id);} using Version::operator <<; using Version::operator >>; virtual std::istream& ReadFromStream (std::istream& is, const Version::V v) { switch (v) { case 0: return is >> id; }; return is; }; virtual std::ostream& WriteToStream (std::ostream& os, const Version::V v) const { switch (v) { case 0: return os << id; }; return os; }; protected: T id; }; template <class T = int64_t> class Id : public ReadOnlyId<T> { protected: ~Id() {}; public: Id (const T aid = -1): ReadOnlyId<T>(aid) {} void set_id(T val) { ReadOnlyId<T>::id = val;} using ReadOnlyId<T>::operator ==; using ReadOnlyId<T>::operator !=; using ReadOnlyId<T>::operator <<; using ReadOnlyId<T>::operator >>; }; } } #endif </DOCUMENT>
<DOCUMENT filename="idgenerator.hpp">
#ifndef IDGENERATOR_HPP #define IDGENERATOR_HPP #include "object.hpp" namespace pensar_digital { namespace cpplib { template <class T, typename Id = int64_t> class IdGenerator { public: IdGenerator(): id(NULL_ID) {} virtual ~IdGenerator() {} Id get_id () { return ++id;} private: Id id; }; } } #endif </DOCUMENT>
<DOCUMENT filename="ifile.hpp">
 #ifndef IFILE_HPP #define IFILE_HPP #include "constant.hpp" #include "string_def.hpp" #include "header_lib/json.hpp" #include "version_factory.hpp" #include "iobject.hpp" #include <iostream> #include <memory> #ifdef _MSC_VER #include <filesystem> #else #include <experimental/filesystem> #endif namespace pensar_digital { namespace cpplib { class IFile; class IFileRO; typedef std::shared_ptr<IFileRO> IFile_RO_Ptr; typedef std::shared_ptr<IFile> IFilePtr; class IFileRO : public virtual IObjectRO { public: inline static const IVersionPtr VERSION = pd::versionf.get(1, 1, 1); virtual ~IFileRO() noexcept = default; virtual fs::path get_full_path() const noexcept = 0; virtual std::ios_base::openmode get_mode() const noexcept = 0; }; class IFile : public virtual IFileRO, public virtual IObject { public: inline static const IVersionPtr VERSION = pd::versionf.get(1, 1, 1); virtual ~IFile() noexcept = default; virtual std::istream& read (std::istream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) = 0; virtual void set_name(const String& name) noexcept = 0; virtual void from_xml(const String& sxml) = 0; }; } } #endif </DOCUMENT>
<DOCUMENT filename="igenerator.hpp">
 #ifndef IGENERATOR_HPP_INCLUDED #define IGENERATOR_HPP_INCLUDED #include "iobject.hpp" #include "version_factory.hpp" namespace pensar_digital { namespace cpplib { template <class T> class IGeneratorRO : public virtual Object { public: inline static const VersionPtr VERSION = pd::versionf.get (1, 1, 1); virtual ~IGeneratorRO() noexcept = default; virtual const Id get_current() const = 0; virtual String json() const noexcept = 0; virtual std::ostream& write (std::ostream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) const = 0; }; template <class T> class IGenerator : public virtual IGeneratorRO<T>, public virtual Object { public: inline static const VersionPtr VERSION = pd::versionf.get (1, 1, 1); virtual ~IGenerator() noexcept = default; virtual const Id get() = 0; virtual const Id get_next() = 0; virtual void set_value(Id val) = 0; virtual std::istream& read (std::istream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) = 0; }; } } #endif </DOCUMENT>
<DOCUMENT filename="iobject.hpp">
 #ifndef IOBJECT_HPP #define IOBJECT_HPP #include "constant.hpp" #include "string_def.hpp" #include "header_lib/json.hpp" #include <iostream> #include <memory> namespace pensar_digital { namespace cpplib { class IObject; class IObjectRO; typedef std::shared_ptr<IObjectRO> IObjectROPtr; typedef std::shared_ptr<IObject> IObjectPtr; class IObjectRO { public: virtual ~IObjectRO() noexcept = default; virtual String class_name() const = 0; virtual String debug_string() const noexcept = 0; virtual const Id get_id() const noexcept = 0; virtual const Hash get_hash() const noexcept = 0; virtual String json() const noexcept = 0; virtual String to_string() const noexcept = 0; virtual std::ostream& write (std::ostream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) const = 0; virtual String xml() const noexcept = 0; virtual bool operator == (const IObjectRO& o) const = 0; virtual bool operator != (const IObjectRO& o) const = 0; virtual operator String () const noexcept = 0; }; class IObject : public virtual IObjectRO { public: virtual ~IObject() noexcept = default; virtual void set_id (const Id& value) = 0; virtual std::istream& read (std::istream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) = 0; virtual void from_xml(const String & sxml) = 0; }; } } #endif </DOCUMENT>
<DOCUMENT filename="io_util.hpp">
 #ifndef IO_UTIL_HPP #define IO_UTIL_HPP #include "multiplatform.hpp" #include "defines.hpp" #include "s.hpp" #include "memory.hpp" #include "constant.hpp" #include "concept.hpp" #include "icu_util.hpp" #include "log.hpp" #include "error.hpp" #include "code_util.hpp" #include INCLUDE(io_util) namespace pensar_digital { namespace cpplib { using LINE_HANDLER = void(*)(const int64_t line_count, const S& line); Result<S> get_exe_full_path(); } } #endif </DOCUMENT>
<DOCUMENT filename="ipath.hpp">
 #ifndef IPATH_HPP #define IPATH_HPP #include "constant.hpp" #include "string_def.hpp" #include "header_lib/json.hpp" #include "version_factory.hpp" #include "iobject.hpp" #include <iostream> #include <memory> #ifdef _MSC_VER #include <filesystem> #else #include <experimental/filesystem> #endif namespace pensar_digital { namespace cpplib { #ifdef _MSC_VER namespace fs = std::filesystem; #else namespace fs = std::experimental::filesystem; #endif class IPath; class IPathRO; typedef std::shared_ptr<IPathRO> IPath_RO_Ptr; typedef std::shared_ptr<IPath> IPathPtr; class IPathRO : public virtual IObjectRO { public: inline static const IVersionPtr VERSION = pd::versionf.get(1, 1, 1); virtual ~IPathRO() noexcept = default; virtual fs::path to_std_path() const noexcept = 0; }; class IPath : public virtual IPathRO, public virtual IObject { public: inline static const IVersionPtr VERSION = pd::versionf.get(1, 1, 1); virtual ~IPath() noexcept = default; virtual std::istream& read (std::istream& os, const IO_Mode& amode = TEXT, const ByteOrder& abyte_order = LITTLE_ENDIAN) = 0; virtual void from_xml(const String& sxml) = 0; }; } } #endif </DOCUMENT>
<<DOCUMENT filename="language.hpp">
#ifndef LANGUAGE_HPP #define LANGUAGE_HPP #include "object.hpp" #include "s.hpp" #include "generator.hpp" #include "version.hpp" namespace pensar_digital { namespace cpplib { class Language : public virtual Object { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); Language(Id aid = NULL_ID) : Object(aid == NULL_ID ? generator.get_id () : aid){} virtual ~Language() {}; /** Copy constructor * \param other Object to copy from */ Language(const Language& other); /** Assignment operator * \param other Object to assign from * \return A reference to this */ Language& operator=(const Language& other); protected: private: static Generator<Language> generator; }; } } #endif </DOCUMENT>
<DOCUMENT filename="linux\io_util_linux.hpp">
 #ifndef io_utilH #define io_utilH #include "defines.hpp" #include "s.hpp" #include "memory.hpp" #include "constant.hpp" #include "concept.hpp" #include "icu_util.hpp" #include "log.hpp" #include "error.hpp" #include <string> #ifdef _MSC_VER #include <io.h> #include <windows.h> #include <filesystem> #else #include <experimental/filesystem> #endif namespace pensar_digital { namespace cpplib { namespace fs = std::filesystem; #ifdef _MSC_VER inline S& windows_read_file (const S& filename, S* s) { #ifdef WIDE_CHAR std::string fname = to_string(filename); HANDLE file = CreateFileA(fname.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); #else std::wstring fname = to_wstring(filename); HANDLE file = CreateFileW(fname.c_str (), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); #endif if (file == INVALID_HANDLE_VALUE) { } DWORD file_size = GetFileSize(file, NULL); #pragma warning(push) #pragma warning(disable: 6387) HANDLE file_mapping = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL); if (file_mapping == NULL) { log_and_throw("windows_read_file: Error mapping file: " + filename); } #pragma warning(pop) else { char* addr = static_cast<char*>(MapViewOfFile(file_mapping, FILE_MAP_READ, 0, 0, file_size)); if (addr == NULL) { log_and_throw("windows_read_file: Error mapping view of file: " + filename); } else { #ifdef WIDE_CHAR std::string* s2 = new std::string(addr, file_size); *s = to_wstring(*s2); #else s = new S(addr, file_size); #endif UnmapViewOfFile(addr); if (file_mapping != 0) CloseHandle(file_mapping); CloseHandle(file); return *s; } } } #endif #ifdef __linux__ inline S& linux_read_file (const S& filename, S* s) { int fd = open(filename.c_str(), O_RDONLY); if (fd == -1) { } struct stat sb; if (fstat(fd, &sb) == -1) { } char* addr = static_cast<char*>(mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0u)); if (addr == MAP_FAILED) { } s = new S (addr, sb.st_size); munmap(addr, sb.st_size); close(fd); return s; } #endif inline S& read_file_mmap (const S& filename, S *s) { #ifdef _MSC_VER return windows_read_file (filename, s); #endif #ifdef __linux__ return linux_read_file (filename, s); #endif } template <typename T> void binary_write(std::ostream& os, const T& t, const size_t& size, const std::endian& byte_order = std::endian::native) { os.write((char*)&size, sizeof(size)); os.write((char*)&t, size); /* if (byte_order == LITTLE_ENDIAN) { for (size_t i = 0; i < size; ++i) { os.put(static_cast<char>(t >> (i * 8))); } } else { for (size_t i = 0; i < size; ++i) { os.put(static_cast<char>(t >> ((size - i - 1) * 8))); } } */ } /* template <typename T> void binary_write(std::ostream& os, const T& t, const size_t& size) { os.write(reinterpret_cast<const char*>(&t), size); } */ template <Sizeofable T> void binary_write (std::ostream& os, const T& t, const std::endian& byte_order = std::endian::native) { os.write ((char*)&t, sizeof(t)); } template <typename CharType> void binary_write (std::ostream& os, const std::basic_string<CharType>& s, const std::endian& byte_order = std::endian::native) { binary_write<size_t> (os, s.size(), byte_order); for (auto&& c : s) { binary_write<CharType> (os, c, byte_order); } } inline void binary_write (std::ostream& os, const S& s, const std::endian& byte_order = std::endian::native) { binary_write<S::value_type> (os, s, byte_order); } template <typename T> void binary_read (std::istream& is, T& t, const size_t& size, const std::endian& byte_order = std::endian::native) { is.read ((char*)(&size), sizeof(size)); is.read ((char*)(&t), size); /* t = 0; if (bye_order == LITTLE_ENDIAN) { for (size_t i = 0; i < size; ++i) { t |= static_cast<T>(static_cast<uint8_t>(is.get())) << (i * 8); } } else { for (size_t i = 0; i < size; ++i) { t |= static_cast<T>(static_cast<uint8_t>(is.get())) << ((size - i - 1) * 8); } } */ } template <Sizeofable T> void binary_read (std::istream& is, T& t, const std::endian& byte_order = std::endian::native) { is.read ((char*)(&t), sizeof(t)); } inline void binary_read (std::istream& is, S& s, const std::endian& byte_order = std::endian::native) { size_t size; binary_read<size_t>(is, size, byte_order); s.clear(); s.reserve(size); is.read((char*)(&s), size); } template <typename DataType = uint8_t, typename CharType = S::value_type> std::basic_string<CharType>& binary_to_string (const std::vector<DataType>& data, std::basic_string<CharType>& out) { out.clear(); out.reserve(data.size() * sizeof(DataType) / sizeof(CharType)); for (auto&& byte : data) { for (size_t i = 0; i < sizeof(DataType); ++i) { out.push_back(static_cast<CharType>(byte >> (i * 8))); } } return out; } template <typename DataType = uint8_t, typename CharType = char> void string_to_binary (const std::basic_string<CharType>&in, std::vector<DataType>&out) { out.clear(); out.reserve(in.size() * sizeof(CharType) / sizeof(DataType)); for (size_t i = 0; i < in.size(); i += sizeof(DataType)) { DataType byte = 0; for (size_t j = 0; j < sizeof(DataType); ++j) { byte |= static_cast<DataType>(static_cast<uint8_t>(in[i + j])) << (j * 8); } out.push_back(byte); } } using LINE_HANDLER = void(*)(const int64_t line_count, const S& line); extern uintmax_t read_file(const S& fname, LINE_HANDLER f); extern void create_empty_file(const C* file_full_path); extern void handle_error(const char* msg); extern bool file_exists(const std::string& filename); #ifdef WINDOWS extern __int64 get_file_size(const S& file_name); #endif /* #include <fstream> #include <string> #include <sys/mman.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> std::string read_file(const std::string& filename) { int fd = open(filename.c_str(), O_RDONLY); if (fd == -1) { } struct stat sb; if (fstat(fd, &sb) == -1) { } char* addr = static_cast<char*>(mmap(nullptr, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0)); if (addr == MAP_FAILED) { } std::string str(addr, sb.st_size); munmap(addr, sb.st_size); close(fd); return str; } */ extern const int SAME_NAME; extern const int SAME_SIZE; extern const int SAME_TIME; extern const int SAME_ALL; #ifdef BORLAND extern bool operator == (const std::ftime& left, const std::ftime& right); extern bool operator != (const std::ftime& left, const std::ftime& right); extern bool operator < (const std::ftime& left, const std::ftime& right); extern std::ftime fileTimestamp (const char* gridFilePath); extern std::string fileTimestampS (const char* gridFilePath); #endif #ifdef WIN32 extern __int64 get_file_size (const std::string& file_name); #endif } } #endif </DOCUMENT>
<DOCUMENT filename="locale.hpp">
 #ifndef LOCALE_HPP #define LOCALE_HPP #include "object.hpp" #include "s.hpp" #include "language.hpp" #include "country.hpp" namespace pensar_digital { namespace cpplib { class Locale : public virtual Object { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); Locale(const typename Id aid = NULL_ID) {} virtual ~Locale() {} /** Copy constructor * \param other Object to copy from */ Locale(const Locale& other) {} /** Assignment operator * \param other Object to assign from * \return A reference to this */ Locale& operator=(const Locale& other) {} /** Access name * \return The current value of name */ S get_name() { return W(""); } /** Access language * \return The current value of language */ Language* get_language() { return language; } /** Access country * \return The current value of country */ Country* get_country() { return country; } private: Language* language; Country* country; }; } } #endif </DOCUMENT>
<DOCUMENT filename="log.hpp">
#ifndef LOG_H_INCLUDED #define LOG_H_INCLUDED #include "macros.hpp" #include "string_def.hpp" #include <iostream> #include <fstream> #include <string> namespace pensar_digital { namespace cpplib { static inline bool log_on = true; static const std::ios::openmode DEFAULT_LOG_FILE_OPEN_MODE = (std::ios::out | std::ios::app); #define LOG_ON #define CODEGEAR_BUG #define SHOW_LOCAL inline static const C* default_log_file_name() { return W("C:\\out\\log.txt"); } static bool initialized = false; static inline FStream log_stream; #ifdef LOG_ON #ifdef SHOW_LOCAL #define cpplog if (pensar_digital::cpplib::log_on) pensar_digital::cpplib::log_stream << __LINE__ #else #define cpplog if (pensar_digital::cpplib::log_on) pensar_digital::cpplib::log_stream #endif static inline FStream& open_log_file (const C* full_path = default_log_file_name (), const std::ios::openmode mode = DEFAULT_LOG_FILE_OPEN_MODE) { if (!initialized) { log_stream.open(full_path, mode); if (!log_stream.is_open()) { std::cerr << "Error opening log file " << full_path << std::endl; } initialized = true; } else if (!log_stream.is_open()) { log_stream.open (full_path, mode); if (!log_stream.is_open()) { std::cerr << "Error opening log file " << full_path << std::endl; } } return log_stream; } static inline void enable_log () {if ((!initialized) || (!log_stream.is_open ())) open_log_file (); log_on = true;} static inline void disable_log() { log_stream.flush(); log_stream.close(); log_on = false; initialized = false; } #define LOG(msg) cpplog << msg << std::endl; pensar_digital::cpplib::log_stream.flush(); #define LOG_FLUSH pensar_digital::cpplib::log_stream.flush (); #else #ifndef CODEGEAR_BUG #define cpplog \/\/ #define LOG \/\/ #define LOG_FLUSH \/\/ #else #define cpplog if (0) out () #define LOG if (0) #define LOG_FLUSH ; #endif #endif } } #endif </DOCUMENT>
<DOCUMENT filename="macros.hpp">
 #ifndef MACROS_HPP_INCLUDED #define MACROS_HPP_INCLUDED #define WIDE2(x) L##x #define WIDE1(x) WIDE2(x) #define __WFILE__ WIDE1(__FILE__) #ifdef WIDE_CHAR #define FILE_LINE __WFILE__ << L"\t linha " << __LINE__ << L"\t" #else #define FILE_LINE __FILE__ << "\t linha " << __LINE__ << "\t" #endif #endif </DOCUMENT>
<DOCUMENT filename="mac_address.hpp">
#ifndef MAC_ADDRESS_HPP #define MAC_ADDRESS_HPP #include <string> #include <inttypes.h> namespace pensar_digital { namespace cpplib { class MacAddress { int64_t mac; public: MacAddress(int64_t mac) : mac(mac) {} operator std::string() const { char buffer[18]; sprintf_s(buffer, "%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64 ":%02" PRIx64, (mac >> 40) & 0xff, (mac >> 32) & 0xff, (mac >> 24) & 0xff, (mac >> 16) & 0xff, (mac >> 8) & 0xff, mac & 0xff); return buffer; } operator int64_t() const { return mac; } operator std::wstring() const { wchar_t buffer[18]; swprintf_s(buffer, L"%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64 L":%02" PRIx64, (mac >> 40) & 0xff, (mac >> 32) & 0xff, (mac >> 24) & 0xff, (mac >> 16) & 0xff, (mac >> 8) & 0xff, mac & 0xff); return buffer; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="memory.hpp">
#ifndef MEMORY_H_INCLUDED #define MEMORY_H_INCLUDED #include "constant.hpp" #include <cstring> namespace pensar_digital { namespace cpplib { extern size_t getPeakRSS(); extern size_t get_available_memory(); static inline BytePtr memory_copy(const BytePtr dest, const BytePtr src, size_t size) { std::memcpy(static_cast <void*> (dest), static_cast <void*> (src), size); } } } #endif </DOCUMENT>
<DOCUMENT filename="memory_buffer.hpp">
 #ifndef MEMORY_BUFFER_HPP #define MEMORY_BUFFER_HPP #include "constant.hpp" #include "concept.hpp" #include "factory.hpp" #include <memory> #include <concepts> #include <exception> #include <string> #include <typeinfo> #include <string.h> #include <utility> #include <unordered_map> #include <functional> #include <typeindex> #include <span> namespace pd = pensar_digital::cpplib; namespace pensar_digital { namespace cpplib { class MemoryBuffer { public: using Offset = size_t; using Ptr = std::unique_ptr<MemoryBuffer>; protected: std::span<std::byte> mbuffer; Offset mwrite_offset; Offset mread_offset; std::unordered_map<Offset, size_t> mindex; public: MemoryBuffer(size_t initial_size = 1024*1024) : mread_offset(0), mwrite_offset(0) { mbuffer = std::span<std::byte>(new std::byte[initial_size], initial_size); } MemoryBuffer(BytePtr bp, size_t size) : MemoryBuffer() { write (bp, size); } MemoryBuffer (const Ptr ptr, size_t size) : MemoryBuffer() { write(ptr->data(), size); } MemoryBuffer(const MemoryBuffer& mb) : MemoryBuffer() { write(mb.mbuffer.data(), mb.size()); } template <class T> requires std::is_trivially_copyable_v<T> MemoryBuffer(const T* t) : MemoryBuffer() { write(t, sizeof(T)); } template <HasStdLayoutTriviallyCopyableData T> MemoryBuffer(const T& t) : MemoryBuffer() { write(t.data_bytes(), T::DATA_SIZE); } template <HasStdLayoutTriviallyCopyableData T> MemoryBuffer() : MemoryBuffer() { T t; write(t.data_bytes(), T::DATA_SIZE); } template <HasStdLayoutTriviallyCopyableData T> MemoryBuffer& operator+=(const T& t) { write(t.data_bytes(), T::DATA_SIZE); return *this; } Offset subtract_from_read_offset (const Offset& amount) { if (amount > mread_offset) { throw std::runtime_error("MemoryBuffer::subtract_from_read_offset: invalid amount to subtract."); } mread_offset -= amount; return mread_offset; } void reset_read_offset () { mread_offset = 0; } virtual ~MemoryBuffer() { delete[] mbuffer.data(); } BytePtr data() noexcept { return mbuffer.data(); } const BytePtr data() const noexcept { return mbuffer.data(); } const size_t size() const noexcept { return mbuffer.size(); } const size_t count() const noexcept { return mindex.size(); } const Offset woffset() const noexcept { return mwrite_offset; } const size_t data_size() const noexcept { return mwrite_offset; } const Offset roffset() const noexcept { return mread_offset; } const size_t wavailable() const noexcept { return mbuffer.size() - mwrite_offset; } const size_t ravailable() const noexcept { return mwrite_offset - mread_offset; } Offset write(const BytePtr data, const size_t size) noexcept { if (wavailable() < size) { auto new_buffer = std::span<std::byte>(new std::byte[mbuffer.size() + size], mbuffer.size() + size); memcpy(new_buffer.data(), mbuffer.data(), mbuffer.size()); delete[] mbuffer.data(); mbuffer = new_buffer; } memcpy(mbuffer.data() + mwrite_offset, data, size); mindex[mwrite_offset] = size; Offset offset = mwrite_offset; mwrite_offset += size; return offset; } Offset write (std::ifstream& in, const size_t size) { in.read((char*)(mbuffer.data() + mwrite_offset), size); mindex[mwrite_offset] = size; Offset offset = mwrite_offset; mwrite_offset += size; return offset; } void read (BytePtr dest, const Offset offset, size_t size) { if (ravailable() < size) { throw std::runtime_error("MemoryBuffer::read: not enough data in the buffer."); } memcpy(dest, mbuffer.data() + offset, size); if (mread_offset == offset) { mread_offset += size; } } void read (BytePtr dest, const Offset offset) { size_t size = mindex[offset]; if (size == 0) { throw std::runtime_error("MemoryBuffer::read: not enough data in the buffer."); } read(dest, offset, size); } void read(BytePtr dest) { read(dest, mread_offset); } void read_known_size(BytePtr dest, const size_t size) { read(dest, mread_offset, size); } template <StdLayoutTriviallyCopyable T> void read(T* t, Offset offset) { read(t, offset, sizeof(T)); } template <HasStdLayoutTriviallyCopyableData T> void read_into_data(T* t, Offset offset) { read(t->data_bytes(), offset, T::DATA_SIZE); } Offset copy (const MemoryBuffer& mb, const Offset offset = 0) { if (wavailable() < mb.size()) { auto new_buffer = std::span<std::byte>(new std::byte[mbuffer.size() + mb.size()], mbuffer.size() + mb.size()); memcpy(new_buffer.data(), mbuffer.data(), mbuffer.size()); delete[] mbuffer.data(); mbuffer = new_buffer; } mindex[mwrite_offset] = mb.size(); memcpy(mbuffer.data() + mwrite_offset, mb.mbuffer.data(), mb.size()); mwrite_offset += mb.size(); return offset; } inline Offset append (const MemoryBuffer& mb) { return copy(mb, mwrite_offset); } inline Offset append(const MemoryBuffer::Ptr& mb) { if (!mb) { throw std::runtime_error("MemoryBuffer::append: null pointer."); } return append(*mb); } inline Offset append(const BytePtr data, const size_t size) { return write(data, size); } inline Offset operator+=(const MemoryBuffer& mb) { return append (mb); } template <HasStdLayoutTriviallyCopyableData T> Offset append(const T& t) { return write(t.data_bytes (), T::DATA_SIZE); } }; template <typename T> concept MemoryBufferPtrConvertible = requires(T t) { { t.bytes() } -> std::convertible_to<MemoryBuffer::Ptr>; }; template <typename T> concept WriteableToMemoryBuffer = Sizeable<T> && MemoryBufferPtrConvertible<T>; template <typename T> concept BinaryConstructible = requires(MemoryBuffer & bytes) { { T(bytes) } -> std::convertible_to<T>; }; template <typename T> concept BinaryIO = MemoryBufferPtrConvertible<T> && BinaryConstructible<T>; template <class T> concept BinaryWriteableObject = MemoryBufferPtrConvertible<T> && Sizeofable<T>; template <typename T> concept BinaryStreamableObject = MemoryBufferPtrConvertible<T> && Streamable<T>; template <typename T, typename Obj> concept ObjectBinaryWriteable = requires(T t, const Obj & object) { { t.template write<Obj>(object) } -> std::convertible_to<void>; }&& BinaryWriteableObject<Obj>; template <typename T, typename Obj, typename... Args> concept FactoryObjectBinaryWriteable = requires(T t, const Obj & object) { { t.template write<Obj, Args...>(object) } -> std::convertible_to<void>; }&& ObjectBinaryWriteable<T, Obj>&& FactoryConstructible<Obj, Args ...>; template <typename T> concept BinaryWriteable = requires(T t, std::span<std::byte>&wbytes) { { t.write(wbytes) } -> std::convertible_to<void>; }; template <typename T> concept BinaryPersistable = BinaryWriteable<T> && BinaryReadable<T>; /* template <class T> class ObjMemoryBuffer { protected: std::span<std::byte> mbuffer; size_t mwrite_offset; size_t mread_offset; std::unordered_map<Id, size_t> mindex; public: ObjMemoryBuffer(size_t initial_size = 1000 * sizeof(T)) : mread_offset(0), mwrite_offset(0) { mbuffer = std::span<std::byte>(new std::byte[initial_size], initial_size); } virtual ~ObjMemoryBuffer() { delete[] mbuffer.data(); } const size_t size() const noexcept { return mbuffer.size(); } const size_t count() const noexcept { return mindex.size(); } const size_t woffset() const noexcept { return mwrite_offset; } const size_t roffset() const noexcept { return mread_offset; } const size_t wavailable() const noexcept { return mbuffer.size() - mwrite_offset; } const size_t ravailable() const noexcept { return mwrite_offset - mread_offset; } void write(const BytePtr data, const size_t size) noexcept { if (wavailable() < size) { auto new_buffer = std::span<std::byte>(new std::byte[mbuffer.size() + size], mbuffer.size() + size); memcpy(new_buffer.data(), mbuffer.data(), mbuffer.size()); delete[] mbuffer.data(); mbuffer = new_buffer; } memcpy(mbuffer.data() + mwrite_offset, data, size); mwrite_offset += size; } void read(BytePtr dest, const size_t offset, size_t size) { if (ravailable() < size) { throw std::runtime_error("MemoryBuffer::read: not enough data in the buffer."); } memcpy(dest, mbuffer.data() + offset, size); if (mread_offset == offset) { mread_offset += size; } } }; */ } } #endif </DOCUMENT>
<DOCUMENT filename="mg.hpp">
 #ifndef MG_H #define MG_H #endif </DOCUMENT>
<DOCUMENT filename="multiplatform.hpp">
#ifndef MULTIPLATFORM_HPP #define MULTIPLATFORM_HPP namespace pensar_digital { namespace cpplib { #if defined(_WIN32) || defined(_WIN64) #define _PLATFORM_FOLDER windows #define _PLATFORM_SUFFIX windows #define _INCLUDE_PATH(base_name) _STRINGIFY(./windows/base_name##_windows.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #elif defined(__linux__) #define _PLATFORM_FOLDER linux #define _PLATFORM_SUFFIX linux #define _INCLUDE_PATH(base_name) _STRINGIFY(./linux/base_name##_linux.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #elif defined(__APPLE__) && defined(TARGET_OS_IPHONE) #define _PLATFORM_FOLDER ios #define _PLATFORM_SUFFIX ios #define _INCLUDE_PATH(base_name) _STRINGIFY(./ios/base_name##_ios.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #elif defined(__ANDROID__) #define _PLATFORM_FOLDER android #define _PLATFORM_SUFFIX android #define _INCLUDE_PATH(base_name) _STRINGIFY(./android/base_name##_android.hpp) #define INCLUDE(base_name) _INCLUDE_PATH(base_name) #else #error "Unsupported platform" #endif #define _STRINGIFY(x) #x } } #endif </DOCUMENT>
<DOCUMENT filename="my_boost.hpp">
#ifndef MY_BOOST_HPP_INCLUDED #define MY_BOOST_HPP_INCLUDED #define CHECK_EQUAL_COLLECTIONS(L, R) \ BOOST_CHECK_EQUAL_COLLECTIONS((L).begin (), (L).end (), (R).begin (), (R).end ()) #include <boost/foreach.hpp> #define foreach BOOST_FOREACH #endif </DOCUMENT>
<DOCUMENT filename="object.hpp">
 #ifndef OBJECT_HPP #define OBJECT_HPP #include "constant.hpp" #include "s.hpp" #include "clone_util.hpp" #include "factory.hpp" #include "log.hpp" #include "string_def.hpp" #include "memory_buffer.hpp" #include "equal.hpp" #include "concept.hpp" #include <sstream> #include <iostream> #include <memory> #include <concepts> #include <string> #include <typeinfo> #include <vector> #include <span> #include <cstddef> #include <bit> #include <cstring> #include <bit> namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; inline static void log_throw(const S& error_msg = W("")) { LOG(error_msg); throw std::runtime_error (error_msg); } template <class T> T& assigns (T& l, const T& r) noexcept { std::memcpy (l.data (), ((T&)r).data (), sizeof(T::DataType)); return l; } template <class T> T& moves (T& l, const T& r) noexcept { std::memmove (l.data (), ((T&)r).data (), sizeof(T::DataType)); return l; } struct ClassInfo { inline static const size_t MAX_IDENTIFIER_SIZE = 100; using Identifier = CS<0, MAX_IDENTIFIER_SIZE>; Identifier mnamespace; Identifier mclass_name; VersionInt mpublic_interface_version; VersionInt mprotected_interface_version; VersionInt mprivate_interface_version; inline static const VersionInt NULL_VERSION = -1; ClassInfo(const S& ns = EMPTY, const S& cn = EMPTY, VersionInt pub_ver = NULL_VERSION, VersionInt pro_ver = NULL_VERSION, VersionInt pri_ver = NULL_VERSION) noexcept : mnamespace (ns), mclass_name (cn), mpublic_interface_version (pub_ver), mprotected_interface_version (pro_ver), mprivate_interface_version (pri_ver) {} inline void write (MemoryBuffer& mb) const noexcept { mb.write((BytePtr)this, sizeof(ClassInfo)); } inline void read (MemoryBuffer& mb) { mb.read_known_size((BytePtr)this, sizeof(ClassInfo)); } MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(sizeof(ClassInfo)); write(*mb); return mb; } inline bool operator==(const ClassInfo& other) const noexcept { return equal<ClassInfo> (*this, other); } inline bool operator!=(const ClassInfo& other) const noexcept { return !(*this == other); } inline void test_class_name_and_version(MemoryBuffer& mb) const { if (mb.size() < sizeof(ClassInfo)) log_throw(W("MemoryBuffer size is smaller than ClassInfo size.")); ClassInfo info; info.read (mb); if (info != *this) log_throw(W("Version mismatch.")); } inline const S to_s () const noexcept { SStream ss; ss << mnamespace << W("::") << mclass_name << W(" v") << mpublic_interface_version << W(".") << mprotected_interface_version << W(".") << mprivate_interface_version; return ss.str(); } inline std::istream& binary_read(std::istream& is, const std::endian& byte_order) { return is.read((char*)(this), sizeof(ClassInfo)); } inline std::ostream& binary_write(std::ostream& os, const std::endian& byte_order) const { return os.write((const char*) this, sizeof(ClassInfo)); } inline void test_class_name_and_version (std:: istream& is, const std::endian& byte_order = std::endian::native) const { ClassInfo info; info.binary_read(is, byte_order); if (info != *this) log_throw(W("Version mismatch.")); } }; static_assert(StdLayoutTriviallyCopyable<ClassInfo>, W("ClassInfo must be a trivially copyable type")); template<typename T> concept HasClassInfo = requires { { T::INFO } -> std::same_as<ClassInfo>; requires std::is_same_v<decltype(T::INFO), const ClassInfo>; }; class Object { public: inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("Object"), 1, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } private: struct Data : public pd::Data { Id mid; Data(const Id& id = NULL_ID) noexcept : mid(id) {} }; static_assert(TriviallyCopyable<Data>, "Data must be a trivially copyable type"); Data mdata; public: using Ptr = std::shared_ptr<Object>; inline const static Data NULL_DATA = { NULL_ID }; using DataType = Data; private: using Factory = pd::Factory<Object, typename Object::DataType>; public: inline virtual pd::Data* get_null_data() const noexcept { return (pd::Data*)(&NULL_DATA); } using FactoryType = Factory; inline const BytePtr object_data_bytes() const noexcept { return (BytePtr)&mdata; } inline const size_t object_data_size() const noexcept { return sizeof(mdata); } virtual const pd::Data* data() const noexcept { return &this->mdata; } virtual const BytePtr data_bytes() const noexcept { return (BytePtr)&this->mdata; } inline static constexpr size_t DATA_SIZE = sizeof(mdata); inline static constexpr size_t SIZE = DATA_SIZE + sizeof(ClassInfo); virtual size_t data_size() const noexcept { return sizeof(this->mdata); } virtual size_t size() const noexcept { return data_size() + sizeof(ClassInfo); } protected: void set_id(const Id& value) { mdata.mid = value; } private: inline static Factory mfactory = { 3, 10, NULL_DATA }; friend class Factory; public: Object(const Data& data = NULL_DATA) noexcept { initialize(data); } Object(const Object& o) { assign(o); } Object(Object&& o) noexcept { assign(o); } Object(MemoryBuffer& mb) { object_assign(mb); } virtual ~Object() {} virtual Object& assign(const Object& o) noexcept { std::memcpy((void*)data(), ((Object&)o).data(), data_size()); return *this; } virtual Object& assign(const Object&& o) noexcept { std::memmove((void*)data(), ((Object&)o).data(), data_size()); return *this; } Object& object_assign(MemoryBuffer& mb) noexcept { INFO.test_class_name_and_version (mb); mb.read_known_size(object_data_bytes(), DATA_SIZE); return *this; } virtual Object& assign(MemoryBuffer& mb) { if (mb.size() < SIZE) log_throw(W("MemoryBuffer size is smaller than Object size.")); return object_assign (mb); } Object& object_assign(const Object& o) noexcept { mdata = o.mdata; return *this; } inline virtual const Object& write(MemoryBuffer& mb) const noexcept { info_ptr ()->write(mb); mb.write((BytePtr)(data ()), data_size ()); return *this; } inline const Object& object_write(MemoryBuffer& mb) const noexcept { INFO.write(mb); mb.write((BytePtr)(&mdata), DATA_SIZE); return *this; } /* inline virtual void bytes_to_vector(ConstBytes& v) const noexcept { VERSION->bytes(v); size_t req_size = v.size() + data_size(); if (v.capacity() < req_size) v.resize(req_size); std::copy_n(reinterpret_cast<const std::byte*>(&mdata), data_size(), v.end() - data_size()); } */ inline MemoryBuffer::Ptr object_bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(SIZE); mb->append((BytePtr)&INFO, sizeof(ClassInfo)); mb->append((BytePtr)(&mdata), DATA_SIZE); return mb; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { return object_bytes (); } inline operator MemoryBuffer::Ptr() const noexcept { return bytes(); } inline virtual ByteSpan data_span() const noexcept { return ByteSpan(data_bytes(), data_size()); } inline virtual std::span<std::byte> wbytes() noexcept { static_assert (sizeof(char) == sizeof(std::byte)); auto byte_span = std::span<std::byte>((std::byte*)(data()), data_size()); return std::as_writable_bytes(byte_span); } inline virtual std::string sclass_name() const { std::string s = typeid(*this).name(); s.erase(0, sizeof("class ") - 1); return s; } inline virtual S class_name() const { std::string s = typeid(*this).name(); s.erase(0, sizeof("class ") - 1); #ifdef WIDE_CHAR return pd::to_wstring(s); #else return s; #endif } inline Object::Ptr clone() const noexcept { return pd::clone<Object>(*this, mdata.mid); } inline virtual Object* get_obj() const noexcept { return ((Object*)(&(*(mfactory.get(NULL_DATA))))); } /*inline virtual Object* clone() const noexcept { Object* o = get_obj(); o->assign(*this); return o; } */ inline virtual bool equals(const Object& o) const noexcept { return equal<Object>(*this, o); } inline virtual const Id id() const noexcept { return mdata.mid; }; inline virtual const Hash hash() const noexcept { return this->id(); }; inline virtual bool initialize(const Data& data) noexcept { mdata = data; return true; } inline std::ostream& bin_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { INFO.binary_write (os, byte_order); os.write((const char*)(&mdata), DATA_SIZE); return os; }; inline bool operator == (const Object& o) const { return equals(o); } inline bool operator != (const Object& o) const { return !equals(o); } inline S to_string() const noexcept { return pd::to_string(mdata.mid); } inline operator S () const noexcept { return to_string(); } inline virtual S debug_string() const noexcept { SStream ss; ss << W("id = ") << Object::to_string(); return ss.str(); } inline Object& operator=(const Object& o) noexcept { return assign(o); } inline Object& operator=(Object&& o) noexcept { return assign(o); } static inline Factory::P get(const Data& data = NULL_DATA) { return mfactory.get(data); }; static inline Factory::P get(const Id& id) { return mfactory.get(Data(id)); }; static inline Factory::P get (MemoryBuffer& mb) { Factory::P o_ptr = get(); Object& o = *o_ptr; o.assign(mb); return o_ptr; }; inline virtual InStream& read(InStream& is) { return is >> mdata.mid; } inline virtual OutStream& write(OutStream& os) const { return os << id(); } inline InStream& operator >> (InStream& is) { return read(is); } inline OutStream& operator << (OutStream& os) { return write(os); } inline std::istream& bin_read(std::istream& is, const std::endian& byte_order = std::endian::native) { INFO.test_class_name_and_version(is, byte_order); is.read((char*)(&mdata), DATA_SIZE); return is; } inline virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { bin_read(is, byte_order); info_ptr ()->test_class_name_and_version (is, byte_order); is.read((char*)data(), data_size()); return is; }; inline virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { bin_write(os, byte_order); info_ptr ()->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; } }; inline InStream& operator >> (InStream& is, Object& o) { return o.read(is); } inline OutStream& operator << (OutStream& os, const Object& o) { return o.write(os); } /* template <typename T> concept CloneableConcept = requires (T t) { { t.clone() } -> std::convertible_to<Object*>; }; */ /* template<typename Container> std::istream& binary_read(Container& c, std::istream& is, const std::endian& byte_order) { size_t size = 0; is.read(reinterpret_cast<char*>(&size), sizeof(size)); if (byte_order != std::endian::native) { size = std::bit_cast<size_t>(std::byteswap<uint64_t>(std::bit_cast<uint64_t>(size))); } c.clear(); auto* as_vector = dynamic_cast<std::vector<Object::Ptr>*>(&c); if (as_vector) { as_vector->reserve(size); } for (size_t i = 0; i < size; ++i) { Object::Ptr obj = Object::get (); obj->binary_read(is, byte_order); c.insert(c.end(), obj); } return is; } template<typename Container> std::ostream& binary_write(const Container& c, std::ostream& os, const std::endian& byte_order) { size_t size = c.size(); if (byte_order != std::endian::native) { size = std::bit_cast<size_t>(byteswap(std::bit_cast<uint64_t>(size))); } os.write(reinterpret_cast<const char*>(&size), sizeof(size)); for (const auto& obj : c) { obj->binary_write(os, byte_order); } return os; } template<typename Container> std::ostream& binary_write(const Container& c, std::ostream& os, const std::endian& byte_order) { size_t size = c.size(); if (byte_order != std::endian::native) { size = std::bit_cast<size_t>(byteswap(std::bit_cast<uint64_t>(size))); } os.write(reinterpret_cast<const char*>(&size), sizeof(size)); for (const auto& obj : c) { obj->binary_write(os, byte_order); } return os; } */ /*template <Versionable MainClass, Versionable RequiredClass> class Dependency { private: Version::Int required_public_interface_version; Version::Int required_protected_interface_version; Version::Int required_private_interface_version; public: Dependency(Version v) noexcept : required_public_interface_version(v.get_public ()), required_protected_interface_version(v.get_protected ()), required_private_interface_version(v.get_private ()) {} virtual ~Dependency() {} virtual bool ok() const noexcept = 0; };*/ } } #endif </DOCUMENT>
<DOCUMENT filename="object_factory.cpp">
 #include "object_factory.hpp" #include <iostream> namespace pensar_digital { namespace cpplib { static ObjectFactory2 objectf; } } </DOCUMENT>
<DOCUMENT filename="object_factory.hpp">
 #ifndef OBJECT_FACTORY_HPP #define OBJECT_FACTORY_HPP #include "factory.hpp" #include "object.hpp" #include "json_util.hpp" #include "type_util.hpp" namespace pensar_digital { namespace cpplib { class ObjectFactory2 : public Factory<Object, Id> { public: inline static const VersionPtr VERSION = pd::versionf.get (1, 1, 1); ObjectFactory2(const Id& aid = NULL_ID) : Factory<Object, Id> (3, 10, aid) { }; virtual ~ObjectFactory2() { }; using P = Factory<Object, Id>::P; virtual P get(const Id& aid = NULL_ID) { return Factory<Object, Id>::get(aid); }; P clone (const Object& aobj) { return get (aobj.get_id()); }; P clone (const ObjectPtr& ptr) { return clone (*ptr); }; P parse_json (const Json& j) { String json_class = j.at("class"); if (json_class != pd::class_name<Object>()) throw std::runtime_error("Invalid class name: " + pd::class_name<Object>()); P ptr = get (j.at("id")); VersionPtr v = versionf.get(j["VERSION"]); if (*(ptr->VERSION) != *v) throw std::runtime_error("ObjectFactory::parse_json: version mismatch."); return ptr; } P parse_json(const String& sjson) { Json j; P ptr = get (pd::get_id<Object>(sjson, &j)); VersionPtr v = versionf.get (j); if (*(ptr->VERSION) != *v) throw std::runtime_error("ObjectFactory::parse_json: version mismatch."); return ptr; } }; extern ObjectFactory2 objectf; } } #endif </DOCUMENT>
<DOCUMENT filename="obj_memory_buffer.hpp">
 #ifndef OBJ_MEMORY_BUFFER_HPP #define OBJ_MEMORY_BUFFER_HPP #include "constant.hpp" #include "s.hpp" #include "bytes_util.hpp" #include "concept.hpp" #include "memory_buffer.hpp" #include <memory> #include <concepts> #include <exception> #include <string> #include <typeinfo> #include <string.h> #include <utility> #include <unordered_map> #include <functional> #include <typeindex> #include <span> namespace pd = pensar_digital::cpplib; namespace pensar_digital { namespace cpplib { template <BinaryIO T> class ObjMemoryBuffer : public MemoryBuffer { public: void add (const T& obj) noexcept { MemoryBuffer::Ptr mb = obj.bytes (); auto offset_it = this->mindex.find(obj.id()); if (offset_it != this->mindex.end()) { this->mwrite_offset = offset_it->second; } this->append (*mb); } template <typename... Args> requires FactoryConstructible<T, Args...> T::Factory::P CreateAndAddObj (Args&&... args) noexcept { typename T::Factory::P p = T::get(std::forward<Args>(args)...); add (*p); return p; } T::Factory::P CreateAndAddObj() noexcept { typename T::Factory::P p = T::get(); T obj = *p; add(obj); return p; } void read_obj (typename T::Factory::P* p) { if (*p != nullptr) { Id id = (*p)->id(); auto offset_it = this->mindex.find(id); if (offset_it != this->mindex.end()) { MemoryBuffer::read((BytePtr)((*p)->data()), offset_it->second + sizeof(Id), (*p)->data_size()); return; } } else { (*p) = T::get(); } Id id = NULL_ID; MemoryBuffer::read((BytePtr)(&id), this->mread_offset, sizeof(Id)); (*p)->set_id(id); MemoryBuffer::read((BytePtr)((*p)->data()), this->mread_offset, sizeof(T)); return; } template <typename... Args> requires FactoryConstructible<T, Args...> typename T::Factory::P read_obj (Args... args) { typename T::Factory::P p = T::get(args ...); read_obj (&p); return p; } typename T::Factory::P read_obj () { typename T::Factory::P p = T::get(); read_obj (&p); return p; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="odb.hpp">
 #ifndef ODB_HPP_INCLUDED #define ODB_HPP_INCLUDED #include "constant.hpp" #include "concept.hpp" #include "string_def.hpp" #include "generator.hpp" #include <memory> #include <type_traits> #include <vector> #include <cassert> namespace pensar_digital { namespace cpplib { namespace db { using namespace pensar_digital::cpplib; template<typename T> concept DBObj = requires(T a) { typename T::Data; { T::Data::mid } -> std::same_as<Id>; { T::Data::mindex } -> std::same_as<Id>; { T::Data::min_use } -> std::same_as<bool>; { T::Data::mchanged } -> std::same_as<bool>; { T::Data::Data(Id(), Id(), bool(), bool()) } noexcept -> std::same_as<typename T::Data>; { a.mdata } -> std::same_as<typename T::Data>; }; template <class T, typename... Args> class NewFactory { public: virtual ~NewFactory() {} virtual T* get(const Args& ... args) const { return new T(args ...); } }; template <class T, typename... Args> class MockupFactory : public NewFactory <T, Args...> { public: MockupFactory(T* mockup_ptr) : mmockup_ptr(mockup_ptr) { }; virtual ~MockupFactory() {} virtual T* get(const Args& ... args) const { return mmockup_ptr; } private: T* mmockup_ptr; }; template <class DBObj, typename... Args> class PoolFactory : public NewFactory <T, Args...> { private: void fill_pool(const size_t& pool_size, const Args& ... args) { for (size_t i = 0; i < pool_size; ++i) { T* ptr = new T(args ...); ptr->mdata.mindex = i; ptr->mdata.min_use = false; ptr->mdata.mchanged = false; if (ptr->mdata.mid == NULL_ID) ptr->mdata.mid = generator.get_id (); pool.push_back(ptr); } available_count = pool_size; } void add(const size_t& count, const Args& ... args) { size_t index = pool.size (); for (size_t i = 0; i < count; ++i) { T* ptr = new T (args ...); ptr->mdata.mindex = index++; ptr->mdata.min_use = false; ptr->mdata.mchanged = false; if (ptr->mdata.mid == NULL_ID) ptr->mdata.mid = generator.get_id (); pool.push_back (ptr); } available_count += count; } public: PoolFactory(const size_t initial_pool_size, const size_t a_refill_size, const Args& ... args) : available_count(0), refill_size(a_refill_size) { generator = new Generator<T>(); fill_pool(initial_pool_size, args ...); }; PoolFactory(const Args& ... args) : PoolFactory(10, 10, args ...) {}; virtual ~PoolFactory() {} virtual T* get(const Args& ... args) { for (size_t i = 0; i < pool.size (); ++i) { auto ptr = pool[i]; if (! ptr->mdata.min_use) { ptr->initialize(args ...); ptr->mdata.min_use = true; ptr->mdata.mchanged = false; available_count--; return ptr; } } assert(available_count <= 0); add(refill_size, args ...); return get(args ...); } size_t get_available_count() const { return available_count; } size_t get_pool_size() const { return pool.size(); } size_t get_refill_size() const { return refill_size; } void set_refill_size(const size_t& value) { refill_size = value; } void reset(const size_t& initial_pool_size, const size_t& a_refill_size, const Args& ... args) { pool.clear(); fill_pool(initial_pool_size, args ...); available_count = initial_pool_size; refill_size = a_refill_size; } private: std::vector<T*> pool; size_t available_count; size_t refill_size; Generator<T> generator; }; template <class T, typename... Args> class SingletonFactory : public NewFactory <T, Args...> { private: using P = NewFactory<T, Args...>::P; public: SingletonFactory(const Args& ... args) : singleton(std::make_shared<T>(args ...)) { }; virtual ~SingletonFactory() {} virtual P get(const Args& ... args) const { return singleton; } private: std::shared_ptr<T> singleton; }; template <class T, typename... Args> class Factory { public: using P = NewFactory<T, Args...>::P; Factory(const size_t pool_size, const size_t refill_size, const Args& ... args) { ptr = std::make_shared<PoolFactory<T, Args...>>(pool_size, refill_size, args ...); }; virtual ~Factory() { } virtual P get(const Args& ... args) { return ptr->get(args ...); } NewFactory<T, Args...>& get_factory() const { return *ptr.get(); } void set_factory(const NewFactory<T, Args...>* afactory) { ptr = afactory; } private: std::shared_ptr<NewFactory<T, Args...>> ptr; }; } } } #endif </DOCUMENT>
<DOCUMENT filename="path.cpp">
 #ifdef CODE_GEAR #pragma hdrstop #endif #include "io_util.hpp" #include "path.hpp" #include <sstream> #include <iostream> #include <fstream> #include <string> namespace pensar_digital { namespace cpplib { } } </DOCUMENT>
<DOCUMENT filename="path.hpp">
 #ifndef PATH_HPP #define PATH_HPP #include "object.hpp" #include "s.hpp" #include "system.hpp" #include "memory.hpp" #include "constant.hpp" #include "version.hpp" #include "concept.hpp" #include "io_util.hpp" #include "clone_util.hpp" #include "error.hpp" #include <string> #include <cstdio> #include <stdlib.h> #include <io.h> #include <windows.h> #include <filesystem> namespace pensar_digital { namespace cpplib { namespace fs = std::filesystem; class Path; typedef std::shared_ptr<Path> PathPtr; typedef Factory<Path, fs::path, Id> PathFactory; class Path : public fs::path, public Object { private: inline static PathFactory mfactory = { 3, 10, W("."), null_value<Id>()}; public: inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); Path(const fs::path& p = W("."), const Id& id = null_value<Id>()) : Object(id), fs::path(p) {} Path(const std::string& s, const Id& id = null_value<Id>()) : Object(id), fs::path(s) {} Path(const char* path, const Id& id = null_value<Id>()) : Object(id), fs::path(path) {} Path(const wchar_t* path, const Id& id = null_value<Id>()) : Object(id), fs::path(path) {} Path(const std::wstring& path, const Id& id = null_value<Id>()) : Object(id), fs::path(path) {} Path(const Path& p, const Id& aid = null_value<Id>()) noexcept : Object(aid), fs::path(p) {} Path(Path&& p, const Id& aid = null_value<Id>()) noexcept : Object(aid), fs::path(p) {} virtual ~Path() noexcept = default; static PathFactory::P get(const fs::path& p = ".", const Id& aid = null_value<Id>()) { return mfactory.get (p, aid); }; PathFactory::P clone(const Path& apath) { return get(apath.std_path(), apath.id()); }; PathFactory::P clone(const PathPtr& ptr) { return clone(*ptr); } static bool is_valid (const S& p) noexcept { return true; } bool is_directory() const noexcept { return fs::is_directory(*this); } bool remove() const noexcept { if (exists()) { if (is_directory ()) return fs::remove_all(*this); else return fs::remove(*this); } return true; } bool exists() const noexcept { return fs::exists(*this); } Path absolute() const noexcept { return fs::absolute(*this); } Path canonical() const noexcept { return fs::canonical(*this); } Path relative() const noexcept { return fs::relative(*this); } Path parent_path() const noexcept { return fs::path::parent_path(); } Path root_path () const noexcept { return fs::path::root_path(); } Path filename() const noexcept { return fs::path::filename(); } Path stem() const noexcept { return fs::path::stem(); } Path filename_only () const noexcept { return stem (); } Path extension() const noexcept { return fs::path::extension(); } Path& replace_extension(const std::string& s) noexcept { fs::path::replace_extension(s); return *this; } Path& replace_extension(const Path& p) noexcept { fs::path::replace_extension(p); return *this; } Path& make_preferred() noexcept { fs::path::make_preferred(); return *this; } Path& remove_filename() noexcept { fs::path::remove_filename(); return *this; } Path& remove_trailing_separator() noexcept { if (! has_filename()) { S s = str (); if (s.back() == Sys::path_separator ()) { s.pop_back(); *this = s; } } return *this; } Path copy_without_trailing_separator() const noexcept { Path p = *this; return p.remove_trailing_separator(); } virtual bool initialize(const fs::path& p, const Id& aid = null_value<Id>()) noexcept { fs::path::operator = (p); Object::set_id(aid); return true; } virtual std::istream& binary_read (std::istream& is, const std::endian& byte_order = std::endian::native) { return is; }; virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); VERSION->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; }; virtual S debug_string() const noexcept { return Object::debug_string() + W(" path = ") + s (); } Path& operator = (Path&& p) noexcept { fs::path::operator = (p); return *this; } Path& operator = (const S & s) { fs::path::operator = (s); return *this; } Path& operator = (const Path& p) { fs::path::operator = (p); return *this; } void create_dir () const noexcept { if (has_filename() && has_parent_path ()) fs::create_directories (parent_path()); else fs::create_directories (*this); } inline size_t size () const noexcept { return s ().size(); } inline fs::path std_path() const noexcept { return static_cast<const fs::path&>(*this); } operator fs::path() const noexcept { return std_path(); } operator std::string() const noexcept { return fs::path::string(); } operator std::wstring() const noexcept { return fs::path::wstring(); } S s () const { #ifdef WIDE_CHAR return fs::path::wstring(); #else return fs::path::string(); #endif } operator const char* () const { return _strdup(fs::path::string().c_str()); } wchar_t * wstr() const { return _wcsdup(fs::path::wstring().c_str()); } char* cstr() const { return _strdup(fs::path::string().c_str()); } C* str() const { #ifdef WIDE_CHAR return wstr(); #else return cstr(); #endif } Path& operator = (const char* s) { fs::path::operator = (s); return *this; } Path& operator /= (const S& s) { fs::path::operator /= (s); return *this; } Path& operator /= (const Path& p) { fs::path::operator /= (p); return *this; } Path operator + (const S& s) const { Path p = *this; p /= s; return p; } bool operator == (const Path& apath) const { return apath.std_path () == this->std_path (); } bool operator != (const std::string& s) const { return !(*this == s); } bool operator == (const char* s) const { return *this == std::string(s); } bool operator != (const char* s) const { return !(*this == s); } inline void set_id(const Id& value) { Object::set_id(value); } using fs::path::value_type; }; inline InStream& operator >> (InStream& is, Path& path) { return path.read(is); } inline OutStream& operator << (OutStream& os, const Path& path) { return path.write(os); } class CPath : public CS<0, MAX_PATH> { public: using P = CS<0, MAX_PATH>; CPath(const P& path = CURRENT_DIR) : P(path) {} inline fs::path to_fspath() const noexcept { return fs::path(P::to_string()); } inline Path to_path() const noexcept { return Path(P::to_string()); } operator fs::path() const noexcept { return to_fspath(); } }; inline CPath path_to_cpath (const Path& path) { return CPath(path.s()); } inline Path cpath_to_path(const CPath& cpath) { return Path (cpath.to_path()); } inline const Path& set_tmp_env_var(const Path& path = fs::temp_directory_path()) { Path p = W("TMP="); p += path; int r = _putenv(p.cstr()); if (r != 0) runtime_error(W("Error setting TMP environment variable.")); return path; } inline static const C* TMP_DIR = W("c:\\tmp\\"); inline static const Path TMP_PATH = set_tmp_env_var (TMP_DIR); } } #endif </DOCUMENT>
<DOCUMENT filename="path_factory.hpp">
 #ifndef PATH_FACTORY_HPP #define PATH_FACTORY_HPP #include "factory.hpp" #include "io_util.hpp" #include "version_factory.hpp" namespace pensar_digital { namespace cpplib { typedef Factory<Path, fs::path, Id> PathFactoryBase; class PathFactory : public PathFactoryBase { public: inline static const VersionPtr VERSION = pd::versionf.get(1, 1, 1); PathFactory(const fs::path& p = ".", const Id& aid = NULL_ID) : PathFactoryBase(3, 10, p, aid) { }; virtual ~PathFactory() { }; using P = PathFactoryBase::P; virtual P get(const fs::path& p = ".", const Id& aid = NULL_ID) { return PathFactoryBase::get(p, aid); }; P clone(const PathRO& apath) { return get(apath.to_std_path (), apath.get_id()); }; P clone(const PathPtr& ptr) { return clone(*ptr); } P parse_json(const String& sjson) { auto j = Json::parse(sjson); String json_class = j.at("class"); if (json_class != pd::class_name<Path>()) throw std::runtime_error("Invalid class name: " + pd::class_name<Path>()); Path p = j; return clone(p); }; }; extern PathFactory pathf; } } #endif </DOCUMENT>
<DOCUMENT filename="pch.cpp">
 </DOCUMENT>
<DOCUMENT filename="person.cpp">
 #include "person.hpp" namespace pensar_digital { namespace contact { } } </DOCUMENT>
<DOCUMENT filename="person.hpp">
 #ifndef PERSON_HPP #define PERSON_HPP #include <string> #include <vector> #include <utility> #include <type_traits> #include <array> #include <unordered_set> #include <cstring> #include "../cpplib/cpp/constant.hpp" #include "../cpplib/cpp/bytes_util.hpp" #include "../cpplib/cpp/concept.hpp" #include "../cpplib/cpp/date.hpp" #include "../cpplib/cpp/object.hpp" #include "../cpplib/cpp/s.hpp" #include "../cpplib/cpp/string_types.hpp" #include "../cpplib/cpp/version.hpp" #include "../cpplib/cpp/s.hpp" #include "../cpplib/cpp/io_util.hpp" #include "../cpplib/cpp/generator.hpp" #include "../cpplib/cpp/type_util.hpp" #include "contact.hpp" #include "phone.hpp" #include "e-mail.hpp" namespace pensar_digital { namespace cpplib { namespace contact { static inline const size_t MAX_FIRST_NAME = 20; static inline const size_t MAX_MIDDLE_NAME = 20; static inline const size_t MAX_LAST_NAME = 20; static inline const size_t MAX_NAME = MAX_FIRST_NAME + MAX_MIDDLE_NAME + MAX_LAST_NAME + 2; class PersonName { public: typedef CS<0, MAX_FIRST_NAME> First; typedef CS<0, MAX_MIDDLE_NAME> Middle; typedef CS<0, MAX_LAST_NAME> Last; First mfirst; Middle mmiddle; Last mlast; constexpr PersonName(const First& f = EMPTY, const Middle& m = EMPTY, const Last& l = EMPTY) : mfirst(f), mmiddle(m), mlast(l) {} const CS<0, MAX_NAME> name() const { S s = mfirst.to_string(); S s2 = mfirst.to_string() + SPACE + mlast.to_string(); S s3 = mlast.to_string(); s += mmiddle.empty() ? s3 : s2; return s; } bool operator==(const PersonName& other) const { return mfirst == other.mfirst && mmiddle == other.mmiddle && mlast == other.mlast; } OutStream& write (OutStream& os) const { os << mfirst << SPACE; if (!mmiddle.empty()) os << mmiddle << SPACE; return os << mlast; } InStream& read (InStream& is) { is >> mfirst; if (is.peek() == SPACE) is.ignore(); if (is.peek() != SPACE) is >> mmiddle; if (is.peek() == SPACE) is.ignore(); return is >> mlast; } }; inline static const PersonName null_person_name() { return { W(""), W(""), W("") }; } inline OutStream& operator<<(OutStream& os, const PersonName& name) { return name.write (os); } inline InStream& operator>>(InStream& is, PersonName& name) { return name.read (is); } class Person : public pd::Object { public: inline static const size_t MAX_PHONE_NUMBERS = 5; inline static const size_t MAX_EMAILS = 5; private: struct Data : public pd::Data { PersonName mname; pd::Date mdate_of_birth; std::array<PhoneNumber, MAX_PHONE_NUMBERS> mphones; size_t phones_count = 0; std::array<Email, MAX_EMAILS> memails; size_t emails_count = 0; Data(const PersonName& name, pd::Date dob = pd::NULL_DATE) : mname(name), mdate_of_birth(dob) {} }; Data mdata; inline static pd::Generator<Person> generator; inline static Factory mfactory = { 1000, 1000, NULL_DATA }; friend class Factory; public: inline const static Data NULL_DATA = { null_person_name(), pd::NULL_DATE }; typedef Data Datatype; typedef pd::Factory<Person, typename Datatype, const pd::Id> Factory; inline static const pd::VersionPtr VERSION = pd::Version::get(1, 1, 1); typedef Factory FactoryType; Data* data() { return &mdata; } virtual const pd::Data* data() const noexcept { return &mdata; } virtual size_t data_size() const noexcept { return sizeof(mdata); } Person(const Data& data = NULL_DATA, const pd::Id id = pd::NULL_ID) : Object(id == pd::NULL_ID ? generator.get_id() : id), mdata(data) { } void add_phone(const PhoneNumber& phone) { if (mdata.phones_count < MAX_PHONE_NUMBERS) { std::memcpy (&mdata.mphones[mdata.phones_count++], &phone, sizeof(phone)); } } void add_email(const Email& email) { if (mdata.emails_count < MAX_EMAILS) { std::memcpy(&mdata.memails[mdata.emails_count++], &email, sizeof(email)); } } virtual bool initialize(const Data& data = NULL_DATA, const pd::Id id = pd::NULL_ID) { bool ok = Object::initialize(id == pd::NULL_ID ? generator.get_id() : id); std::memcpy(&mdata, &data, data_size()); return true; } const PersonName& name() const { return mdata.mname; } virtual std::istream& binary_read (std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read(is, byte_order); read_bin_version(is, *VERSION, byte_order); is.read((char*)data(), data_size()); return is; }; virtual std::ostream& binary_write (std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write(os, byte_order); VERSION->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; }; /*static inline Factory::P get(T aid = null_value<T>(), T initial_value = 0, T step = 1) noexcept { return mfactory.get(aid, initial_value, step); }; Factory::P clone() { return get(get_id(), mdata.minitial_value, mdata.mstep); }; */ protected: bool _equals(const Object& other) const noexcept override { const Person* pother = dynamic_cast<const Person*>(&other); if (pother == nullptr) return false; return (std::memcmp(&mdata, &pother->mdata, sizeof(mdata)) == 0); } inline virtual InStream& read(InStream& is) { Object::read(is); return is >> mdata.mname; } inline virtual OutStream& write(OutStream& os) const { Object::write(os); return os << mdata.mname; } friend InStream& operator >> (InStream& is, Person& p); friend OutStream& operator << (OutStream& os, const Person& p); }; inline InStream& operator >> (InStream& is, Person& p) { return p.read (is); } inline OutStream& operator << (OutStream& os, const Person& p) { return p.write (os); } } } } #endif </DOCUMENT>
<DOCUMENT filename="phone.hpp">
 #ifndef PHONE_HPP #define PHONE_HPP #include "../cpplib/cpp/s.hpp" #include "contact.hpp" #include <sstream> namespace pensar_digital { namespace cpplib { namespace contact { namespace pd = pensar_digital::cpplib; struct PhoneNumber : public Contact { typedef CS<0, 3> CountryCode; typedef CS<0, 4> AreaCode; typedef CS<0, 10> Number; CountryCode mcountry_code; AreaCode mareacode; Number mnumber; ContactQualifier mqualifier; PhoneNumber(const CountryCode& cc = EMPTY, const AreaCode& ac = EMPTY, const Number& n = EMPTY, ContactQualifier cq = ContactQualifier::Business) : mcountry_code(cc), mareacode(ac), mnumber(n), mqualifier(cq) {} inline bool equal_country_code(const PhoneNumber& other) const noexcept { return mcountry_code == other.mcountry_code; } inline bool equal_area_code(const PhoneNumber& other) const noexcept { return mareacode == other.mareacode; } inline bool equal_number(const PhoneNumber& other) const noexcept { return mnumber == other.mnumber; } inline bool operator==(const PhoneNumber& other) const noexcept { return equal_country_code(other) && equal_area_code(other) && equal_number(other); } inline bool operator!=(const PhoneNumber& other) const noexcept { return !(*this == other); } }; } } } #endif </DOCUMENT>
<DOCUMENT filename="pobject.cpp">
 #include "pobject.hpp" #include "io_util.hpp" namespace pd = pensar_digital::cpplib; /*/namespace nlohmann { template <> struct adl_serializer<pd::PObject> { pd::PObject from_json (const pd::Json& j) { pd::S class_name = pd::class_name<pd::PObject> (); pd::S json_class = j.at("class"); if (class_name == json_class) { return *pd::PObject::get.get (j.at("id")); } else throw new std::runtime_error("PObject expected class = " + class_name + " but json has " + json_class); } }; } */ namespace pensar_digital { namespace cpplib { PObject& PObject::from_json(const S& sjson) { VersionPtr v; Id aid; Json j; pd::read_json<PObject>(sjson, *this, &aid, &v, &j); mdata.mid = aid; if (*VERSION != *v) throw std::runtime_error("Factory::parse_json: version mismatch."); return *this; } void PObject::read_bin_obj(std::istream& is, const std::endian& byte_order) { S sclass_name; binary_read(is, sclass_name, byte_order); if (sclass_name != class_name()) throw new std::runtime_error("PObject::read: class name mismatch."); binary_read<Id>(is, mdata.mid, byte_order); } void PObject::read_bin_version(std::istream& is, const std::endian& byte_order) { Version v; v.read(is, BINARY, byte_order); if (*VERSION != v) throw new std::runtime_error("Version mismatch."); } std::istream& PObject::read(std::istream& is, const IO_Mode amode, const std::endian& byte_order) { if (amode == BINARY) { read_bin_obj(is, byte_order); read_bin_version(is, byte_order); } else { S stream_class_name; VersionPtr stream_version; Id stream_id; Json j; pd::read_json<PObject>(is, *this, &stream_id, &stream_version, &j); mdata.mid = stream_id; if (*VERSION != *stream_version) throw new std::runtime_error("PObject::read: version mismatch."); } return is; }; std::ostream& PObject::write(std::ostream& os, const IO_Mode amode, const std::endian& byte_order) const { if (amode == BINARY) { binary_write(os, class_name(), byte_order); binary_write<Id>(os, mdata.mid, byte_order); VERSION->write(os, amode, byte_order); } else { os << json(); } return os; }; void to_json(Json& j, const PObject& o) { j["class"] = o.class_name(); j["id"] = o.id(); to_json(j, *o.VERSION); }; void from_json(const Json& j, PObject& o) { S class_name = o.class_name(); S json_class = j.at("class"); if (class_name == json_class) o.set_id(j.at("id")); else throw new std::runtime_error("PObject expected class = " + class_name + " but json has " + json_class); } } } </DOCUMENT>
<DOCUMENT filename="pobject.hpp">
 #ifndef OBJECT_HPP #define OBJECT_HPP #include "constant.hpp" #include "concept.hpp" #include "string_util.hpp" #include "header_lib/xmlParser.h" #include "clone_util.hpp" #include "version.hpp" #include "json_util.hpp" #include "factory.hpp" #include <fstream> #include <sstream> #include <iostream> #include <memory> #include <concepts> #include <exception> #include <string> #include <typeinfo> #include <string.h> #include <utility> #include <vector> namespace pensar_digital { namespace cpplib { namespace pd = pensar_digital::cpplib; class PObject; typedef std::shared_ptr<PObject> PObjectPtr; class PObject { public: typedef pd::Factory<PObject, Id> Factory; private: inline static Factory mfactory = { 3, 10, NULL_ID }; struct Data { Id mid; Id mindex; bool min_use; bool mchanged; Data(const Id& id = NULL_ID, bool in_use = false, bool changed = false) noexcept : mid(id), mindex(NULL_ID), min_use(in_use), mchanged(changed) {} }; Data mdata; protected: void set_id(const Id& value) { mdata.mchanged = (value != mdata.mid); mdata.mid = value; } S ObjXMLPrefix() const noexcept { return "<object class_name = \"" + class_name() + "\" id = \"" + PObject::to_string() + "\""; } virtual bool _equals(const PObject& o) const { return (mdata.mid == o.mdata.mid); } void set_changed() noexcept { mdata.mchanged = true; } public: inline static const VersionPtr VERSION = pd::Version::get(1, 1, 1); typedef Factory FactoryType; typedef Data DataType; PObject(const Id& id = NULL_ID, const IO_Mode mode = BINARY) noexcept : mdata(id) { }; PObject(const PObject& o) { assign(o); } PObject(PObject&& o) noexcept { assign(o); } virtual ~PObject() {} Data* data() noexcept { return &mdata; } PObject& assign(const PObject& o) noexcept { mdata.mid = o.mdata.mid; return *this; } inline virtual void bytes(std::vector<std::byte> v) const noexcept { VERSION->bytes(v); } virtual std::span<std::byte> wbytes() noexcept { return std::as_writable_bytes(std::span{ this, this + sizeof(*this) }); } virtual std::string class_name() const { S c = typeid(*this).name(); c.erase(0, sizeof("class ") - 1); return c; } virtual bool changed() const noexcept { return mdata.mchanged; } PObjectPtr clone() const noexcept { return pd::clone<PObject>(*this, mdata.mid); } bool equals(const PObject& o) const noexcept { if (get_hash() != o.get_hash()) return false; return _equals(o); } virtual const Id id() const noexcept { return mdata.mid; }; virtual const Id index() const noexcept { return mdata.mindex; } virtual const bool in_use() const noexcept { return mdata.min_use; } virtual const Hash get_hash() const noexcept { return mdata.mid; }; virtual bool initialize(const Id& id = NULL_ID) noexcept { mdata.mid = id; return true; } inline virtual S json() const noexcept { return pd::json<PObject>(*this) + " }"; } virtual void read_bin_obj(std::istream& is, const std::endian& byte_order = std::endian::native); void read_bin_version(std::istream& is, const std::endian& byte_order = std::endian::native); virtual std::istream& read(std::istream& is, const IO_Mode amode = BINARY, const std::endian& byte_order = std::endian::native); virtual std::ostream& write(std::ostream& os, const IO_Mode amode = BINARY, const std::endian& byte_order = std::endian::native) const; virtual S xml() const noexcept { return ObjXMLPrefix() + "/>"; } XMLNode parse_object_tag(const pensar_digital::cpplib::S& sxml) { const char* xml = sxml.c_str(); XMLCSTR tag = "object"; XMLResults* pResults = 0; XMLNode node = XMLNode::parseString(xml, tag, pResults); S xml_class_name = node.getAttribute("class_name"); if (xml_class_name == class_name()) { S sid = node.getAttribute("id"); mdata.mid = std::stoi(sid); } else throw std::runtime_error("Invalid class name"); return node; } virtual void from_xml(const S& sxml) { parse_object_tag(sxml); } bool operator == (const PObject& o) const { return equals(o); } bool operator != (const PObject& o) const { return !equals(o); } PObject& from_json(const S& sjson); virtual S to_string() const noexcept { return std::to_string(mdata.mid); } operator S () const noexcept { return to_string(); } virtual S debug_string() const noexcept { std::stringstream ss; ss << "id = " << to_string(); return ss.str(); } PObject& operator=(const PObject& o) noexcept { return assign(o); } PObject& operator=(PObject&& o) noexcept { return assign(o); } friend void from_json(const Json& j, PObject& o); static inline Factory::P get(const Id& aid = NULL_ID) { return mfactory.get(aid); }; Factory::P clone() { return get(mdata.mid); }; inline static Factory::P get(const Json& j) { S json_class = j.at("class"); if (json_class != pd::class_name<PObject, char>()) throw std::runtime_error("Invalid class name: " + pd::class_name<PObject, char>()); Factory::P ptr = get(j.at("id")); VersionPtr v = Version::get(j["VERSION"]); if (*(ptr->VERSION) != *v) throw std::runtime_error("Factory::parse_json: version mismatch."); return ptr; } inline static Factory::P get(const S& sjson) { Json j; Factory::P ptr = get(pd::id<PObject>(sjson, &j)); VersionPtr v = Version::get(j); if (*(ptr->VERSION) != *v) throw std::runtime_error("Factory::parse_json: version mismatch."); return ptr; } }; extern void to_json(Json& j, const PObject& o); extern void from_json(const Json& j, PObject& o); inline std::istream& operator >> (std::istream& is, PObject& o) { return o.read(is, TEXT); } inline std::ostream& operator << (std::ostream& os, const PObject& o) { return o.write(os, TEXT); } inline PObject& operator >> (const S& sjson, PObject& o) { return o.from_json(sjson); } inline std::istream& operator >> (std::istream& is, PObjectPtr o) { return is >> *o; } inline std::ostream& operator << (std::ostream& os, const PObjectPtr o) { return os << *o; } static_assert (std::is_move_constructible_v <PObject>); static_assert (std::is_move_assignable_v <PObject>); } } #endif </DOCUMENT>
<DOCUMENT filename="posix_util.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #ifdef CODE_GEAR #pragma hdrstop #endif #include "posix_util.h" #ifdef CODE_GEAR #pragma package(smart_init) #endif #include "posix_util.h" #include <iostream> #include <fstream> #include <time.h> #include <stdlib.h> #include <sys/types.h> #include <sys/stat.h> #if !defined(__BORLANDC__) && !defined(_MSC_VER) #include <unistd.h> #endif #ifdef WINDOWS #include <windows.h> #endif using namespace std; namespace POSIX { void TimeT_To_FILETIME(time_t t, ALT_FILETIME *pft ) { uint64_t ll = (((uint64_t)t) *10000000L) + (((uint64_t)116444736L) * 1000000000L); pft->dwLowDateTime = (uint32_t)(ll & 0xFFFFFFFF); pft->dwHighDateTime = (uint32_t)((ll>>32)&0xFFFFFFFF); } bool operator < (const ALT_FILETIME& left, const ALT_FILETIME& right) { bool less = left.dwHighDateTime < right.dwHighDateTime; if (! less) if (left.dwHighDateTime == right.dwHighDateTime) less = left.dwLowDateTime < right.dwLowDateTime; return less; } #ifdef __WIN32__ #ifdef UNICODE ALT_FILETIME getFileTime(LPCWSTR sFileName) { FILETIME temp; GetSystemTimeAsFileTime(&temp); HANDLE h = CreateFile(sFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); if (h == INVALID_HANDLE_VALUE) { cerr << "Cannot read file time of " << sFileName << "\n"; } else { GetFileTime(h, NULL, NULL, &temp); CloseHandle(h); } ALT_FILETIME result; result.dwHighDateTime = temp.dwHighDateTime; result.dwLowDateTime = temp.dwLowDateTime; return result; } #else ALT_FILETIME getFileTime(const char* sFileName) { struct stat buf; time_t currentTime = time(NULL); if(stat(sFileName, &buf)) { cerr << "Cannot read file time of " << sFileName << "\n"; } else { currentTime = buf.st_mtime; } ALT_FILETIME result; TimeT_To_FILETIME(currentTime, &result); return result; } #endif #endif uint32_t getFileSize(const char* sFileName) { std::ifstream f; f.open(sFileName, std::ios_base::binary | std::ios_base::in); if (!f.good() || f.eof() || !f.is_open()) { throw "File could not be read (getFileSize)"; } f.seekg(0, std::ios_base::beg); std::ifstream::pos_type begin_pos = f.tellg(); f.seekg(0, std::ios_base::end); return static_cast<int>(f.tellg() - begin_pos); } #ifdef __WIN32__ #ifdef UNICODE wstring getTempFile() { wchar_t buffer[MAX_PATH]; if(GetTempFileName(L".",L"vpatch",0,buffer) == 0) { cerr << "Cannot create temporary filename"; } return wstring(buffer); } #endif #else string getTempFile() { char t[] = "/tmp/genpatXXXXXX"; mode_t old_umask = umask(0077); int fd = mkstemp(t); if (fd == -1) { cerr << "Cannot create temporary filename"; return ""; } close(fd); umask(old_umask); return string(t); } #endif } </DOCUMENT>
<DOCUMENT filename="random_util.cpp">
 #include "random_util.hpp" namespace pensar_digital { namespace cpplib { DefaultRandomGeneratorType seed () { return std::chrono::system_clock::now().time_since_epoch().count(); } RandGen get_generator () { static RandGen random_generator (seed ()) ; return random_generator; } } } </DOCUMENT>
<DOCUMENT filename="random_util.hpp">
#ifndef RANDOM_UTIL_HPP_INCLUDED #define RANDOM_UTIL_HPP_INCLUDED #include <chrono> #include <random> #include <cstdlib> namespace pensar_digital { namespace cpplib { using DefaultRandomGeneratorType = unsigned long long int; inline DefaultRandomGeneratorType seed() { return std::chrono::system_clock::now().time_since_epoch().count(); } template <typename T = DefaultRandomGeneratorType> class CustomRandomGenerator { public: using result_type = T; #undef min CustomRandomGenerator(result_type seed) : m_engine(seed), m_dist(std::numeric_limits<result_type>::min(), std::numeric_limits<result_type>::max()) {} static constexpr result_type min() { return std::numeric_limits<result_type>::min(); } static constexpr result_type max() { return std::numeric_limits<result_type>::max(); } result_type operator()() { return m_dist(m_engine); } private: std::mt19937_64 m_engine; std::uniform_int_distribution<result_type> m_dist; }; using RandGen = CustomRandomGenerator<>; template <typename T = DefaultRandomGeneratorType, class Distribution = std::uniform_int_distribution<T>, class RandomGenerator = RandGen> class Random { public: Random(const T min_value, const T max_value) : mmin(min_value), mmax(max_value), mseed(seed()), mdistribution(min_value, max_value), mgenerator(mseed) {} T operator()() { return mdistribution(mgenerator); } private: Distribution mdistribution; RandomGenerator mgenerator; DefaultRandomGeneratorType mseed; T mmin; T mmax; }; class CRandom { public: CRandom (int min_value, int max_value): _min(min_value), _max(max_value) { srand ((unsigned int) seed()); } inline int get () const { return rand () % (_max - _min + 1) + _min;} inline int get_min () const { return _min; } inline int get_max () const { return _max; } inline void set_min (const int min_value) { _min = min_value; } inline void set_max (const int max_value) { _max = max_value; } private: int _min; int _max; }; inline RandGen get_generator() { static RandGen random_generator(seed()) ; return random_generator; } inline RandGen random_generator = get_generator (); } } #endif </DOCUMENT>
<DOCUMENT filename="ro_object.hpp">
#ifndef RO_OBJECT_HPP #define RO_OBJECT_HPP #include <cstdint> namespace pensar_digital { namespace cpplib { class RO_Object { public: using IdType = int64_t; using HashType = int64_t; using VersionType = int16_t; const static VersionType VERSION = 1; const static VersionType INTERFACE_VERSION = 1; const static IdType NULL_ID = 0; const bool equals (const RO_Object& o) const {return id == o.id;} /** Access object id * \return The current value of id */ virtual const IdType get_id() const {return id;}; /** Access hash * \return The current value of hash */ virtual const HashType get_hash() const {return id;}; virtual const VersionType get_version () const { return VERSION ; }; virtual const VersionType get_interface_version () const { return INTERFACE_VERSION; }; bool operator == (const RO_Object& o) const {return equals (o);} bool operator != (const RO_Object& o) const {return ! equals (o);} protected: RO_Object () {}; IdType id; }; } } #endif </DOCUMENT>
<DOCUMENT filename="s.hpp">
 #ifndef S_HPP #define S_HPP #include "constant.hpp" #include "string_def.hpp" #include "concept.hpp" #include "icu_util.hpp" #include <array> #include <algorithm> #include <sstream> #include <fstream> #include <iostream> #include <iomanip> namespace pensar_digital { namespace cpplib { inline void runtime_error(const S& message) { #ifdef WIDE_CHAR throw std::runtime_error(to_string(message)); #else throw std::runtime_error(message); #endif } inline static constexpr S sfile () { #ifdef WIDE_CHAR return __FILEW__; #else return __FILE__; #endif } inline S& read_all(InStream& is, S& s) { C c; while (is.get(c)) s += c; return s; } static inline S& rtrim(S& s) { #ifdef WIDE_CHAR s.erase(std::find_if_not(s.rbegin(), s.rend(), [](wchar_t c) {return iswspace(c); }).base(), s.end()); #else s.erase(std::find_if_not(s.rbegin(), s.rend(), [](unsigned char c) {return iswspace(c); }).base(), s.end()); #endif return s; } static inline S& ltrim(S& s) { #ifdef WIDE_CHAR s.erase(s.begin(), std::find_if_not(s.begin(), s.end(), [](wchar_t c) {return iswspace(c); })); #else s.erase(s.begin(), std::find_if_not(s.begin(), s.end(), [](unsigned char c) {return iswspace(c); })); #endif return s; } static inline void trim(S& s) { ltrim(rtrim(s)); } static inline S trim(const S& s) { S t = s; return ltrim(rtrim(t)); } typedef std::unique_ptr<std::vector<S>> SVectorPtr; template<typename Container = std::vector<S>> inline void split(const S& s, C ch, Container& c, bool trim_elements = true, bool include_empty_fields = false) { size_t i = 0; size_t j = s.find(ch); if (j == S::npos) c.insert(c.end(), s); else while (j != S::npos) { S aux = s.substr(i, j - i); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) c.insert(c.end(), aux); i = ++j; j = s.find(ch, j); if (j == S::npos) { aux = s.substr(i, s.length()); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) c.insert(c.end(), aux); } } } /*void split(const S& s, C c, std::vector<S>& v, bool trim_elements = true, bool include_empty_fields = false) { size_t i = 0; size_t j = s.find(c); if (j == S::npos) v.push_back(s); else while (j != S::npos) { S aux = s.substr(i, j - i); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) v.push_back(aux); i = ++j; j = s.find(c, j); if (j == S::npos) { aux = s.substr(i, s.length()); if (trim_elements) trim(aux); if (include_empty_fields || aux.length() > 0) v.push_back(aux); } } }*/ /* template<typename CharType> std::auto_ptr<std::vector<std::basic_string<CharType> > > split (const std::basic_string<CharType>& s, CharType c, bool trim_elements = true) { std::vector<std::basic_string<CharType> > *vp = new std::vector<std::basic_string<CharType> > (); split<CharType> (s, c, *vp, trim_elements); return std::auto_ptr<std::vector<std::basic_string<CharType> > > (vp); } */ /*inline void split(S& s, C c, std::vector<S>& v, bool trim_elements = true) { split(s, c, v, trim_elements); }*/ /* inline std::auto_ptr<std::vector<std::string> > split (const std::string& s, char c, bool trim_elements = true) { return split<char> (s, c, trim_elements); } */ #ifdef CODE_GEAR #endif inline void pad(S& s, const C c, const typename S::size_type n, bool where = PAD_RIGHT) { if (n == 0) return; assert(static_cast<int>(n) > 0); const typename S::size_type length = s.length(); if (where == PAD_RIGHT) { if (n > length) s.append(n - length, c); } else { if (n > length) s.insert(0, n - length, c); } } inline S pad_copy (const S& s, const C c, const typename S::size_type n, bool where = PAD_RIGHT) { S aux(s); pad(aux, c, n, where); return aux; } inline S pad_copy(const C* s, const C c, const unsigned n, bool where = PAD_RIGHT) { assert(s != 0); S aux = s; pad(aux, c, n, where); return aux; } inline S only_digits(const S& s) { S out; for (const auto& ch : s) { if (isdigit(ch)) out += ch; } return out; } inline S only_alpha_numeric(const S& s) { S out; for (const C& ch : s) { if (isalnum(ch)) out += ch; } return out; } inline void troca_char(C* c, const std::locale& loc = std::locale(W(""))) { switch (*c) { case W('á'): case W('à'): case W('ã'): case W('ä'): case W('â'): *c = W('a'); break; case W('é'): case W('è'): case W('ë'): case W('ê'): *c = W('e'); break; case W('í'): case W('ì'): case W('ï'): case W('î'): *c = W('i'); break; case W('ó'): case W('ò'): case W('õ'): case W('ö'): case W('ô'): *c = W('o'); break; case W('ú'): case W('ù'): case W('ü'): case W('û'): *c = W('u'); break; case W('ç'): *c = W('c'); break; case W('Á'): case W('À'): case W('Ã'): case W('Ä'): case W('Â'): *c = W('A'); break; case W('É'): case W('È'): case W('Ë'): case W('Ê'): *c = W('E'); break; case W('Í'): case W('Ì'): case W('Ï'): case W('Î'): *c = W('I'); break; case W('Ó'): case W('Ò'): case W('Õ'): case W('Ö'): case W('Ô'): *c = W('O'); break; case W('Ú'): case W('Ù'): case W('Ü'): case W('Û'): *c = W('U'); break; case W('Ç'): *c = W('C'); break; default: break; } } inline void remove_accents(S& s) { for (C& ch : s) { troca_char(&ch); } } inline S no_accents(const S& s) { S r = s; remove_accents(r); return r; } template <class CharT = char> inline bool is_space(CharT c) { return std::isspace<CharT>(c, std::locale()); } template<typename T = char> inline void remove_blanks(S& s) { s.erase(std::remove_if(s.begin(), s.end(), is_space<T>), s.end()); } template<typename T = char> inline S copy_remove_accents(S s) { S s2 = s; remove_accents(s2); return s2; } template<typename T = char> inline void remove(const S& s, S& target) { typename S::size_type pos = target.find(s); while (pos != S::npos) { target.erase(pos, s.length()); pos = target.find(s); } } template<typename T = char> inline void remove_delimiters(T delimiter, S& s) { if (s[0] == delimiter && s[s.length() - 1] == delimiter) { s.erase(0, sizeof(T)); s.erase(s.length() - 1, sizeof(T)); } } template<typename T = char> inline S copy_remove(const S& s, S target) { remove(s, target); return target; } template<typename C = char> inline void remove_substr(S& s, const S& p) { std::string::size_type n = p.length(); for (std::string::size_type i = s.find(p); i != std::string::npos; i = s.find(p)) s.erase(i, n); } inline bool replace_substr(S& s, const S& o, const S& r) { if (s.size() == 0) return false; bool replaced = false; S::size_type n = o.length(); for (S::size_type i = s.find(o); i != S::npos; i = s.find(o)) { s.replace(i, n, r); replaced = true; } return replaced; } inline bool replace_substr (S& s, const C* o, const C* r) { return replace_substr (s, S(o), S(r)); } inline S insert_grouping_char (const S& s, typename S::value_type grouping_char = W(',')) { S f; unsigned primeiro = s.length() % 3; if (primeiro == 0) primeiro = 3; --primeiro; unsigned i = 0; unsigned count = 0; for (typename S::const_iterator it = s.begin(); it != s.end(); ++it) { f += *it; bool last = (++it == s.end()) ? true : false; --it; if ((i++ == primeiro || ++count == 3) && !last) { f += grouping_char; count = 0; } } return f; } inline std::wstring to_wstring(const std::string& s) { return pensar_digital::cpplib::icu::to_wstring(s); } template<typename IntType = int, bool use_grouping_char = false> S to_string(IntType number, C grouping_char = W(',')) { OutStringStream ss; ss << number; S s = ss.str(); if (number < 0) s.insert(s.begin(), W('-')); return use_grouping_char ? insert_grouping_char(s, grouping_char) : s; } template<bool use_grouping_char = false> S to_string(size_t number, typename C grouping_char = W(',')) { return to_string <size_t, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(int number, C grouping_char = W(',')) { return to_string <int, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(long number, C grouping_char = W(',')) { return to_string <long, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(long long int number, C grouping_char = W(',')) { return to_string <long long int, use_grouping_char>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(unsigned int number, C grouping_char = W(',')) { return to_string <unsigned int, use_grouping_char, C>(number, grouping_char); } template<bool use_grouping_char = false> S to_string(unsigned long int number, C grouping_char = W(',')) { return to_string <unsigned long int, use_grouping_char>(number, grouping_char); } inline S to_string(double number, unsigned num_decimals , bool use_grouping, C grouping_char = W(','), C decimal_separator = W(',')) { long long int integer_part = (long long)trunc(number); S s = to_string(integer_part); SStream ss; ss << std::fixed << std::setprecision(num_decimals) << number; S s1 = ss.str(); typename S::size_type pos = s1.find(decimal_separator); S decimal_part = W(".00"); if (pos != S::npos) { size_t n = (num_decimals + pos) < s1.length() ? num_decimals : s1.length(); decimal_part = s1.substr(pos, n + 1); } pad(decimal_part, W('0'), num_decimals); return s + decimal_part; } inline std::string to_string(const std::wstring& s) { #ifdef WINDOWS return icu::utf16_to_utf8(s); #else return icu::utf32_to_utf8(s); #endif } inline S pad_left0(long long int number, const unsigned n = 4) { return pad_copy(pd::to_string<decltype(number), false>(number).c_str(), W('0'), n, PAD_LEFT); } inline void remove_ext(S& fname) { typename S::size_type pos = fname.find_last_of(W('.')); if (pos != S::npos) { fname.erase(pos, fname.length()); } } inline S& remove_double_spaces(S& s) { if (s.size() == 0) return s; while (replace_substr (s, W(" "), W(" "))); return s; } inline S reverse(const S& s) { S out; for (typename S::const_reverse_iterator i = s.crbegin(); i != s.crend(); ++i) { out += *i; } return out; } inline void to_upper(S& s) { for (S::iterator p = s.begin(); p != s.end(); ++p) { if (*p >= W('a') && *p <= W('z')) *p = W('A') + (*p - W('a')); else { switch (*p) { case W('á'): *p = W('Á'); break; case W('à'): *p = W('À'); break; case W('ã'): *p = W('Ã'); break; case W('ä'): *p = W('Ä'); break; case W('â'): *p = W('Â'); break; case W('é'): *p = W('É'); break; case W('è'): *p = W('È'); break; case W('ë'): *p = W('Ë'); break; case W('ê'): *p = W('Ê'); break; case W('í'): *p = W('Í'); break; case W('ì'): *p = W('Ì'); break; case W('ï'): *p = W('Ï'); break; case W('î'): *p = W('Î'); break; case W('ó'): *p = W('Ó'); break; case W('ò'): *p = W('Ò'); break; case W('õ'): *p = W('Õ'); break; case W('ö'): *p = W('Ö'); break; case W('ô'): *p = W('Ô'); break; case W('ú'): *p = W('Ú'); break; case W('ù'): *p = W('Ù'); break; case W('ü'): *p = W('Ü'); break; case W('û'): *p = W('Û'); break; case W('Ç'): *p = W('ç'); break; case W('Ñ'): *p = W('ñ'); break; default: break; } } } }; inline void to_lower(S& s) { for (S::iterator p = s.begin(); p != s.end(); ++p) { if (*p >= W('A') && *p <= W('Z')) *p = W('a') + (*p - W('A')); else { switch (*p) { case W('Á'): *p = W('á'); break; case W('À'): *p = W('à'); break; case W('Ã'): *p = W('ã'); break; case W('Ä'): *p = W('ä'); break; case W('Â'): *p = W('â'); break; case W('É'): *p = W('é'); break; case W('È'): *p = W('è'); break; case W('Ë'): *p = W('ë'); break; case W('Ê'): *p = W('ê'); break; case W('Í'): *p = W('í'); break; case W('Ì'): *p = W('ì'); break; case W('Ï'): *p = W('ï'); break; case W('Î'): *p = W('î'); break; case W('Ó'): *p = W('ó'); break; case W('Ò'): *p = W('ò'); break; case W('Õ'): *p = W('õ'); break; case W('Ö'): *p = W('ö'); break; case W('Ô'): *p = W('ô'); break; case W('Ú'): *p = W('ú'); break; case W('Ù'): *p = W('ù'); break; case W('Ü'): *p = W('ü'); break; case W('Û'): *p = W('û'); break; case W('Ç'): *p = W('ç'); break; case W('Ñ'): *p = W('ñ'); break; default: break; } } } }; inline S upper(const S& s) { S r = s; to_upper(r); return r; } inline S lower(const S& s) { S r = s; to_lower(r); return r; } /*void troca_char(wchar_t* c, const std::locale& loc) { switch (*c) { case L'\u00C0'): case L'\u00C1'): case L'\u00C2'): case L'\u00C3'): case L'\u00C4'): case L'\u00C5'): *c = L'A'); break; case L'\u00C8'): case L'\u00C9'): case L'\u00CA'): case L'\u00CB'): *c = L'E'); break; case L'\u00CC'): case L'\u00CD'): case L'\u00CE'): case L'\u00CF'): *c = L'I'); break; case L'\u00D2'): case L'\u00D3'): case L'\u00D4'): case L'\u00D5'): case L'\u00D6'): *c = L'O'); break; case L'\u00D9'): case L'\u00DA'): case L'\u00DB'): case L'\u00DC'): *c = L'U'); break; case L'\u00C7'): *c = L'C'); break; case L'\u00D1'): *c = L'N'); break; case L'\u00E0'): case L'\u00E1'): case L'\u00E2'): case L'\u00E3'): case L'\u00E4'): *c = L'a'); break; case L'\u00E8'): case L'\u00E9'): case L'\u00EA'): case L'\u00EB'): *c = L'e'); break; case L'\u00EC'): case L'\u00ED'): case L'\u00EE'): case L'\u00EF'): *c = L'i'); break; case L'\u00F2'): case L'\u00F3'): case L'\u00F4'): case L'\u00F5'): case L'\u00F6'): *c = L'o'); break; case L'\u00E7'): *c = L'c'); break; case L'\u00F1'): *c = L'n'); break; case L'\u00F9'): case L'\u00FA'): case L'\u00FB'): case L'\u00FC'): *c = L'u'); break; default: break; } } */ #ifdef CODE_GEAR /*void __fastcall split(const AnsiString& as, char c, std::vector<AnsiString>* v, bool trim_elements) { S s = as.c_str(); S::size_type i = 0; S::size_type j = s.find(c); if (j == S::npos) v->push_back(as); else while (j != S::npos) { S aux = s.substr(i, j - i); if (trim_elements) trim(aux); AnsiString s1 = aux.c_str(); v->push_back(s1); i = ++j; j = s.find(c, j); if (j == S::npos) { aux = s.substr(i, s.length()); if (trim_elements) trim(aux); s1 = aux.c_str(); v->push_back(s1); } } } AnsiString __fastcall only_digits(const AnsiString& s) { AnsiString d = ""; for (int i = 1; i <= s.Length(); i++) { if (isdigit(s[i])) d += s[i]; } return d; } AnsiString __fastcall remove_acentos(const AnsiString& s) { AnsiString sem_acentos = s; for (int i = 1; i <= s.Length(); ++i) { troca_char<char>(&sem_acentos[i]); } return sem_acentos; }*/ #endif /*void remove_accent(wchar_t* c) noexcept { switch (*c) { case L'\u00C0'): case L'\u00C1'): case L'\u00C2'): case L'\u00C3'): case L'\u00C4'): case L'\u00C5'): *c = L'A'); break; case L'\u00C8'): case L'\u00C9'): case L'\u00CA'): case L'\u00CB'): *c = L'E'); break; case L'\u00CC'): case L'\u00CD'): case L'\u00CE'): case L'\u00CF'): *c = L'I'); break; case L'\u00D2'): case L'\u00D3'): case L'\u00D4'): case L'\u00D5'): case L'\u00D6'): *c = L'O'); break; case L'\u00D9'): case L'\u00DA'): case L'\u00DB'): case L'\u00DC'): *c = L'U'); break; case L'\u00C7'): *c = L'C'); break; case L'\u00D1'): *c = L'N'); break; case L'\u00E0'): case L'\u00E1'): case L'\u00E2'): case L'\u00E3'): case L'\u00E4'): *c = L'a'); break; case L'\u00E8'): case L'\u00E9'): case L'\u00EA'): case L'\u00EB'): *c = L'e'); break; case L'\u00EC'): case L'\u00ED'): case L'\u00EE'): case L'\u00EF'): *c = L'i'); break; case L'\u00F2'): case L'\u00F3'): case L'\u00F4'): case L'\u00F5'): case L'\u00F6'): *c = L'o'); break; case L'\u00E7'): *c = L'c'); break; case L'\u00F1'): *c = L'n'); break; case L'\u00F9'): case L'\u00FA'): case L'\u00FB'): case L'\u00FC'): *c = L'u'); break; default: break; } }*/ } } #endif </DOCUMENT>
<DOCUMENT filename="serialization.hpp">
#ifndef SERIALIZATION_HPP_INCLUDED #define SERIALIZATION_HPP_INCLUDED #include <iostream> #include <sstream> #include <string> #include <boost/archive/text_iarchive.hpp> #include <boost/archive/text_oarchive.hpp> #include <boost/archive/xml_oarchive.hpp> #include <boost/archive/xml_iarchive.hpp> #include <boost/archive/binary_oarchive.hpp> #include <boost/archive/binary_iarchive.hpp> #include <boost/serialization/base_object.hpp> #include <boost/serialization/vector.hpp> #include <boost/serialization/string.hpp> #include <boost/serialization/list.hpp> #include <boost/serialization/slist.hpp> #include <boost/serialization/shared_ptr.hpp> #include <boost/serialization/scoped_ptr.hpp> #include <boost/serialization/utility.hpp> #include <boost/serialization/void_cast.hpp> #include <boost/serialization/weak_ptr.hpp> #include <boost/serialization/wrapper.hpp> #include <boost/serialization/traits.hpp> #include <boost/serialization/hash_map.hpp> #include <boost/serialization/map.hpp> #include <boost/serialization/assume_abstract.hpp> #include <boost/serialization/nvp.hpp> #include <boost/archive/archive_exception.hpp> namespace pensar_digital { namespace cpplib { namespace serialization { namespace ser = boost::serialization; template <typename T, typename OutputArchiveType = boost::archive::text_oarchive> std::string to_string (const T& value) { std::stringstream ss (std::stringstream::in | std::stringstream::out); OutputArchiveType oa (ss); oa << ser::make_nvp("value", value); return ss.str (); } template <typename T, typename InputArchiveType = boost::archive::text_iarchive> T from_string (const std::string& s) { std::stringstream ss (std::stringstream::in | std::stringstream::out); ss << s; InputArchiveType ia (ss); T value; ia >> ser::make_nvp("value", value); return value; } template <typename T> std::string to_xml (const T& value) { return to_string<boost::archive::xml_oarchive> (value); } template <typename T> T from_xml (const std::string& xml_string) { return from_string<boost::archive::xml_iarchive> (xml_string); } } } } #endif </DOCUMENT>
<DOCUMENT filename="sorted_list.hpp">
 #ifndef SORTED_LIST_HPP #define SORTED_LIST_HPP #include "string_def.hpp" #include <vector> #include <algorithm> #include <ranges> #include <iterator> #include <stdexcept> #include <concepts> #include <functional> namespace pensar_digital { namespace cpplib { template<typename T, typename Compare> concept ComparableWith = requires(T a, T b, Compare comp) { { comp(a, b) } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; inline void validate_index(size_t index, size_t size, const S& context = W("SortedList")) { if (index >= size) { throw std::out_of_range(context + W(": Index ") + std::to_string(index) + W(" out of bounds for size ") + std::to_string(size)); } } template<typename T, typename Compare = std::less<T>> requires ComparableWith<T, Compare>&& std::strict_weak_order<Compare, T, T> class SortedList { public: using value_type = T; using iterator = typename std::vector<T>::iterator; using const_iterator = typename std::vector<T>::const_iterator; using reverse_iterator = typename std::vector<T>::reverse_iterator; using const_reverse_iterator = typename std::vector<T>::const_reverse_iterator; using comparator_type = Compare; SortedList(bool unique = false, const Compare& comp = Compare()) : unique_(unique), comp_(comp) { } SortedList(std::initializer_list<T> init, bool unique = false, const Compare& comp = Compare()) : unique_(unique), comp_(comp) { data_.reserve(init.size()); for (const auto& item : init) { add(item); } } template<std::ranges::input_range R> SortedList(R&& range, bool unique = false, const Compare& comp = Compare()) : unique_(unique), comp_(comp) { for (const auto& item : range) { add(item); } } SortedList(const SortedList& other) = default; SortedList(SortedList&& other) noexcept = default; SortedList& operator=(const SortedList& other) = default; SortedList& operator=(SortedList&& other) noexcept = default; ~SortedList() = default; operator S() const { return to_s(); } S to_s() const { SStream ss; ss << W("["); bool first = true; for (const auto& item : *this) { if (!first) ss << W(", "); ss << item; first = false; } ss << W("]"); return ss.str(); } void set_unique(bool unique) noexcept { unique_ = unique; } bool is_unique() const noexcept { return unique_; } bool add(const T& value) { try { auto it = std::lower_bound(data_.begin(), data_.end(), value, comp_); if (unique_ && it != data_.end() && !comp_(*it, value) && !comp_(value, *it)) { return false; } data_.insert(it, value); return true; } catch (const std::exception& e) { throw std::runtime_error(W("Failed to add element: ") + S(e.what())); } } const_iterator find(const T& value) const { try { auto it = std::lower_bound(data_.begin(), data_.end(), value, comp_); if (it != data_.end() && !comp_(*it, value) && !comp_(value, *it)) return it; return data_.end(); } catch (const std::exception& e) { throw std::runtime_error(W("Failed to find element: ") + S(e.what())); } } bool remove(const T& value) { try { auto it = find(value); if (it != data_.end()) { data_.erase(it); return true; } return false; } catch (const std::exception& e) { throw std::runtime_error(W("Failed to remove element: ") + S(e.what())); } } void remove_at(size_t index) { try { validate_index(index, data_.size(), W("SortedList::remove_at")); data_.erase(data_.begin() + index); } catch (const std::exception& e) { throw std::runtime_error(W("Failed to remove element at index: ") + S(e.what())); } } T& at(size_t index) { validate_index(index, data_.size(), W("SortedList::at")); return data_[index]; } const T& at(size_t index) const { validate_index(index, data_.size(), W("SortedList::at")); return data_[index]; } T& operator[](size_t index) { validate_index(index, data_.size(), W("SortedList::operator[]")); return data_[index]; } const T& operator[](size_t index) const { validate_index(index, data_.size(), W("SortedList::operator[]")); return data_[index]; } bool contains(const T& value) const { return find(value) != data_.end(); } size_t size() const noexcept { return data_.size(); } bool empty() const noexcept { return data_.empty(); } void clear() noexcept { data_.clear(); } iterator begin() noexcept { return data_.begin(); } const_iterator begin() const noexcept { return data_.begin(); } const_iterator cbegin() const noexcept { return data_.cbegin(); } iterator end() noexcept { return data_.end(); } const_iterator end() const noexcept { return data_.end(); } const_iterator cend() const noexcept { return data_.cend(); } reverse_iterator rbegin() noexcept { return data_.rbegin(); } const_reverse_iterator rbegin() const noexcept { return data_.rbegin(); } const_reverse_iterator crbegin() const noexcept { return data_.crbegin(); } reverse_iterator rend() noexcept { return data_.rend(); } const_reverse_iterator rend() const noexcept { return data_.rend(); } const_reverse_iterator crend() const noexcept { return data_.crend(); } auto as_range() const noexcept { return std::ranges::subrange(data_.begin(), data_.end()); } const std::vector<T>& data() const noexcept { return data_; } const Compare& comparator() const noexcept { return comp_; } inline auto& last () const { if (data_.empty()) throw std::out_of_range(W("SortedList::back: List is empty")); return data_.back(); } inline auto& back() const { return last(); } private: std::vector<T> data_; bool unique_ = false; Compare comp_; }; } } #endif </DOCUMENT>
<DOCUMENT filename="span_util.hpp">
#ifndef SPAN_UTIL #define SPAN_UTIL #include <span> #include <array> #include "constant.hpp" #include "memory.hpp" namespace pensar_digital { namespace cpplib { ConstByteSpan add (const ConstByteSpan& left, const ConstByteSpan& right) { Bytes v(left.size() + right.size()); ConstByteSpan r = v; return r; } } } #endif </DOCUMENT>
<DOCUMENT filename="statistic.hpp">
#ifndef STATISTIC_HPP #define STATISTIC_HPP #include <iterator> #include <type_traits> #include <numeric> #include <cmath> #include <limits> #include <ranges> namespace pensar_digital { namespace cpplib { template <typename Iter> requires std::input_iterator<Iter>&& std::is_arithmetic_v<typename std::iterator_traits<Iter>::value_type> double standard_deviation(Iter begin, Iter end) { using value_type = typename std::iterator_traits<Iter>::value_type; struct Accumulator { double sum_x = 0.0; double sum_x2 = 0.0; size_t n = 0; }; Accumulator result = std::accumulate(begin, end, Accumulator{}, [](Accumulator acc, value_type x) { double dx = static_cast<double>(x); acc.sum_x += dx; acc.sum_x2 += dx * dx; acc.n += 1; return acc; }); if (result.n == 0) { return std::numeric_limits<double>::quiet_NaN(); } double mean = result.sum_x / result.n; double variance = (result.sum_x2 / result.n) - mean * mean; return std::sqrt(variance); } template <typename Collection> requires std::ranges::input_range<Collection>&& std::is_arithmetic_v<std::ranges::range_value_t<Collection>> double standard_deviation(const Collection& collection) { return standard_deviation(std::ranges::begin(collection), std::ranges::end(collection)); } } } #endif </DOCUMENT>
<DOCUMENT filename="stop_watch.hpp">
 #ifndef STOP_WATCH_HPP_INCLUDED #define STOP_WATCH_HPP_INCLUDED #include "object.hpp" #include "s.hpp" #include <chrono> namespace pensar_digital { namespace cpplib { template <typename Resolution = std::chrono::nanoseconds> class StopWatch : public virtual Object { private: typedef std::chrono::time_point<std::chrono::steady_clock> TimePoint; inline static const TimePoint ZERO = TimePoint (); TimePoint mstart; TimePoint mlast; TimePoint mmark; bool mrunning; public: typedef long long ELAPSED_TYPE; static const ELAPSED_TYPE H = 3600000000000; static const ELAPSED_TYPE M = 60000000000; static const ELAPSED_TYPE S = 1000000000; static const ELAPSED_TYPE MS = 1000000; static const ELAPSED_TYPE MICRO_SECOND = 1000; StopWatch(bool start_now = true) : mstart (start_now ? std::chrono::steady_clock::now() : ZERO), mlast (ZERO), mrunning (start_now) {} inline void start () { mstart = std::chrono::steady_clock::now(); mrunning = true; } inline void reset () { mstart = std::chrono::steady_clock::now(); mlast = ZERO; mrunning = true; } inline void stop () { mlast = std::chrono::steady_clock::now(); mrunning = false; } inline ELAPSED_TYPE elapsed () { return std::chrono::duration_cast<Resolution> (mrunning ? std::chrono::steady_clock::now() - mstart : mlast - mstart).count (); } inline void mark () { mmark = std::chrono::steady_clock::now(); } inline ELAPSED_TYPE elapsed_since_mark () { return std::chrono::duration_cast<Resolution> (mrunning ? std::chrono::steady_clock::now() - mmark : mlast - mmark).count(); } inline ELAPSED_TYPE now () { return std::chrono::duration_cast<Resolution> (std::chrono::steady_clock::now() - ZERO).count(); } pensar_digital::cpplib::S elapsed_formatted(ELAPSED_TYPE elapsed_nanoseconds) { ELAPSED_TYPE elapsed = elapsed_nanoseconds; ELAPSED_TYPE hours = elapsed / H; elapsed -= hours * H; ELAPSED_TYPE minutes = elapsed / M; elapsed -= minutes * M; ELAPSED_TYPE seconds = elapsed / S; elapsed -= seconds * S; ELAPSED_TYPE milliseconds = elapsed / MS; if (milliseconds > 1000) std::cerr << "Warning: milliseconds > 1000" << std::endl; elapsed -= milliseconds * MS; ELAPSED_TYPE microseconds = elapsed / MICRO_SECOND; elapsed -= microseconds * MICRO_SECOND; pensar_digital::cpplib::S result = pd::pad_left0 (hours, 2) + W(":"); result += pd::pad_left0 (minutes, 2) + W(":"); result += pd::pad_left0 (seconds, 2) + W("."); result += pd::pad_left0 (milliseconds, 3) + W("."); result += pd::pad_left0 (microseconds, 3) + W("."); result += pd::pad_left0 (elapsed, 3); return result; } pensar_digital::cpplib::S elapsed_formatted () { return elapsed_formatted (elapsed ()); } pensar_digital::cpplib::S elapsed_since_mark_formatted () { return elapsed_formatted(elapsed_since_mark ()); } }; } } #endif </DOCUMENT>
<DOCUMENT filename="streamable.hpp">
#ifndef STREAMABLE_HPP_INCLUDED #define STREAMABLE_HPP_INCLUDED #include <iostream> namespace pensar_digital { namespace cpplib { class Streamable { protected: virtual std::istream& ReadFromStream (std::istream& is) = 0; virtual std::ostream& WriteToStream ( std::ostream& os) const = 0; public: std::istream& operator >> (std::istream& is) { return ReadFromStream (is);}; std::ostream& operator << (std::ostream& os) const { return WriteToStream (os);}; }; } } #endif </DOCUMENT>
<DOCUMENT filename="stream_util.hpp">
 #ifndef STREAM_UTIL_HPP #define STREAM_UTIL_HPP #include "s.hpp" #include <iostream> #include <sstream> namespace pensar_digital { namespace cpplib { inline constexpr OutStream& out() noexcept { #ifdef WIDE_CHAR return std::wcout; #else return std::cout; #endif } inline auto StringStream() noexcept { #ifdef WIDE_CHAR return std::wstringstream (); #else return std::stringstream(); #endif } } } #endif </DOCUMENT>
<DOCUMENT filename="string_def.hpp">
 #ifndef STRING_DEF_HPP_INCLUDED #define STRING_DEF_HPP_INCLUDED namespace pensar_digital { namespace cpplib { #ifdef WIDE_CHAR using C = wchar_t; #define W(x) L ## x #else using C = char; #define W(x) x #endif inline static const C* EMPTY = W(""); inline static const C SPACE = W(' '); inline static const C* CURRENT_DIR = W("."); inline static const C* DEFAULT_TXT_FILE_EXTENSION = W(".txt"); inline static const C* DEFAULT_BIN_FILE_EXTENSION = W(".bin"); inline static const C* DOUBLE_QUOTES = W("\""); inline static const C NULL_CHAR = W('\0'); using S = std::basic_string<C>; using SView = std::basic_string_view<C>; using SIter = std::basic_string<C>::iterator; using SConstIter = std::basic_string<C>::const_iterator; using InStream = std::basic_istream<C>; using OutStream = std::basic_ostream<C>; using SStream = std::basic_stringstream<C>; using InStreamBuf = std::basic_streambuf<C>; using OutStreamBuf = std::basic_streambuf<C>; using InStreamBufIter = std::istreambuf_iterator<C>; using OutStreamBufIter = std::ostreambuf_iterator<C>; using InStringStream = std::basic_istringstream<C>; using OutStringStream = std::basic_ostringstream<C>; using InFStream = std::basic_ifstream<C>; using OutFStream = std::basic_ofstream<C>; using FStream = std::basic_fstream<C>; using InFileBuf = std::basic_filebuf<C>; using InFileBufIter = std::istreambuf_iterator<C>; using OutFileBuf = std::basic_filebuf<C>; using OutFileBufIter = std::ostreambuf_iterator<C>; } } #endif </DOCUMENT>
<DOCUMENT filename="string_types.hpp">
 #ifndef STRING_TYPES_HPP_INCLUDED #define STRING_TYPES_HPP_INCLUDED #include "s.hpp" namespace pensar_digital { namespace cpplib { } } #endif </DOCUMENT>
<DOCUMENT filename="sysinfo.hpp">
 #ifndef SYSINFO_HPP #define SYSINFO_HPP #include <vector> #include <thread> #include <chrono> #include <atomic> #include <cmath> #include <iostream> #include "code_util.hpp" namespace pensar_digital { namespace cpplib { using EstimateCPUCoresResult = Result<unsigned int>; auto estimate_cpu_threads () { const unsigned int max_threads = std::thread::hardware_concurrency() * 2; const unsigned int min_threads = 1; const double workload_duration_ms = 100.0; const double degradation_threshold = 1.20; std::vector<double> execution_times(max_threads + 1, 0.0); auto worker = [](std::atomic<bool>& running, double duration_ms) { auto start = std::chrono::high_resolution_clock::now(); double dummy = 0.0; while (running) { for (int i = 0; i < 100; ++i) { dummy += std::sin(std::cos(dummy + i)); } auto now = std::chrono::high_resolution_clock::now(); auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - start).count(); if (elapsed >= duration_ms) { break; } } if (dummy == 0.0) std::cout << ""; }; for (unsigned int num_threads = min_threads; num_threads <= max_threads; ++num_threads) { std::vector<std::thread> threads; std::atomic<bool> running(true); auto start = std::chrono::high_resolution_clock::now(); for (unsigned int i = 0; i < num_threads; ++i) { threads.emplace_back(worker, std::ref(running), workload_duration_ms); } for (auto& t : threads) { t.join(); } running = false; auto end = std::chrono::high_resolution_clock::now(); execution_times[num_threads] = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0; if (num_threads > 1) { double prev_time = execution_times[num_threads - 1]; double curr_time = execution_times[num_threads]; if (curr_time > prev_time * degradation_threshold) { return num_threads; } } } } auto cpu_threads(const unsigned int n = 10) { auto result = std::thread::hardware_concurrency(); if (result > 0) { return result; } std::vector<unsigned int> results(n); for (unsigned int i = 0; i < n; ++i) { results[i] = estimate_cpu_threads(); std::this_thread::sleep_for(std::chrono::milliseconds(50)); } std::sort(results.begin(), results.end()); unsigned int mode = results[0]; unsigned int count = 1; unsigned int max_count = 1; for (unsigned int i = 1; i < n; ++i) { if (results[i] == results[i - 1]) { count++; } else { if (count > max_count) { max_count = count; mode = results[i - 1]; } count = 1; } } if (count > max_count) { mode = results[n - 1]; } return mode; } } } #endif </DOCUMENT>
<DOCUMENT filename="system.cpp">
#include <string> namespace pensar_digital { namespace cpplib { } } </DOCUMENT>
<DOCUMENT filename="system.hpp">
 #ifndef SYSTEM_HPP #define SYSTEM_HPP #ifdef _WIN32 #define _WINSOCKAPI_ #include <winsock2.h> #include <iphlpapi.h> #include <intrin.h> #include <windows.h> #elif __APPLE__ #include <sys/socket.h> #include <sys/sysctl.h> #include <net/if.h> #include <net/if_dl.h> #include <sys/statvfs.h> #elif __linux__ #include <unistd.h> #include <sys/ioctl.h> #include <net/if.h> #include <linux/if.h> #include <linux/sockios.h> #include <sys/statvfs.h> #endif #include "s.hpp" #include "mac_address.hpp" #include <iostream> #include <type_traits> #include <string> #include <bit> #include <cstdint> #include <cstring> #include <cstdio> #include <array> #include <fstream> namespace pensar_digital { namespace cpplib { #if defined(_WIN32) || defined(_WIN64) #include <windows.h> #elif __linux__ #include <unistd.h> #include <sys/utsname.h> #define MAX_PATH 4096 #define MAX_UNC_PATH 4096 #define PATH_SEPARATOR W('/') #endif static S os_name() { #if defined(_WIN32) || defined(_WIN64) return W("Windows"); #elif defined(__APPLE__) && defined(TARGET_OS_IOS) return W("iOS"); #elif defined(__ANDROID__) return W("Android"); #elif defined(__linux__) return W("Linux"); #else return W("Other"); #endif } enum class OS { Windows, Linux, MacOS, IOS, Android, Other }; inline static constexpr OS os() { #if defined(_WIN32) || defined(_WIN64) return OS::Windows; #elif defined(__APPLE__) && defined(TARGET_OS_IOS) return OS::IOS; #elif defined(__ANDROID__) return OS::Android; #elif defined(__linux__) return OS::Linux; #else return OS::Other; #endif } static S os_version() { #if defined(_WIN32) || defined(_WIN64) OSVERSIONINFO info; ZeroMemory(&info, sizeof(OSVERSIONINFO)); info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); S s = to_string(info.dwMajorVersion); s += W("."); s += to_string(info.dwMinorVersion); S r(s.c_str()); return r; #elif __linux__ struct utsname buffer; uname(&buffer); return buffer.release; #else return W("Unknown"); #endif } class BaseSystem { public: inline static constexpr size_t DEFAULT_MAX_NAME_LENGTH = 255; inline static constexpr size_t DEFAULT_MAX_PATH = 260; inline static S endianess_name() noexcept { return (std::endian::native == std::endian::little) ? W("Little Endian") : W("Big Endian"); } static std::endian endianess() noexcept { return (std::endian::native == std::endian::little) ? std::endian::little : std::endian::big; } inline static bool is_name_valid_common(const S& name) { return !name.empty() && name[0] != '.' && name.size() <= DEFAULT_MAX_NAME_LENGTH; } }; template<OS OSTtype> class System : public BaseSystem { static_assert (OSTtype == OS::Windows || OSTtype == OS::Linux || OSTtype == OS::MacOS || OSTtype == OS::IOS || OSTtype == OS::Android, W("Unsupported operating system.")); }; template<> class System<OS::Linux> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static size_t get_max_name_length () noexcept { return 255; } inline static size_t get_max_path () noexcept { #define DEFAULT_LINUX_MAX_PATH 4096 #ifdef PATH_MAX return PATH_MAX; #else return DEFAULT_LINUX_MAX_PATH; #endif } inline static constexpr C path_separator() { return W('/'); } inline static bool is_valid_file_name (const S& file_name) { return is_name_valid_common (file_name) && file_name.find (path_separator ()) == S::npos && file_name.find ('\0') == S::npos; } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common(path_name) && path_name.find('\0') == S::npos; } inline static std::vector<MacAddress> mac_addresses () { #ifdef __linux__ std::vector<MacAddress> mac_addresses; struct ifreq ifr; struct ifconf ifc; char buf[1024]; int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); if (sock == -1) { }; ifc.ifc_len = sizeof(buf); ifc.ifc_buf = buf; if (ioctl(sock, SIOCGIFCONF, &ifc) == -1) { } struct ifreq* it = ifc.ifc_req; const struct ifreq* const end = it + (ifc.ifc_len / sizeof(struct ifreq)); for (; it != end; ++it) { strcpy(ifr.ifr_name, it->ifr_name); if (ioctl(sock, SIOCGIFFLAGS, &ifr) == 0) { if (!(ifr.ifr_flags & IFF_LOOPBACK)) { if (ioctl(sock, SIOCGIFHWADDR, &ifr) == 0) { unsigned char mac_address[6]; memcpy(mac_address, ifr.ifr_hwaddr.sa_data, 6); int64_t mac; sscanf_s((char*)mac_address, "%llx", &mac); mac_addresses.push_back(MacAddress(mac)); } } } else { } return mac_addresses; #endif } #ifdef __linux__ static inline S cpu_id() { S cpu_id; InFStream cpuinfo (W("/proc/cpuinfo")); if (cpuinfo) { S line; while (std::getline (cpuinfo, line)) { if (line.substr (0, 9) == W("processor")) { cpu_id = line; break; } } } return cpu_id; } #endif }; template<> class System<OS::IOS> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static constexpr size_t get_max_name_length () noexcept { return 255; } inline static constexpr size_t get_max_path () noexcept { #define DEFAULT_IOS_MAX_PATH 4096 return DEFAULT_IOS_MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('/'); } inline static bool is_valid_file_name (const S& file_name) { return is_name_valid_common (file_name) && file_name.find (path_separator ()) == S::npos && file_name.find ('\0') == S::npos; } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } }; template<> class System<OS::Android> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static constexpr size_t get_max_name_length() noexcept { return 255; } inline static constexpr size_t get_max_path () noexcept { #define DEFAULT_ANDROID_MAX_PATH 4096 return DEFAULT_ANDROID_MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('/'); } inline static bool is_valid_file_name(const S& file_name) { return is_name_valid_common(file_name) && file_name.find(path_separator()) == S::npos && file_name.find('\0') == S::npos; } inline static bool is_valid_path(const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } }; template<> class System<OS::MacOS> : public BaseSystem { public: inline static const S LINE_FEED = W("\n"); inline static constexpr size_t get_max_name_length () noexcept { return 255; } inline static constexpr size_t get_max_path () noexcept { #define DEFAULT_MACOS_MAX_PATH 1024 return DEFAULT_MACOS_MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('/'); } inline static bool is_valid_file_name (const S& file_name) { return is_name_valid_common (file_name) && file_name.find (path_separator ()) == S::npos && file_name.find ('\0') == S::npos; } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } inline static std::vector<MacAddress> mac_addresses () { return std::vector<MacAddress>(); } }; template<> class System <OS::Windows> : public BaseSystem { public: inline static const S LINE_FEED = W("\r\n"); inline static size_t get_max_name_length () noexcept { return 255; } inline static size_t get_max_path () noexcept { return MAX_PATH; } inline static constexpr C path_separator () noexcept { return W('\\'); } inline static bool is_valid_path (const S& path_name) { return is_name_valid_common (path_name) && path_name.find (W('\0')) == S::npos; } inline static bool is_valid_file_name (const S& file_name) { static const S invalidChars = W("<>:\"/\\|?*"); return is_name_valid_common (file_name) && file_name.find_first_of (invalidChars) == S::npos; } #if defined(_WIN32) || defined(_WIN64) #pragma comment(lib, "IPHLPAPI.lib") #endif inline static std::vector<MacAddress> mac_addresses () { std::vector<MacAddress> mac_addresses; PIP_ADAPTER_INFO AdapterInfo; DWORD dwBufLen = sizeof(AdapterInfo); char* mac_addr = new char[18]; AdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO)); if (AdapterInfo == NULL) { printf("Error allocating memory needed to call GetAdaptersinfo\n"); return mac_addresses; } if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) { AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen); if (AdapterInfo == NULL) { printf("Error allocating memory needed to call GetAdaptersinfo\n"); return mac_addresses; } } if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) { PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; do { sprintf_s(mac_addr, 18, "%02X:%02X:%02X:%02X:%02X:%02X", pAdapterInfo->Address[0], pAdapterInfo->Address[1], pAdapterInfo->Address[2], pAdapterInfo->Address[3], pAdapterInfo->Address[4], pAdapterInfo->Address[5]); printf("Address: %s, mac: %s\n", pAdapterInfo->IpAddressList.IpAddress.String, mac_addr); int64_t mac; sscanf_s(mac_addr, "%llx", &mac); mac_addresses.push_back(MacAddress(mac)); pAdapterInfo = pAdapterInfo->Next; } while (pAdapterInfo); } free(AdapterInfo); return mac_addresses; } inline static S cpu_id() { std::array<int, 4> cpuid; __cpuid (cpuid.data (), 0); S cpu_id = to_string (cpuid[1]) + to_string (cpuid[3]); return cpu_id; } }; using Sys = System<os()>; inline const static S LF = Sys::LINE_FEED; inline static bool is_valid_path(const S& path_name) { return Sys::is_valid_file_name(path_name); } inline static bool is_valid_file_name(const S& file_name) { return Sys::is_valid_file_name(file_name); } inline static std::vector<MacAddress> mac_addresses() { return Sys::mac_addresses(); } inline static S cpu_id() { return Sys::cpu_id(); } inline static S file_name(const S& path_name) { size_t pos = path_name.find_last_of(Sys::path_separator()); if (pos == S::npos) return path_name; return path_name.substr(pos + 1); } } } #endif </DOCUMENT>
<DOCUMENT filename="sys_user_info.cpp">
 #ifdef CODE_GEAR #pragma hdrstop #endif #ifdef WIN32 #include <windows.h> #endif #include "sys_user_info.hpp" #ifdef CODE_GEAR #pragma package(smart_init) #endif namespace pensar_digital { namespace cpplib { } } </DOCUMENT>
<DOCUMENT filename="sys_user_info.hpp">
 #ifndef sys_user_infoH #define sys_user_infoH #include "s.hpp" #include "io_util.hpp" #include "path.hpp" namespace pensar_digital { namespace cpplib { #ifdef _WIN32 template <bool use_exceptions = true> Path get_user_home_windows() { std::string home = ""; char* s; size_t len; errno_t err = _dupenv_s(&s, &len, "USERPROFILE"); if (err != 0) { err = _dupenv_s(&s, &len, "HOMEDRIVE"); if (err != 0) { err = _dupenv_s(&s, &len, "HOMESHARE"); } else { home = s; free(s); err = _dupenv_s(&s, &len, "HOMEPATH"); home = (err ? (home + s) : ""); } } home = (err ? "" : s); free(s); if (err and use_exceptions) { throw std::runtime_error("get_user_home_windows: Failed to get user home dir."); } return home; } #endif #if defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__)) template <bool use_exceptions = true> Path get_user_home_unix() { S home = ""; char* s; size_t len; errno_t err = _dupenv_s(&s, &len, "USERPROFILE"); if (!err) { home = s; free(s); } else { if (!s_GetHomeByUID(home)) { s_GetHomeByLOGIN(home); } } if (err and use_exceptions) { throw std::runtime_error("get_user_home_unix: Failed to get user home dir."); } } #endif template <bool use_exceptions = true> Path get_user_home() { S home; #ifdef _WIN32 return get_user_home_windows<use_exceptions>(); #elif defined(__unix__ || __APPLE__ || __linux__) return get_user_home_unix<use_exceptions>(); #else if (use_exceptions) throw std::runtime_error("get_user_home: Não foi possível pegar o diretório home do usuário pois o sistema operacional não foi identificado."); else return ""; #endif } } } #endif </DOCUMENT>
<DOCUMENT filename="telefone - Copy.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #ifdef CODE_GEAR #pragma hdrstop #endif #include "telefone.h" namespace pensar_digital { namespace cpplib { #ifdef CODE_GEAR const AnsiString asCOMERCIAL = "Comercial" ; const AnsiString asRESIDENCIAL = "Residencial"; const AnsiString asCELULAR = "Celular" ; const AnsiString asEMERGENCIA = "Emergencia"; const AnsiString asDEFAULT_DDD = "11"; const AnsiString asDEFAULT_COD_PAIS = "55"; #pragma package(smart_init) #endif extern const std::string COMERCIAL = "Comercial"; extern const std::string RESIDENCIAL = "Residencial"; extern const std::string CELULAR = "Celular"; extern const std::string EMERGENCIA = "Emergencia"; extern const std::string DEFAULT_DDD = "11"; extern const std::string DEFAULT_COD_PAIS = "55"; #ifdef CODE_GEAR vclTelefone parse_phone_number (AnsiString valid_number) { vclTelefone t; AnsiString d = only_digits (valid_number); int size = d.Length (); if (size >= 8) { int restante = size - 8; t.numero = d.SubString (size - 7, 8); if (restante) { t.cod_ddd = d.SubString (restante - 1, 2); if (restante - 2) { t.cod_pais = d.SubString (0, restante - 2); } } } else t.numero = d; return t; } AnsiString format_phone_number (AnsiString valid_number) { AnsiString d = only_digits (valid_number); assert (is_valid_phone_number (valid_number)); int size = d.Length (); int restante = size - 8; AnsiString numero = d.SubString (size - 7, 4); AnsiString numero2 = d.SubString (size - 3, 4); AnsiString result; if (restante) { AnsiString cod_ddd = d.SubString (restante - 1, 2); if (restante - 2) { AnsiString cod_pais = d.SubString (0, restante - 2); result = cod_pais + "-"; } result += cod_ddd + "-"; } return result + numero + "-" + numero2; } #endif } } </DOCUMENT>
<DOCUMENT filename="telefone.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #ifdef CODE_GEAR #pragma hdrstop #endif #include "telefone.h" namespace pensar_digital { namespace cpplib { #ifdef CODE_GEAR const AnsiString asCOMERCIAL = "Comercial" ; const AnsiString asRESIDENCIAL = "Residencial"; const AnsiString asCELULAR = "Celular" ; const AnsiString asEMERGENCIA = "Emergencia"; const AnsiString asDEFAULT_DDD = "11"; const AnsiString asDEFAULT_COD_PAIS = "55"; #pragma package(smart_init) #endif extern const std::string COMERCIAL = "Comercial"; extern const std::string RESIDENCIAL = "Residencial"; extern const std::string CELULAR = "Celular"; extern const std::string EMERGENCIA = "Emergencia"; extern const std::string DEFAULT_DDD = "11"; extern const std::string DEFAULT_COD_PAIS = "55"; #ifdef CODE_GEAR vclTelefone parse_phone_number (AnsiString valid_number) { vclTelefone t; AnsiString d = only_digits (valid_number); int size = d.Length (); if (size >= 8) { int restante = size - 8; t.numero = d.SubString (size - 7, 8); if (restante) { t.cod_ddd = d.SubString (restante - 1, 2); if (restante - 2) { t.cod_pais = d.SubString (0, restante - 2); } } } else t.numero = d; return t; } AnsiString format_phone_number (AnsiString valid_number) { AnsiString d = only_digits (valid_number); assert (is_valid_phone_number (valid_number)); int size = d.Length (); int restante = size - 8; AnsiString numero = d.SubString (size - 7, 4); AnsiString numero2 = d.SubString (size - 3, 4); AnsiString result; if (restante) { AnsiString cod_ddd = d.SubString (restante - 1, 2); if (restante - 2) { AnsiString cod_pais = d.SubString (0, restante - 2); result = cod_pais + "-"; } result += cod_ddd + "-"; } return result + numero + "-" + numero2; } #endif } } </DOCUMENT>
<DOCUMENT filename="test\algorithm_util_test.cpp">
 #include <unordered_map> #include <cctype> #include <functional> #include "../../../unit-test/src/test.hpp" #include "../version.hpp" #include "../algorithm_util.hpp" #include "../s.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(algorithm_util, true) std::unordered_map<int, std::string> map; map[0] = "a"; map[1] = "1"; map[2] = "c"; erase_if(map, std::isdigit); test::CHECK_EQ(std::string, map[0], "a", "0"); CHECK_EQ(W("c"), map[2]); CHECK_EQ(2u, map.size()); std::vector<int> v(3); v[0] = 0; v[1] = 1; v[2] = 2; pd::erase_if(v, std::bind2nd(std::equal_to<int>(), 1)); CHECK_EQ(0, v[0]); CHECK_EQ(2, v[1]); CHECK_EQ(2u, v.size()); END_TEST(algorithm_util); } } </DOCUMENT>
<DOCUMENT filename="test\byte_order_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../byte_order.hpp" #include "../array.hpp" #include <span> namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { template <typename U, typename T = U> void test_byte_order_conversion(Test& t, std::vector<U> a, std::vector<T> expected, uint_fast8_t count = 0) { std::vector<T> a6; for (auto x : a) a6.push_back (x); auto data = std::span{ a }; auto b = std::as_writable_bytes(data); auto size = sizeof(U); pd::convert<>(b, size, pd::native_byte_order, pd::big_address_8_byte_order); if (sizeof(U) > sizeof(std::byte)) { if ((sizeof(T) == sizeof(U))) { Array<T> c(expected.size()); std::memcpy(c.data(), b.data(), b.size()); std::vector<T> a3(c.data(), c.data() + c.size()); static_assert (ContainerV<pd::Array<T>, T>); static_assert (ContainerV<std::vector<T>, T>); t.check_equal_collection<std::vector<T>, std::vector<T>>(a3, expected, pd::to_string<decltype(count)>(count++) + W("."), sfile (), __LINE__); pd::convert<>(b, size, pd::big_address_8_byte_order, pd::native_byte_order); std::memcpy(c.data(), b.data(), b.size()); std::vector<T> a5(c.data(), c.data() + c.size()); t.check_equal_collection<std::vector<T>, std::vector<T>>(a5, a6, pd::to_string<decltype(count)>(count++) + W("."), sfile(), __LINE__); } else { if (sizeof(T) > sizeof(U)) { /* size_t diff = sizeof(T) - sizeof(U); Array<T> c(expected.size()); for (auto i = 0; i < expected.size(); i++) { c[i] = 0x00000000; std::byte* p = (std::byte*)(&c[i]) + i * sizeof(U); *p = b[i]; *(p + 1) = b[i + 1]; } t.check<pd::Array<T>, std::vector<T>>(c, expected, pd::to_string<decltype (count)>(count++) + ".", __FILE__, __LINE__); Array<U> d(a.size()); pd::convert<>(b, size, pd::big_address_8_byte_order, pd::native_byte_order); std::memcpy(d.data(), b.data(), b.size()); t.check<Array<U>, std::vector<T>>(d, a6, pd::to_string<decltype(count)>(count++) + ".", __FILE__, __LINE__); */ } } } } TEST(ByteOrder1, true) std::vector<uint8_t> a1 = { 0, 1, 2, 3, 4, 5, 6, 7, 8 }; std::vector<uint8_t> a2 = { 0, 1, 2, 3, 4, 5, 6, 7, 8 }; test_byte_order_conversion<uint8_t > (*this, a1, a2, 0); std::vector<uint16_t> a3 = {0, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008}; std::vector<uint16_t> expected = { 0, 0x0100, 0x0200, 0x0300, 0x0400, 0x0500, 0x0600, 0x0700, 0x0800 }; test_byte_order_conversion<uint16_t> (*this, a3, expected, 1); std::vector<uint32_t> a5 = { 0, 0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008 }; std::vector<uint32_t> a6 = { 0, 0x01000000, 0x02000000, 0x03000000, 0x04000000, 0x05000000, 0x06000000, 0x07000000, 0x08000000 }; test_byte_order_conversion<uint32_t> (*this, a5, a6, 2); std::vector<uint64_t> a7 = { 0, 0x0000000000000001, 0x0000000000000002, 0x0000000000000003, 0x0000000000000004, 0x0000000000000005, 0x0000000000000006, 0x0000000000000007, 0x0000000000000008 }; std::vector<uint64_t> a8 = { 0, 0x0100000000000000, 0x0200000000000000, 0x0300000000000000, 0x0400000000000000, 0x0500000000000000, 0x0600000000000000, 0x0700000000000000, 0x0800000000000000 }; test_byte_order_conversion<uint64_t> (*this, a7, a8, 3); std::vector<int8_t> a9 = { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8 }; std::vector<int8_t> a10 = { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2 ,3, 4, 5, 6, 7, 8 }; test_byte_order_conversion<int8_t >(*this, a9, a10, 4); std::vector<int16_t > a11 = { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8 }; std::vector<uint16_t> a12 = { 0xf8ff, 0xf9ff, 0xfaff, 0xfbff, 0xfcff, 0xfdff, 0xfeff, 0xffff, 0x0000, 0x0100, 0x0200 ,0x0300, 0x0400, 0x0500, 0x0600, 0x0700, 0x0800 }; test_byte_order_conversion<int16_t, uint16_t>(*this, a11, a12, 5); std::vector<int32_t > a13 = { -8, -7, -6, -5, -4, -3, -2, -1, 0x00000000, 0x00000001, 0x00000002 ,0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008 }; std::vector<uint32_t> a14 = { 0xf8ffffff, 0xf9ffffff, 0xfaffffff, 0xfbffffff, 0xfcffffff, 0xfdffffff, 0xfeffffff, 0xffffffff, 0x0000000000000000, 0x01000000, 0x02000000 ,0x03000000, 0x04000000, 0x05000000, 0x06000000, 0x07000000, 0x08000000 }; test_byte_order_conversion<int32_t, uint32_t>(*this, a13, a14, 6); std::vector<int64_t > a15 = { -8, -7, -6, -5, -4, -3, -2, -1, 0x00000000, 0x00000001, 0x00000002 ,0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008 }; std::vector<uint64_t> a16 = { 0xf8ffffffffffffff, 0xf9ffffffffffffff, 0xfaffffffffffffff, 0xfbffffffffffffff, 0xfcffffffffffffff, 0xfdffffffffffffff, 0xfeffffffffffffff, 0xffffffffffffffff, 0x0000000000000000, 0x0100000000000000, 0x0200000000000000 ,0x0300000000000000, 0x0400000000000000, 0x0500000000000000, 0x0600000000000000, 0x0700000000000000, 0x0800000000000000 }; test_byte_order_conversion<int64_t, uint64_t>(*this, a15, a16, 7); TEST_END(ByteOrder1) } } </DOCUMENT>
<DOCUMENT filename="test\code_util_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../code_util.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { namespace code_util { using R = Result<int>; R f() { return 10; } R f1() { return W("err msg"); } TEST(Result, true) R r = f (); CHECK_EQ(R, r, 10, W("0. r != 10")); CHECK_EQ(Bool, r.mok, Bool::T, W("0. r != Bool::T")); R r1 = f1 (); CHECK (! r1, "r1 must be false."); CHECK_EQ(R::ErrorMessageType, r1.merror_message, W("err msg"), W("0. r1.merror_message != err msg")); CHECK_EQ(Bool, r1, Bool::F, W("1. r1.mok != Bool::F")); TEST_END(Result) TEST(ResultSerialization, true) using R = Result<int>; R r; MemoryBuffer mb((BytePtr)&r, sizeof(R)); R r1(0, Bool::F, R::ErrorMessageType(W("err msg"))); CHECK_NOT_EQ(R, r, r1, W("0. r == r1")); r1 = r; CHECK_EQ(R, r, r1, W("1. r != r1")); TEST_END(ResultSerialization) } } } </DOCUMENT>
<DOCUMENT filename="test\command.cpp">
</DOCUMENT>
<DOCUMENT filename="test\command_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../command.hpp" #include "../memory_buffer.hpp" #include "../obj_memory_buffer.hpp" namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { inline static int value = 0; class IncCmd : public Command { public: using Ptr = std::shared_ptr<IncCmd>; IncCmd(const Id aid = NULL_ID) : Command(aid) { } IncCmd(MemoryBuffer& mb) : Command(mb) { } ~IncCmd() = default; using Factory = pd::Factory<IncCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("IncCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } inline Ptr clone() const noexcept { return pd::clone<IncCmd>(*this, id()); } inline void _run() { ++value; } inline void _undo() const { --value; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class DecCmd : public Command { public: using Ptr = std::shared_ptr<DecCmd>; DecCmd(const Id aid = NULL_ID) : Command(aid) { } DecCmd(MemoryBuffer& mb) : Command(mb) { } ~DecCmd() = default; using Factory = pd::Factory<DecCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("DecCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } virtual Ptr clone() const noexcept { return pd::clone<DecCmd>(*this, id()); } void _run() { --value; } void _undo() const { ++value; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class IncFailCmd : public Command { public: using Ptr = std::shared_ptr<IncFailCmd>; IncFailCmd(const Id aid = NULL_ID) : Command(aid) { } IncFailCmd(MemoryBuffer& mb) : Command(mb) { } ~IncFailCmd() = default; using Factory = pd::Factory<IncFailCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("IncFailCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } virtual Ptr clone() const noexcept { return pd::clone<IncFailCmd>(*this, id()); } void _run() { throw "IncFailCmd.run () error."; } void _undo() const { --value; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class DoubleCmd : public Command { public: using Ptr = std::shared_ptr<DoubleCmd>; DoubleCmd(const Id aid = NULL_ID) : Command(aid) { } DoubleCmd(MemoryBuffer& mb) : Command(mb) { } ~DoubleCmd() = default; using Factory = pd::Factory<DoubleCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("DoubleCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } virtual Ptr clone() const noexcept { return pd::clone<DoubleCmd>(*this, id()); } void _run() { value *= 2; } void _undo() const { value /= 2; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; class DoubleFailCmd : public Command { public: using Ptr = std::shared_ptr<DoubleFailCmd>; DoubleFailCmd(const Id aid = NULL_ID) : Command(aid) { } DoubleFailCmd(MemoryBuffer& mb) : Command(mb) { } ~DoubleFailCmd() = default; using Factory = pd::Factory<DoubleFailCmd, Id>; inline static Factory mfactory = { 3, 10, NULL_ID }; inline static typename Factory::P get(Id aid = NULL_ID) noexcept { return mfactory.get(aid); } inline static const ClassInfo INFO = { CPPLIB_NAMESPACE, W("DoubleFailCmd"), 2, 1, 1 }; inline virtual const ClassInfo* info_ptr() const noexcept { return &INFO; } virtual bool initialize(const Id id) noexcept { this->set_id(id == NULL_ID ? this->mgenerator.get_id() : id); return true; } Ptr clone() const noexcept { return pd::clone<DoubleFailCmd>(*this, id()); } void _run() { throw "Double errors."; } void _undo() const { value /= 2; } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(size()); mb->append(Command::bytes()); mb->append(INFO.bytes()); return mb; } }; TEST(Command, true) { value = 0; IncCmd inc; CHECK_EQ(int, value, 0, "0"); inc.run(); CHECK_EQ(int, value, 1, "1"); inc.undo(); CHECK_EQ(int, value, 0, "2"); DecCmd dec; CHECK_EQ(int, value, 0, "3"); dec.run(); CHECK_EQ(int, value, -1, "4"); dec.undo(); CHECK_EQ(int, value, 0, "5"); IncFailCmd inc_fail; try { inc_fail.run(); } catch (...) { CHECK_EQ(int, value, 0, "6"); } } TEST_END(Command) TEST(CommandClone, true) IncCmd Cmd; IncCmd Cmd2(1); CHECK_NOT_EQ(IncCmd, Cmd, Cmd2, W("0")); auto ClonedCmd = Cmd.clone(); IncCmd* ClonedCmdPtr = (IncCmd*)ClonedCmd.get (); CHECK_EQ(IncCmd, Cmd, *ClonedCmdPtr, W("1")); TEST_END(CommandClone) TEST(CompositeCommand, true) { using Cmd = CompositeCommand; static_assert (Identifiable<Cmd>); Cmd cmd; value = 0; CHECK_EQ(int, value, 0, "0"); cmd.run(); CHECK_EQ(int, value, 0, "1"); CompositeCommand cmd2; cmd2.add(new IncCmd); cmd2.add(new DecCmd); cmd2.add(new DecCmd); cmd2.add(new DecCmd); CHECK_EQ(int, value, 0, "2"); cmd2.run(); CHECK_EQ(int, value, -2, "3"); cmd2.undo(); CHECK_EQ(int, value, 0, "4"); CompositeCommand cmd3; cmd3.add(new IncCmd); cmd3.add(new DecCmd); cmd3.add(new IncFailCmd); CHECK_EQ(int, value, 0, "5"); try { cmd3.run(); } catch (...) { CHECK_EQ(int, value, 0, "6"); } CHECK_EQ(int, value, 0, "7"); MemoryBuffer::Ptr mb_ptr = cmd2.bytes(); Cmd cmd4(*mb_ptr); value = 0; cmd2.run(); CHECK_EQ(int, value, -2, "3"); cmd2.undo(); CHECK_EQ(int, value, 0, "4"); } TEST_END(CompositeCommand) TEST(CommandBinaryFileStreaming, true) using Cmd = IncCmd; std::ofstream out(W("c:\\tmp\\test\\CommandBinaryStreaming\\test.bin"), std::ios::binary); Cmd cmd; Cmd cmd2; CHECK_NOT_EQ(Cmd, cmd, cmd2, W("0")); cmd.binary_write(out); out.close(); std::ifstream in(W("c:\\tmp\\test\\CommandBinaryStreaming\\test.bin"), std::ios::binary); cmd2.binary_read(in); CHECK_EQ(Cmd, cmd, cmd2, W("1")); TEST_END(CommandBinaryFileStreaming) TEST (CompositeCommandClone, true) using Cmd = CompositeCommand; Cmd cmd; Cmd cmd2; CHECK_NOT_EQ(Cmd, cmd, cmd2, W("0")); Cmd::Ptr cmd3 = cmd.clone(); Cmd& cmd4 = *cmd3; CHECK_EQ(Cmd, cmd4, cmd, W("1")); TEST_END(CompositeCommandClone) TEST(CompositeCmdBinaryStreaming, true) using Cmd = CompositeCommand; Cmd cmd; Cmd cmd2; CHECK_NOT_EQ(Cmd, cmd, cmd2, W("0")); MemoryBuffer::Ptr mb_ptr = cmd.bytes (); cmd2.assign(*mb_ptr); CHECK_EQ(Cmd, cmd2, cmd, W("1")); TEST_END(CompositeCmdBinaryStreaming) } } </DOCUMENT>
<DOCUMENT filename="test\concept_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../concept.hpp" #include "../constraint.hpp" namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { template <typename... Args> class Checkable0 { public: virtual bool ok (Args& ... args) const { return true; } }; class Checkable1 { public: virtual bool ok () const noexcept { return true; } }; TEST(CheckableConcept, true) static_assert(Checkable<Checkable0<int>, int>); static_assert(Checkable<Checkable0<S>, S>); static_assert(Checkable<Checkable0<>>); static_assert(Checkable<Checkable1>); static_assert(Checkable<StringConstraint, S>); TEST_END(CheckableConcept) } } </DOCUMENT>
<DOCUMENT filename="test\config_manager_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "ConfigManager.h" namespace cpp = pensar_digital::cpplib; class Dummy { private: std::string s; int i; std::vector<std::string> slist; friend class boost::serialization::access; template<typename Archive> void serialize(Archive& ar, const unsigned int version) { ar & BOOST_SERIALIZATION_NVP(s); ar & BOOST_SERIALIZATION_NVP(i); ar & BOOST_SERIALIZATION_NVP(slist); } public: Dummy (std::string s_, int i_, const std::vector<std::string>& slist_): s(s_), i(i_), slist(slist_) {} }; BOOST_AUTO_TEST_SUITE(config_manager_suite) BOOST_AUTO_TEST_CASE(config_manager_test) { cpp::ConfigManager<std::string> cfg; cfg.set ("p1", std::string("value1")); cfg.set ("p2", "2"); cfg.save (); cpp::ConfigManager<std::string> cfg2; cfg.load (); std::string p1 = cfg.get<std::string> ("p1"); int p2 = cfg.get<int> ("p2"); BOOST_CHECK_EQUAL ("value1", p1); BOOST_CHECK_EQUAL (2, p2); } BOOST_AUTO_TEST_CASE(config_manager_xml_test) { /* std::vector<std::string> v; v.push_back ("a@a.com"); v.push_back ("b@a.com"); v.push_back ("c@a.com"); TestSerialization ("teste", 1, v); cpp::ConfigManager<std::string, boost::archive::xml_oarchive, boost::archive::xml_iarchive> cfg ("config.xml"); cfg.set ("p1", "value1"); cfg.set ("p2", "2"); cfg.save (); cfg.set ("p1", ""); cfg.set ("p2", ""); cfg.load (); std::string p1 = cfg.get<std::string> ("p1"); int p2 = cfg.get<int> ("p2"); BOOST_CHECK_EQUAL ("value1", p1); BOOST_CHECK_EQUAL (2, p2); */ } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\constraint_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../constraint.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Constraint, true) StringConstraint sc (ONLY_DIGITS_REGEX); CHECK( sc.ok (W("123") ), W("0")); CHECK(!sc.ok (W("123a")), W("1")); CHECK(!sc.ok (W("a123")), W("2")); CHECK( sc.ok (W("") ), W("3")); CHECK(!sc.ok (W(" ") ), W("4")); CHECK(!sc.ok (W(" 123")), W("5")); CHECK( sc.ok (W("0") ), W("6")); StringConstraint sc2(W("^bola$")); CHECK( sc2.ok (W("bola") ), W("7")); CHECK(!sc2.ok (W(" bola")), W("8")); CHECK(!sc2.ok (W("") ), W("9")); CompositeConstraint<StringConstraint, StringConstraint> sc3 = (sc || sc2); CHECK( sc3.ok (W("bola") ), W("10")); CHECK( sc3.ok (W("123") ), W("11")); CHECK(!sc3.ok (W("123bola")), W("12")); TEST_END (Constraint); TEST(RangeConstraint, true) RangeConstraint<int> rc (0, 10); CHECK( rc.ok (0 ), W("0")); CHECK( rc.ok (10 ), W("1")); CHECK( rc.ok (5 ), W("2")); CHECK(!rc.ok (-1 ), W("3")); CHECK(!rc.ok (11 ), W("4")); CHECK(!rc.ok (100), W("5")); RangeConstraint<C> rc2 (W('A'), W('E')); CHECK( rc2.ok (W('A')), W("6")); CHECK( rc2.ok (W('E')), W("7")); CHECK( rc2.ok (W('C')), W("8")); CHECK(!rc2.ok (W('@')), W("9")); CHECK(!rc2.ok (W('F')), W("10")); CHECK(!rc2.ok (W('a')), W("11")); CHECK(!rc2.ok (W('e')), W("12")); RangeConstraint<int> rc3 (10); CHECK( rc3.ok (10), W("13")); CHECK(!rc3.ok (9 ), W("14")); CHECK(!rc3.ok (11), W("15")); TEST_END (RangeConstraint); TEST(CompositeConstraints, true) RangeConstraint<int> baby (0, 2); RangeConstraint<int> kid (3, 10); RangeConstraint<int> teen (11, 19); RangeConstraint<int> adult(20, 60); RangeConstraint<int> old (61, 200); typedef CompositeConstraint<RangeConstraint<int>, RangeConstraint<int>> CompositeRangeInt; CompositeRangeInt babies_or_kids = (baby || kid); CHECK( babies_or_kids.ok ( 0), W("0")); CHECK(!babies_or_kids.ok (11), W("1")); CHECK( babies_or_kids.ok ( 3), W("2")); CHECK( babies_or_kids.ok (10), W("3")); CompositeRangeInt teens_or_adults = (teen || adult); CHECK( teens_or_adults.ok ( 11), W("4")); CHECK( teens_or_adults.ok ( 19), W("5")); CHECK( teens_or_adults.ok ( 20), W("6")); CHECK( teens_or_adults.ok ( 60), W("7")); CHECK(!teens_or_adults.ok ( 10), W("8")); CHECK(!teens_or_adults.ok ( 61), W("9")); typedef CompositeConstraint<CompositeRangeInt, RangeConstraint<int>> Composite3RangeInt; Composite3RangeInt no_adults = (babies_or_kids || teen); CHECK( no_adults.ok ( 0), W("10")); CHECK( no_adults.ok ( 3), W("11")); CHECK( no_adults.ok ( 10), W("12")); CHECK( no_adults.ok ( 11), W("13")); CHECK( no_adults.ok ( 19), W("14")); CHECK(!no_adults.ok ( 20), W("15")); CHECK(!no_adults.ok ( 60), W("16")); CHECK(!no_adults.ok ( 61), W("17")); RangeConstraint<int> legal (18, 200); CHECK(!legal.ok(0), W("10")); CHECK(!legal.ok(3), W("11")); CHECK(!legal.ok(10), W("12")); CHECK(!legal.ok(11), W("13")); CHECK(legal.ok(19), W("14")); CHECK(legal.ok(20), W("15")); CHECK(legal.ok(60), W("16")); CHECK(legal.ok(61), W("17")); TEST_END (CompositeConstraints) } } </DOCUMENT>
<DOCUMENT filename="test\dir_util_test.cpp">
#ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <string> #include <vector> #include <algorithm> #include <iostream> #include <boost/test/unit_test.hpp> #include <filesystem_util.h> #include <io_util.h> #include "my_boost.hpp" using namespace std; using namespace boost::unit_test_framework; using namespace cpplib; const fs::path test_base_path = "dir_util_test_dir"; struct F { F() : d1(test_base_path / "dir1"), d2(test_base_path / "dir2"), d3(test_base_path / "dir3"), d4(test_base_path / "dir4"), d5(d4 / "dir5"), d6(d5 / "dir6"), p1(test_base_path / "file1"), p2(test_base_path / "file2"), p3(d1 / "file3"), p4(d2 / "file4"), p5(d6 / "file5") { if (fs::exists (test_base_path)) fs::remove_all (test_base_path); create_file<string> (p1, ""); create_file<string> (p2, ""); create_file<string> (p3, ""); create_file<string> (p4, ""); create_file<string> (p5, ""); fs::create_directory (d3); } ~F() { } fs::path d1; fs::path d2; fs::path d3; fs::path d4; fs::path d5; fs::path d6; fs::path p1; fs::path p2; fs::path p3; fs::path p4; fs::path p5; }; BOOST_FIXTURE_TEST_SUITE(dir_util_suite, F) BOOST_AUTO_TEST_CASE(get_files_test0) { vector<fs::path> expected; expected.push_back (p1); expected.push_back (p2); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); auto_ptr<vector<fs::path> > files2 = get_files (test_base_path, NO_FILTER, DO_NOT_INCLUDE_DIRS, NO_RECURSION); sort (files2->begin (), files2->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files2); } BOOST_AUTO_TEST_CASE(get_files_test1) { vector<fs::path> expected; expected.push_back (p1); expected.push_back (p2); expected.push_back (p3); expected.push_back (p4); expected.push_back (p5); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path, NO_FILTER, DO_NOT_INCLUDE_DIRS, RECURSIVE); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_CASE(get_files_test2) { vector<fs::path> expected; expected.push_back (p3); auto_ptr<vector<fs::path> > files = get_files (test_base_path, ".*3.*", DO_NOT_INCLUDE_DIRS, RECURSIVE); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_CASE(get_files_test3) { vector<fs::path> expected; expected.push_back (p3); expected.push_back (d3); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path, ".*3.*", INCLUDE_DIRS, RECURSIVE); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_CASE(get_files_test4) { vector<fs::path> expected; expected.push_back (p1); expected.push_back (p2); expected.push_back (p3); expected.push_back (p4); expected.push_back (p5); expected.push_back (d1); expected.push_back (d2); expected.push_back (d3); expected.push_back (d4); expected.push_back (d5); expected.push_back (d6); sort (expected.begin (), expected.end ()); auto_ptr<vector<fs::path> > files = get_files (test_base_path, NO_FILTER, INCLUDE_DIRS, RECURSIVE); sort (files->begin (), files->end ()); CHECK_EQUAL_COLLECTIONS (expected, *files); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\distance_test.cpp">
#ifndef DISTANCE_TEST_HPP #define DISTANCE_TEST_HPP #include <map> #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../distance.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(DistLev, true) using Pair = std::pair<S, S>; using Map = std::map<Pair, size_t>; Map map; map[Pair (W(""), W(""))] = 0; map[Pair (W(""), W("a"))] = 1; map[Pair (W("abc"), W("abd"))] = 1; map[Pair (W("abc"), W("ab"))] = 1; map[Pair (W("abc"), W("acb"))] = 1; map[Pair (W("abc"), W("a"))] = 2; map[Pair (W("abc"), W("acd"))] = 2; map[Pair (W("abc"), W("agg"))] = 2; map[Pair (W("Campeonato Inglês Arsenal x Liverpool"), W("Campeonato Ingles ArsenalxLiverpool"))] = 3; map[Pair (W("1234"), W("456"))] = 4; map[Pair (W("PLANETA EXPN: SURFE 2009"), W("PLANETA EXPN : AVENTURAS COM RENATA FALZONI"))] = 25; map[Pair (W("Copa América Masculino de Basquete: Brasil x Porto Rico"), W("Copa América (r) Masculino de Basquete -VT- Brasil x Porto Rico"))] = 10; map[Pair (W("copaamericamasculinodebasquetebrasilxportorico"), W("copaamericamasculinodebasqueteVTbrasilxportorico"))] = 2; size_t i = 0; for (const auto& it : map) { S s = it.first.first; S t = it.first.second; size_t result = distance (s, t); std::stringstream ss; ss << s << " " << t << " " << "i = " << i++; CHECK_EQ(size_t, result, it.second, ss.str ()); } TEST_END(DistLev) } } #endif </DOCUMENT>
<DOCUMENT filename="test\dummy-old.cpp">
#include "dummy.h" namespace pensar_digital { namespace cpplib { namespace test { bool operator== (const Dummy& left, const Dummy& right) { bool ok; ok = (left.s == right.s); ok = ok && (left.i == right.i); if (ok) ok = ok && (left.slist == right.slist); return ok; } } } } </DOCUMENT>
<DOCUMENT filename="test\dummy.cpp">
#include "dummy.hpp" #include "../s.hpp" namespace pensar_digital { namespace cpplib { } } </DOCUMENT>
<DOCUMENT filename="test\dummy.hpp">
 #ifndef DUMMY_HPP #define DUMMY_HPP #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../clone_util.hpp" #include "../factory.hpp" #include "../string_types.hpp" #include "../equal.hpp" #include <memory> namespace pensar_digital { namespace cpplib { class Dummy; #pragma warning( disable : 4250) typedef std::shared_ptr<Dummy> DummyPtr; class Dummy : public Object { private: struct Data : public pd::Data { CS<0, 20> mname; Data(const S& name = W("")) noexcept : mname(name) {} size_t data_size() const noexcept { return mname.length (); } }; Data mdata; public: using Ptr = std::shared_ptr<Dummy>; typedef pd::Factory<Dummy, Id, S> Factory; inline static Factory factory = {3, 10, NULL_ID, EMPTY}; inline static const Version::Ptr VERSION = pd::Version::get (1, 1, 1); virtual const pd::Data* data() const noexcept { return &mdata; } virtual size_t data_size() const noexcept { return mdata.data_size (); } Dummy(const Id& id = NULL_ID, const S& name = EMPTY) : Object(id), mdata(name) {} Dummy(const Dummy& d) : Object(d), mdata (d.mdata.mname) { } Dummy(Dummy&& d) noexcept : Object(d) { assign (d); } inline static Factory::P get(const Id& aid = NULL_ID, const S& aname = EMPTY) { return factory.get(aid, aname); } inline Factory::P clone () const noexcept { return get(id (), get_name ()); } inline Factory::P clone(const DummyPtr& ptr) { return ptr->clone (); } Dummy& operator = (const Dummy& d) noexcept { assign(d); return *this; } Dummy& operator = (Dummy&& d) noexcept { assign(d); return *this; } using Object::operator ==; using Object::operator !=; virtual ~Dummy() {} virtual S class_name() const noexcept { return Object::class_name (); } virtual void set_id(const Id& aid) noexcept { Object::set_id(aid); } virtual bool initialize(const Id& aid = NULL_ID, const S& name = W("")) noexcept { Object::set_id(aid); mdata.mname = name; return true; } virtual bool equals(const Object& o) const noexcept { return (equal<const Dummy>(*this, *dynamic_cast<const Dummy*>(&o))); } /*virtual std::istream& binary_read(std::istream& is, const std::endian& byte_order = std::endian::native) { Object::binary_read(is, byte_order); read_bin_version(is, *VERSION, byte_order); is.read((char*)data(), data_size()); return is; } virtual std::ostream& binary_write(std::ostream& os, const std::endian& byte_order = std::endian::native) const { Object::binary_write (os, byte_order); VERSION->binary_write(os, byte_order); os.write((const char*)data(), data_size()); return os; } */ virtual S get_name() const noexcept { return mdata.mname; } void set_name(const S& aname) noexcept { mdata.mname = aname; } virtual S to_string() const noexcept { return Object::to_string () + W(" ") + mdata.mname.to_string (); } operator S () const noexcept { return to_string(); } virtual S debug_string() const noexcept { return Object::debug_string() + W(" name = ") + mdata.mname; } }; inline InStream& operator >> (InStream& is, Dummy& o) { return o.read (is); } inline OutStream& operator << (OutStream& os, const Dummy& o) { return o.write (os); } } } #endif </DOCUMENT>
<DOCUMENT filename="test\dummy_factory.cpp">
#include "dummy_factory.hpp" </DOCUMENT>
<DOCUMENT filename="test\dummy_factory.hpp">
 #ifndef DUMMY_FACTORY_HPP #define DUMMY_FACTORY_HPP #include "../factory.hpp" #include "dummy.hpp" namespace pensar_digital { namespace cpplib { class DummyFactory2 : public Factory<Dummy, Id, S> { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); DummyFactory2(const Id& aid = NULL_ID, const S& aname = W("")) : Factory<Dummy, Id, S>(3, 10, aid, aname) { }; virtual ~DummyFactory2() { }; using P = Factory<Dummy, Id, S>::P; virtual P get(const Id& aid = NULL_ID, const S& aname = W("")) { return Factory<Dummy, Id, S>::get(aid, aname); }; P clone (const Dummy& adummy) { return get (adummy.id (), adummy.get_name ()); }; P clone(const DummyPtr& ptr) { return clone (*ptr);} }; extern DummyFactory2 dummyf; } } #endif </DOCUMENT>
<DOCUMENT filename="test\factory_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../factory.hpp" #include "../s.hpp" #include "../object.hpp" #include <memory> namespace pensar_digital { using namespace pensar_digital::cpplib; namespace unit_test { TEST(NewFactory, true) { std::vector<Object::Ptr> v; v.push_back (std::make_shared<Object>(1)); CHECK(v[0].use_count() == 1, W("0. use_count() should be 1 but is ") + pd::to_string((int)v[0].use_count())); Object::Ptr ptr = v[0]; CHECK(ptr.use_count() == 2, W("1. use_count() should be 2 but is ") + pd::to_string((int)ptr.use_count())); NewFactory <Object> factory; Object::Ptr o = factory.get (); NewFactory <Object, pd::Id> factory1; Object::Ptr o1 = factory1.get (1); CHECK(*o != *o1, W("0. o != o1 should be true")); o.reset(); CHECK(o.get () == nullptr, W("1. managed object should have been deleted and assigned to nullptr.")); } TEST_END(NewFactory) TEST(SingletonFactory, true) { SingletonFactory <Object, pd::Id> factory (1); Object::Ptr o = factory.get (1); Object::Ptr o1 = factory.get (1); CHECK(*o == *o1, W("0. o == o1 should be true.")); o.reset(); CHECK(o.get () == nullptr, W("1. managed object should have been deleted and assigned to nullptr.")); } TEST_END(SingletonFactory) TEST(MockupFactory, true) { Object* mockup = new Object (1); MockupFactory<Object, pd::Id> factory (mockup); Object::Ptr o = factory.get (1); CHECK(*o == *mockup, W("0. o == mockup should be true.")); } TEST_END(MockupFactory) TEST(PoolFactory, true) { PoolFactory<Object, Object::DataType> factory (3, 10, {1}); { size_t count = factory.get_available_count(); Object::Ptr ptr; for (size_t i = 0; i < count; i++) { ptr = factory.get({1}); CHECK(factory.get_available_count () == factory.get_pool_size () - i - 1, W("0.")); } CHECK(factory.get_available_count() == 0, W("0.1. available_count should be 0 but is ") + pd::to_string((int)factory.get_available_count())); } factory.reset(3, 10, 0); CHECK(factory.get_available_count() == 3, W("1. available_count should be 3 but is ") + pd::to_string((int)factory.get_available_count ())); Object::Ptr o = factory.get ({ 1 }); CHECK(o->id () == 1, W("0. o->id () should be 1 but is ") + pd::to_string((int)o->id ())) CHECK(factory.get_available_count() == 2, W("2. available_count should be 2.")); Object::Ptr o1 = factory.get({ 2 }); CHECK(o1->id() == 2, W("3. o1->id () should be 2 but is ") + pd::to_string((int)o->id())) CHECK(factory.get_available_count() == 1, W("4. available_count should be 1.")); Object::Ptr o2 = factory.get({ 3 }); CHECK(o2->id() == 3, W("5. o2->id () should be 3 but is ") + pd::to_string((int)o->id())) CHECK(factory.get_available_count() == 0, W("6. available_count should be 0.")); Object::Ptr o3 = factory.get({ 4 }); CHECK(factory.get_available_count() == 9, W("7. available_count should be 9 but is ") + pd::to_string((int)factory.get_available_count())); CHECK(o3->id() == 4, W("8. o3->id () should be 4 but is ") + pd::to_string((int)o->id())) CHECK(*o != *o1, W("9. *o != *o1 should be true.")); o.reset(); CHECK(o.get () == nullptr, W("10. managed object should have been deleted and assigned to nullptr.")); } TEST_END(PoolFactory) } } </DOCUMENT>
<DOCUMENT filename="test\file_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../file.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(RandomFileNameGenerator, true) RandomFileNameGenerator r; Path p = r (); CHECK_EQ(Path, p.parent_path(), TMP_PATH.copy_without_trailing_separator(), W("0")); S filename = p.filename_only().str(); CHECK_EQ(S, p.extension(), W(".txt"), W("1")); CHECK_EQ(size_t, filename.length (), 8, W("2")); CHECK(filename.find_first_not_of (W("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")) == S::npos, W("3")); CHECK(filename.find_first_of (W("0123456789")) != 0, W("4")); TEST_END(RandomFileNameGenerator) TEST(TextFile, true) Path p; { p = TMP_PATH / W("text-file-test.txt"); TmpTextFile file(p, W("blah")); p = file.fullpath (); CHECK(file.exists(), W("0")); S s = file.read(); CHECK_EQ(S, s, W("blah"), W("1")); CHECK(file.remove(), W("2")); } CHECK(! p.exists(), W("0")); TEST_END(TextFile) } } </DOCUMENT>
<DOCUMENT filename="test\fixed_columns_parser_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "fixed_columns_parser.h" #include <boost/fusion/include/at_c.hpp> #include <cmath> using namespace std; namespace cpp = pensar_digital::cpplib; using namespace boost::fusion; const string line = "15213MARCOS DA SILVA BRASILEIRO RUA RUA RUA RUA RUA RU 765 APTO 23 POMPEIA SAO PAULO SP 05617000 "; BOOST_AUTO_TEST_SUITE(fixed_columns_parser_suite) BOOST_AUTO_TEST_CASE(parse_test) { cpp::FixedColumnsParser<int, string, int> parser (4, 10, 2); cpp::FixedColumnsParser<int, string, int>::ParseResult r = parser.parse("0123abcdefgh 18"); BOOST_CHECK_EQUAL (123, at_c<0>(r)); BOOST_CHECK_EQUAL ("abcdefgh ", at_c<1>(r)); BOOST_CHECK_EQUAL (18, at_c<2>(r)); typedef cpp::FixedColumnsParser<char, short, int, long, long long, float, double, long double, string, bool> Parser; Parser parser2 (1, 1, 1, 1, 1, 1, 1, 5, 3, 1); Parser::ParseResult r2 = parser2.parse("01234567.777abc0"); BOOST_CHECK_EQUAL ('0', at_c<0>(r2)); BOOST_CHECK_EQUAL (1, at_c<1>(r2)); BOOST_CHECK_EQUAL (2, at_c<2>(r2)); BOOST_CHECK_EQUAL (3L, at_c<3>(r2)); BOOST_CHECK_EQUAL ((long long)4L, at_c<4>(r2)); BOOST_CHECK_EQUAL (5.0f, at_c<5>(r2)); BOOST_CHECK_EQUAL ((double)6.0, at_c<6>(r2)); BOOST_CHECK_CLOSE ((long double)7.777, at_c<7>(r2), 0.000001); BOOST_CHECK_EQUAL ("abc", at_c<8>(r2)); BOOST_CHECK_EQUAL (false, at_c<9>(r2)); } BOOST_AUTO_TEST_CASE(parse_error) { cpp::FixedColumnsParser<int, int> parser (2, 2); bool ok = false; try { parser.parse ("11ab"); } catch (cpp::ParserException& e) { ok = true; BOOST_CHECK_EQUAL (1, e.err_column); } catch (...) {} if (! ok) BOOST_FAIL ("It was supposed to throw a ParserException exception."); } BOOST_AUTO_TEST_CASE (parse_stream_test) { const char* file_name = "FixedColumnsParser_test_file.txt"; ofstream out (file_name); out << "gato01\npato02\nsapo03"; out.close (); cpp::FixedColumnsParser<string, int> parser (4, 2); ifstream in (file_name); cpp::FixedColumnsParser<string, int>::ParseStreamResult r = parser.parse (in); in.close (); BOOST_CHECK_EQUAL ((unsigned)3, r.size () ); BOOST_CHECK_EQUAL ("gato", at_c<0> (r[0])); BOOST_CHECK_EQUAL (1, at_c<1> (r[0])); BOOST_CHECK_EQUAL ("pato", at_c<0> (r[1])); BOOST_CHECK_EQUAL (2, at_c<1> (r[1])); BOOST_CHECK_EQUAL ("sapo", at_c<0> (r[2])); BOOST_CHECK_EQUAL (3, at_c<1> (r[2])); } BOOST_AUTO_TEST_CASE (parse_file_error_test) { cpp::FixedColumnsParser<string, int> parser (4, 2); const char* file_name = "FixedColumnsParser_test_file.txt"; ofstream out (file_name); out << "gato01\nato02\nsapo03"; out.close (); bool ok = false; try { parser.parse_file (file_name); } catch (cpp::ParserException& e) { ok = true; BOOST_CHECK_EQUAL (1, e.err_line); BOOST_CHECK_EQUAL ("The line 'ato02' was supposed to have 6 chars but it has 5 instead.", e.err_message); } catch (...) {} if (! ok) BOOST_FAIL ("It was supposed to throw a ParserException exception."); } BOOST_AUTO_TEST_CASE (parse_file_test) { const char* file_name = "FixedColumnsParser_test_file.txt"; ofstream out (file_name); out << "gato01\npato02\nsapo03"; out.close (); cpp::FixedColumnsParser<string, int> parser (4, 2); cpp::FixedColumnsParser<string, int>::ParseStreamResult r = parser.parse_file (file_name); BOOST_CHECK_EQUAL ((unsigned)3, r.size () ); BOOST_CHECK_EQUAL ("gato", at_c<0> (r[0])); BOOST_CHECK_EQUAL (1, at_c<1> (r[0])); BOOST_CHECK_EQUAL ("pato", at_c<0> (r[1])); BOOST_CHECK_EQUAL (2, at_c<1> (r[1])); BOOST_CHECK_EQUAL ("sapo", at_c<0> (r[2])); BOOST_CHECK_EQUAL (3, at_c<1> (r[2])); } BOOST_AUTO_TEST_CASE (parse_12_args_test) { typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); PropayParser::ParseResult r = parser.parse (line); BOOST_CHECK_EQUAL (15213, at_c<0> (r)); BOOST_CHECK_EQUAL ("MARCOS DA SILVA BRASILEIRO ", at_c<1> (r)); BOOST_CHECK_EQUAL ("RUA RUA RUA RUA RUA RU ", at_c<2> (r)); BOOST_CHECK_EQUAL ("765 ", at_c<3> (r)); BOOST_CHECK_EQUAL ("APTO 23 ", at_c<4> (r)); BOOST_CHECK_EQUAL ("POMPEIA ", at_c<5> (r)); BOOST_CHECK_EQUAL ("SAO PAULO ", at_c<6> (r)); BOOST_CHECK_EQUAL ("SP ", at_c<7> (r)); BOOST_CHECK_EQUAL ("05617000 ", at_c<8> (r)); BOOST_CHECK_EQUAL (" ", at_c<9> (r)); } BOOST_AUTO_TEST_CASE (parse_trim_test) { typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; PropayParser::ParseResult r = parser.parse (line); BOOST_CHECK_EQUAL (15213, at_c<0> (r)); BOOST_CHECK_EQUAL ("MARCOS DA SILVA BRASILEIRO", at_c<1> (r)); BOOST_CHECK_EQUAL ("RUA RUA RUA RUA RUA RU", at_c<2> (r)); BOOST_CHECK_EQUAL ("765", at_c<3> (r)); BOOST_CHECK_EQUAL ("APTO 23", at_c<4> (r)); BOOST_CHECK_EQUAL ("POMPEIA", at_c<5> (r)); BOOST_CHECK_EQUAL ("SAO PAULO", at_c<6> (r)); BOOST_CHECK_EQUAL ("SP", at_c<7> (r)); BOOST_CHECK_EQUAL ("05617000", at_c<8> (r)); BOOST_CHECK_EQUAL ("", at_c<9> (r)); } BOOST_AUTO_TEST_CASE (parse_pad_test) { string line2 = "15213MARCOS DA SILVA BRASILEIRO RUA RUA RUA RUA RUA RU 765 APTO 23 POMPEIA SAO PAULO SP 05617000"; typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; PropayParser::ParseResult r = parser.parse (line2, true); BOOST_CHECK_EQUAL (15213, at_c<0> (r)); BOOST_CHECK_EQUAL ("MARCOS DA SILVA BRASILEIRO", at_c<1> (r)); BOOST_CHECK_EQUAL ("RUA RUA RUA RUA RUA RU", at_c<2> (r)); BOOST_CHECK_EQUAL ("765", at_c<3> (r)); BOOST_CHECK_EQUAL ("APTO 23", at_c<4> (r)); BOOST_CHECK_EQUAL ("POMPEIA", at_c<5> (r)); BOOST_CHECK_EQUAL ("SAO PAULO", at_c<6> (r)); BOOST_CHECK_EQUAL ("SP", at_c<7> (r)); BOOST_CHECK_EQUAL ("05617000", at_c<8> (r)); BOOST_CHECK_EQUAL ("", at_c<9> (r)); } BOOST_AUTO_TEST_CASE (performance_trim_test) { typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; for (int i = 0; i < 10000; i++) { PropayParser::ParseResult r = parser.parse (line); } } BOOST_AUTO_TEST_CASE (performance_pad_test) { string line2 = "15213MARCOS DA SILVA BRASILEIRO RUA RUA RUA RUA RUA RU 765 APTO 23 POMPEIA SAO PAULO SP 05617000"; typedef cpp::FixedColumnsParser<int, string, string, string, string, string, string, string, string, string, string, string> PropayParser; PropayParser parser (5, 48, 41, 6, 23, 23, 23, 5, 9, 10, 20, 4); parser.trim_data = true; for (int i = 0; i < 10000; i++) { PropayParser::ParseResult r = parser.parse (line2, true); } } BOOST_AUTO_TEST_SUITE_END() </DOCUMENT>
<DOCUMENT filename="test\generator_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../generator.hpp" #include "../memory_buffer.hpp" #include "../trivially_persistable_memory_buffer.hpp" #include "../concept.hpp" #include <sstream> namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Get, true) Generator<int> g; Id expected = 1; CHECK_EQ(Id, g.get_id (), expected++, W("0")); CHECK_EQ(Id, g.get_id (), expected++, W("1")); Generator<> g2(1, 1, 2); expected = 3; CHECK_EQ(Id, g2.get_id (), expected, W("2")); expected = 5; CHECK_EQ(Id, g2.get_id (), expected, W("3")); TEST_END(Get) TEST(GetNext, true) Generator<int> g; Id expected = 1; CHECK_EQ(Id, g.next(), expected, W("0")); CHECK_EQ(Id, g.next(), expected, W("1")); Generator<> g2(1, 1, 2); expected = 3; CHECK_EQ(Id, g2.next(), expected, W("2")); CHECK_EQ(Id, g2.next(), expected, W("3")); TEST_END(GetNext) TEST(GetCurrent, true) Generator<int> g; Id expected = 0; CHECK_EQ(Id, g.current(), expected, W("0")); CHECK_EQ(Id, g.get_id () , ++expected, W("1")); CHECK_EQ(Id, g.current(), expected, W("2")); Generator<> g2(1, 1, 2); expected = 1; CHECK_EQ(Id, g2.current(), expected, W("4")); CHECK_EQ(Id, g2.get_id () , 3, W("5")); CHECK_EQ(Id, g2.current(), 3, W("6")); TEST_END(GetCurrent) TEST(SetValue, true) Generator<int> g; g.set_value (10); Id expected = 10; CHECK_EQ(Id, g.current (), 10, W("0")); CHECK_EQ(Id, g.get_id () , ++expected, W("1")); TEST_END(SetValue) TEST(SetStep, true) Generator<int> g (1, 0, 2); Id expected = 0; CHECK_EQ(Id, g.current (), expected, W("0")); CHECK_EQ(Id, g.get_id () , 2, W("1")); CHECK_EQ(Id, g.get_id () , 4, W("2")); TEST_END(SetStep) TEST(GeneratorSerialization, false) using G = Generator<int>; G g; MemoryBuffer::Ptr mb = g.bytes (); G g2 (1); CHECK_NOT_EQ(G, g2, g, W("0")); g2.assign(*mb); CHECK_EQ(G, g2, g, W("1")); TEST_END(GeneratorSerialization) TEST(GeneratorFileBinaryStreaming, false) std::ofstream out(W("c:\\tmp\\test\\GeneratorFileBinaryStreaming\\file_binary_streaming_test.bin"), std::ios::binary); typedef Generator<Object> G; typedef std::shared_ptr<G> GP; G g(1); g.binary_write(out); out.close (); out.flush (); std::ifstream in(W("c:\\tmp\\test\\GeneratorFileBinaryStreaming\\file_binary_streaming_test.bin"), std::ios::binary); GP pg2 = G::get (1); pg2->binary_read (in); in.close(); G g3(3); CHECK_NOT_EQ(G, g3, g, W("0")); CHECK_EQ(G, *pg2, g, W("1")); CHECK_EQ(VersionInt, pg2->version()->get_private (), 2, W("2")); TEST_END(GeneratorFileBinaryStreaming) TEST(GeneratorBinaryStreaming, false) typedef Generator<Object> G; static_assert (Identifiable <G>); static_assert (Hashable<G>); static_assert (TriviallyCopyable <G::DataType>); static_assert (TriviallyCopyable <G::DataType>); static_assert (TriviallyPersistable<G>); TriviallyPersistableMemoryBuffer<G> buffer; G g(1); Id id = g.get_id (); buffer.write_obj (g); Hash h = g.hash (); G::Factory::P p2 = buffer.read_obj (1); G g2 (1); Hash h2 = g2.hash (); CHECK_NOT_EQ(G, g2, g, W("0")); CHECK_EQ(G, *p2, g, "1"); G::Factory::P p3 = buffer.write_obj <Id, Id, Id>(3, 2, 1); G::Factory::P p4 = nullptr; buffer.read_obj (&p4); CHECK_EQ(G, *p4, *p3, "2"); TEST_END(GeneratorBinaryStreaming) } } </DOCUMENT>
<DOCUMENT filename="test\io_util_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../io_util.hpp" #include "../sys_user_info.hpp" #include "../file.hpp" #include <memory> namespace pensar_digital { using namespace pensar_digital::unit_test; namespace cpplib { TEST(PathTest, true) Path temp_dir = get_user_home<true>() / W("test_dir"); Path file1 = temp_dir / W("file_name"); Path file2 = temp_dir / W("dir" / "file_name"); TextFile tf(file1, W("blah")); CHECK(tf.exists(), W("0")); TextFile tf2(file2, W("blah")); CHECK(tf2.exists(), W("0")); fs::last_write_time (file2, last_write_time (file1)); /*fs::last_write_time(file2, last_write_time(file1) + (time_t)60); BOOST_CHECK (! cpp::is_same (file1, file2)); Path file3 = temp_dir / "file_name3"; cpp::create_file (file3, "blah"); BOOST_CHECK (cpp::is_same (file1, file3, cpp::SAME_SIZE + cpp::SAME_TIME)); */ TEST_END(PathTest) } } </DOCUMENT>
<DOCUMENT filename="test\object_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../s.hpp" #include "../object.hpp" #include "../io_util.hpp" #include "../file.hpp" #include "../test/dummy.hpp" #include <memory> #include <fstream> #ifdef _MSC_VER #include <filesystem> #else #include <experimental/filesystem> #endif namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(ObjectClone, true) Factory::P o = pd::Object::get(42); Factory::P o1 = o->clone (); CHECK(*o == *o1,W("0. o == o1 should be true")); Dummy::Ptr d = Dummy::get (42,W("d")); Dummy::Ptr d1 = d->clone(); static_assert(OutputStreamable<Dummy>); CHECK_EQ(Dummy, *d1, *d,W("1. d != d1")); TEST_END(ObjectClone) TEST(ObjectSerialization, true) auto o = pd::Object::get(42); MemoryBuffer::Ptr mb = *o; auto o1 = pd::Object::get(); CHECK_NOT_EQ(Object, *o, *o1, W("0. o == o1")); o1->object_assign (*mb); CHECK_EQ(Object, *o, *o1, W("1. o != o1")); mb->reset_read_offset(); auto o2 = pd::Object::get(*mb); CHECK_EQ(Object, *o, *o2, W("1. o != o1")); TEST_END(ObjectSerialization) TEST(ObjectBinaryFileStreaming, true) std::vector<Object::Ptr> objects; const Id N = 1000; for (Id i = 0; i < N; i++) { objects.push_back(pd::Object::get(i)); } std::ofstream out (W ("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { objects[i]->bin_write(out); } out.close(); std::ifstream in (W("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { Object::Ptr o = pd::Object::get(); o->bin_read(in); Object::Ptr o1 = pd::Object::get(i); CHECK_EQ(Object, *o, *o1, pd::to_string(i)); } TEST_END(ObjectBinaryFileStreaming) TEST(ObjectBinaryFileStreaming2, true) std::vector<Object::Ptr> objects; const Id N = 1000; for (Id i = 0; i < N; i++) { objects.push_back(pd::Object::get(i)); } std::ofstream out(W("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { MemoryBuffer::Ptr mb = objects[i]->bytes(); out.write((const char*)mb->data(), mb->size()); } out.close(); std::ifstream in(W("c:\\tmp\\test\\ObjectBinaryFileStreaming\\test.bin"), std::ios::binary); for (Id i = 0; i < N; i++) { MemoryBuffer mb(Object::SIZE); mb.write (in, mb.size()); Object o(mb); Object::Ptr o1 = pd::Object::get(i); CHECK_EQ(Object, o, *o1, pd::to_string(i)); } TEST_END(ObjectBinaryFileStreaming2) } } </DOCUMENT>
<DOCUMENT filename="test\odb\ODBTest.cpp">
 #include <string> #include <boost/test/unit_test.hpp> #include "filesystem_util.h" #include "io_util.h" #include "my_boost.hpp" #include "ODB.hpp" #include "string_util.hpp" using namespace boost::unit_test_framework; namespace cpp = pensar_digital::cpplib; namespace odb = pensar_digital::odb; class OdbDummy { public: OdbDummy (int aid, const std::string& aname, const std::string& aother): id(aid), name(aname), other(aother) {}; std::string search_string () { return cpp::to_string(id) + "," + name + "," + other; } private: int id; std::string name; std::string other; }; BOOST_AUTO_TEST_SUITE(odb_suite) BOOST_AUTO_TEST_CASE(constructor_test) { namespace fs = boost::filesystem; fs::path dbfile("test_db"); odb::ODB<std::string> db; } BOOST_AUTO_TEST_CASE(add_test) { std::string s1 = "asdfçlkj"; std::string s2 = "asdkkk"; std::string s3 = "kj123"; odb::ODB<std::string> db; db.add (s1, &s1); db.add (s2, &s2); db.add (s3, &s3); odb::ODB<std::string>::ResultSet r; BOOST_CHECK (db.contains ("kj", r)); BOOST_CHECK_EQUAL(unsigned(2), r.size()); BOOST_CHECK (db.contains ("k", r)); BOOST_CHECK_EQUAL(unsigned(3), r.size()); BOOST_CHECK (db.contains ("ç", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); } BOOST_AUTO_TEST_CASE(contains_test) { odb::ODB<OdbDummy> db; OdbDummy d1 (1, "d1", "other1"); db.add (d1.search_string(), &d1); odb::ODB<OdbDummy>::ResultSet r; BOOST_CHECK(db.contains ("d1", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); OdbDummy d2 (2, "a rather long name for this object", ""); db.add (d2.search_string(), &d2); db.add (d2.search_string(), &d2); BOOST_CHECK(db.contains ("long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(! db.contains ("longa", r)); BOOST_CHECK_EQUAL(unsigned(0), r.size()); BOOST_CHECK(db.contains ("Lõng", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); OdbDummy d3 (3, "a rather long name for this objec", ""); OdbDummy d4 (4, "a rather long name for this obje", ""); OdbDummy d5 (5, "a rather long name for this obj", ""); db.add (d3.search_string(), &d3); db.add (d4.search_string(), &d4); db.add (d5.search_string(), &d5); BOOST_CHECK(db.contains ("a rather long name for this object", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(db.contains ("a rather long name for this objec", r)); BOOST_CHECK_EQUAL(unsigned(2), r.size()); BOOST_CHECK(db.contains ("a rather long name for this obje", r)); BOOST_CHECK_EQUAL(unsigned(3), r.size()); BOOST_CHECK(db.contains ("a rather long name for this obj", r)); BOOST_CHECK_EQUAL(unsigned(4), r.size()); } BOOST_AUTO_TEST_CASE(case_insensitive_test) { typedef odb::ODB<OdbDummy, std::string, odb::case_insensitive_hash<>, odb::case_insensitive_equal_to<>> DB; DB db; OdbDummy d2 (2, "a rather long name for this object", ""); db.add (d2.search_string(), &d2); typename DB::ResultSet r; BOOST_CHECK(db.contains ("long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(db.contains ("Long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); } BOOST_AUTO_TEST_CASE(no_accents_test) { typedef odb::ODB<OdbDummy, std::string, odb::no_accents_hash<>, odb::no_accents_equal_to<>> DB; DB db; OdbDummy d2 (2, "a rather long name for this object", ""); db.add (d2.search_string(), &d2); typename DB::ResultSet r; BOOST_CHECK(db.contains ("long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(db.contains ("lóng", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); } BOOST_AUTO_TEST_CASE(case_insensitive_no_accents_test) { typedef odb::ODB<OdbDummy, std::string, odb::case_insensitive_no_accents_hash<std::string>, odb::case_insensitive_no_accents_equal_to<std::string>> DB; DB db; OdbDummy d2 (2, "a rather long name for this object", ""); db.add (d2.search_string(), &d2); typename DB::ResultSet r; BOOST_CHECK(db.contains ("long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(db.contains ("Lóng", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); } BOOST_AUTO_TEST_CASE(default_hash_test) { typedef odb::ODB<OdbDummy> DB; DB db; OdbDummy d2 (2, "a rather long name for this object", ""); db.add (d2.search_string(), &d2); typename DB::ResultSet r; BOOST_CHECK(db.contains ("long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(db.contains ("Lóng", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); } BOOST_AUTO_TEST_CASE(case_sensitive_accents_test) { typedef odb::ODB<OdbDummy, std::string, std::hash<std::string>, std::equal_to<std::string>> DB; DB db; OdbDummy d2 (2, "a rather long name for this object", ""); db.add (d2.search_string(), &d2); typename DB::ResultSet r; BOOST_CHECK(db.contains ("long", r)); BOOST_CHECK_EQUAL(unsigned(1), r.size()); BOOST_CHECK(! db.contains ("Long", r)); BOOST_CHECK_EQUAL(unsigned(0), r.size()); BOOST_CHECK(! db.contains ("lóng", r)); BOOST_CHECK_EQUAL(unsigned(0), r.size()); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\path_test.cpp">
 #include "..\unit-test\test\test.hpp" #include "../cpplib/cpp namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Path, true) static_assert (TriviallyCopyable<CPath>); Path path; CHECK_EQ (Path, path, CURRENT_DIR, W("0")); path = W("\\\\"); CHECK_EQ (Path, path, path.root_path (), W("1")); path = W("c:\\tmp\\test\\path_test\\"); path.remove(); CHECK(!path.exists(), W("2")); path.create_dir (); CHECK(path.exists(), W("3")); CHECK(!path.has_filename (), W("4")); path += W("\\path_test.txt"); CHECK(path.has_filename (), W("5")); fs::remove (path); CHECK(!path.exists(), W("6")); Path path2 = path.filename (); CHECK_EQ (Path, path2, W("path_test.txt"), W("7")); path2 = path.parent_path (); CHECK_EQ (Path, path2, W("c:\\tmp\\test\\path_test"), W("8")); path2.remove (); TEST_END(Path) } } </DOCUMENT>
<DOCUMENT filename="test\random_util_test.cpp">
 #include <cmath> #include <boost/test/unit_test.hpp> #include "../random_util.hpp" #include "../log.hpp" namespace cpp = pensar_digital::cpplib; BOOST_AUTO_TEST_SUITE(random_util_suite) BOOST_AUTO_TEST_CASE(random_test) { cpp::CRandom r(0, 9); int a[10]; for (unsigned i = 0; i < 10; ++i) a[i] = 0; for (unsigned i = 0; i < 10000; ++i) { unsigned u = r.get (); a[u]++; } double variance = 0.0; for (unsigned i = 0; i < 10; ++i) { variance += pow(a[i] - 1000, 2); } variance /= 10; double standard_deviation = sqrt (variance); BOOST_CHECK (standard_deviation < 50); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\serialization_test.cpp">
#ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "serialization.hpp" #include "dummy.h" namespace cpp = pensar_digital::cpplib; namespace ser = cpp::serialization; namespace tst = cpp::test; BOOST_AUTO_TEST_SUITE(serialization_suite) BOOST_AUTO_TEST_CASE(serialization_test) { std::vector<std::string> v; v.push_back ("a@a.com"); v.push_back ("b@a.com"); v.push_back ("c@a.com"); tst::Dummy d ("teste", 1, v); std::string s; int i = 5; s = ser::to_string<int>(i); BOOST_CHECK_EQUAL (i, ser::from_string<int>(s)); s = ser::to_string<tst::Dummy>(d); tst::Dummy d2 = ser::from_string<tst::Dummy>(s); if (d == d2) BOOST_CHECK (1); else BOOST_CHECK (0); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\sorted_list_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../sorted_list.hpp" #include <cwctype> #include <clocale> namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { struct Descending { bool operator()(int a, int b) const { return a > b; } }; struct CaseInsensitive { bool operator()(const S& a, const S& b) const { S a_lower = a; S b_lower = b; #ifdef WIDE_CHAR std::transform(a_lower.begin(), a_lower.end(), a_lower.begin(), [](C c) { return std::towlower(c); }); std::transform(b_lower.begin(), b_lower.end(), b_lower.begin(), [](C c) { return std::towlower(c); }); #else std::transform(a_lower.begin(), a_lower.end(), a_lower.begin(), [](C c) { return std::tolower(c); }); std::transform(b_lower.begin(), b_lower.end(), b_lower.begin(), [](C c) { return std::tolower(c); }); #endif return a_lower < b_lower; } }; TEST(SortedList, true) std::setlocale(LC_ALL, "C"); SortedList<int> sl = {}; CHECK_EQ(int, sl.size(), 0, W("0: Default constructor size")); CHECK_EQ(bool, sl.is_unique(), false, W("1: Default constructor not unique")); sl.add(2); CHECK_EQ(int, sl.size(), 1, W("2: Size after adding one element")); CHECK_EQ(int, sl[0], 2, W("3: Element at index 0")); sl.add(0); CHECK_EQ(int, sl.size(), 2, W("4: Size after adding second element")); CHECK_EQ(int, sl[0], 0, W("5: Element at index 0 after sorting")); CHECK_EQ(int, sl[1], 2, W("6: Element at index 1 after sorting")); sl.add(1); CHECK_EQ(int, sl.size(), 3, W("7: Size after adding third element")); CHECK_EQ(int, sl[1], 1, W("8: Element at index 1 after sorting")); SortedList<int, Descending> desc_sl({ 3, 1, 4, 1, 5 }, false, Descending{}); CHECK_EQ(int, desc_sl.size(), 5, W("9: Descending list size")); CHECK_EQ(int, desc_sl[0], 5, W("10: Descending list first element")); CHECK_EQ(int, desc_sl[1], 4, W("11: Descending list second element")); CHECK_EQ(int, desc_sl[2], 3, W("12: Descending list third element")); CHECK_EQ(int, desc_sl[3], 1, W("13: Descending list fourth element")); CHECK_EQ(int, desc_sl[4], 1, W("14: Descending list fifth element")); CHECK_EQ(bool, desc_sl.add(2), true, W("15: Add 2 to descending list")); CHECK_EQ(int, desc_sl.size(), 6, W("16: Size after adding to descending list")); CHECK_EQ(int, desc_sl[3], 2, W("17: Element at index 3 after adding 2")); auto it = sl.find(1); CHECK_EQ(int, it != sl.end() ? *it : -1, 1, W("18: Find existing element")); it = sl.find(99); CHECK_EQ(bool, it == sl.end(), true, W("19: Find non-existing element")); CHECK_EQ(bool, sl.contains(2), true, W("20: Contains existing element")); CHECK_EQ(bool, sl.contains(99), false, W("21: Contains non-existing element")); CHECK_EQ(bool, sl.remove(1), true, W("22: Remove existing element")); CHECK_EQ(int, sl.size(), 2, W("23: Size after remove")); CHECK_EQ(bool, sl.contains(1), false, W("24: Element removed")); CHECK_EQ(bool, sl.remove(99), false, W("25: Remove non-existing element")); sl.remove_at(0); CHECK_EQ(int, sl.size(), 1, W("26: Size after remove_at")); CHECK_EQ(int, sl[0], 2, W("27: Element after remove_at")); int expected[] = { 2 }; int i = 0; for (const auto& item : sl) { CHECK_EQ(int, item, expected[i], W("28: Iterator element at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 1, W("29: Iterator count")); i = 0; for (const auto& item : sl.as_range()) { CHECK_EQ(int, item, expected[i], W("30: Range element at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 1, W("31: Range count")); sl.clear(); CHECK_EQ(int, sl.size(), 0, W("32: Size after clear")); CHECK_EQ(bool, sl.empty(), true, W("33: Empty after clear")); bool exception_thrown = false; try { sl[0]; } catch (const std::out_of_range&) { exception_thrown = true; } CHECK_EQ(bool, exception_thrown, true, W("34: operator[] throws on empty list")); exception_thrown = false; try { sl.at(0); } catch (const std::out_of_range&) { exception_thrown = true; } CHECK_EQ(bool, exception_thrown, true, W("35: at throws on empty list")); desc_sl.clear(); desc_sl.add(3); desc_sl.add(2); desc_sl.add(1); int rev_expected[] = { 1, 2, 3 }; i = 0; for (auto it = desc_sl.rbegin(); it != desc_sl.rend(); ++it) { CHECK_EQ(int, *it, rev_expected[i], W("36: Reverse iterator element at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 3, W("37: Reverse iterator count")); CHECK_EQ(bool, desc_sl.comparator()(5, 3), true, W("38: Comparator check (5 > 3)")); CHECK_EQ(int, desc_sl[0], 3, W("39: Descending list operator[] at index 0")); CHECK_EQ(int, desc_sl[1], 2, W("40: Descending list operator[] at index 1")); CHECK_EQ(int, desc_sl[2], 1, W("41: Descending list operator[] at index 2")); SortedList<int> asc_sl2 = {}; asc_sl2.add(5); asc_sl2.add(2); asc_sl2.add(8); asc_sl2.add(1); int asc_expected[] = { 1, 2, 5, 8 }; i = 0; for (const auto& item : asc_sl2) { CHECK_EQ(int, item, asc_expected[i], W("42: Ascending order after multiple adds at index ") + std::to_string(i)); ++i; } CHECK_EQ(int, i, 4, W("43: Ascending order count")); SortedList<S, CaseInsensitive> str_sl({ W("Apple"), W("banana"), W("date") }, false, CaseInsensitive{}); CHECK_EQ(int, str_sl.size(), 3, W("44: String list size")); CHECK_EQ(S, str_sl[0], W("Apple"), W("45: String list first element (case-insensitive)")); CHECK_EQ(S, str_sl[1], W("banana"), W("46: String list second element (case-insensitive)")); CHECK_EQ(S, str_sl[2], W("date"), W("47: String list third element (case-insensitive)")); CHECK_EQ(bool, str_sl.add(W("Cherry")), true, W("48: Add 'Cherry' to string list")); CHECK_EQ(S, str_sl[3], W("date"), W("49: String list after adding 'date'")); CHECK_EQ(S, str_sl.to_s(), W("[Apple, banana, Cherry, date]"), W("50: to_s after adding 'Cherry'")); CHECK_EQ(S, sl.to_s(), W("[]"), W("51: to_s on empty list")); CHECK_EQ(S, S(sl), W("[]"), W("52: Conversion to S on empty list")); CHECK_EQ(S, asc_sl2.to_s(), W("[1, 2, 5, 8]"), W("53: to_s on ascending list")); CHECK_EQ(S, S(asc_sl2), W("[1, 2, 5, 8]"), W("54: Conversion to S on ascending list")); CHECK_EQ(S, desc_sl.to_s(), W("[3, 2, 1]"), W("55: to_s on descending list")); CHECK_EQ(S, S(desc_sl), W("[3, 2, 1]"), W("56: Conversion to S on descending list")); SortedList<int, Descending> desc_sl_copy = desc_sl; CHECK_EQ(int, desc_sl_copy.size(), 3, W("57: Copy constructor size")); CHECK_EQ(int, desc_sl_copy[0], 3, W("58: Copy constructor first element")); CHECK_EQ(bool, desc_sl_copy.comparator()(5, 3), true, W("59: Copy constructor comparator")); SortedList<int, Descending> desc_sl_move = std::move(desc_sl_copy); CHECK_EQ(int, desc_sl_move.size(), 3, W("60: Move constructor size")); CHECK_EQ(int, desc_sl_move[0], 3, W("61: Move constructor first element")); CHECK_EQ(int, desc_sl_copy.size(), 0, W("62: Moved-from list size")); i = 0; for (const auto& item : sl) { i++; } CHECK_EQ(int, i, 0, W("63: Empty iterator count")); CHECK_EQ(bool, desc_sl.add(2), true, W("64: Add duplicate to non-unique descending list")); CHECK_EQ(int, desc_sl.size(), 4, W("65: Size after adding duplicate")); CHECK_EQ(int, desc_sl[1], 2, W("66: First duplicate at index 1")); CHECK_EQ(int, desc_sl[2], 2, W("67: Second duplicate at index 2")); SortedList<int> unique_sl ({}, true); CHECK_EQ(bool, unique_sl.is_unique(), true, W("68: Unique constructor")); CHECK_EQ(bool, unique_sl.add(1), true, W("69: Add to unique list")); CHECK_EQ(int, unique_sl.size(), 1, W("70: Size after first add to unique list")); CHECK_EQ(bool, unique_sl.add(1), false, W("71: Reject duplicate in unique list")); CHECK_EQ(int, unique_sl.size(), 1, W("72: Size unchanged after rejected duplicate")); unique_sl.set_unique(false); CHECK_EQ(bool, unique_sl.is_unique(), false, W("73: set_unique(false)")); CHECK_EQ(bool, unique_sl.add(1), true, W("74: Allow duplicate after set_unique(false)")); CHECK_EQ(int, unique_sl.size(), 2, W("75: Size after allowing duplicate")); CHECK_EQ(int, unique_sl[1], 1, W("76: Duplicate element at index 1")); SortedList<int, Descending> unique_desc_sl({ 3, 1 }, true, Descending{}); CHECK_EQ(bool, unique_desc_sl.is_unique(), true, W("77: Unique descending constructor")); CHECK_EQ(int, unique_desc_sl.size(), 2, W("78: Unique descending list size")); CHECK_EQ(int, unique_desc_sl[0], 3, W("79: Unique descending first element")); CHECK_EQ(int, unique_desc_sl[1], 1, W("80: Unique descending second element")); CHECK_EQ(bool, unique_desc_sl.add(3), false, W("81: Reject duplicate in unique descending list")); CHECK_EQ(int, unique_desc_sl.size(), 2, W("82: Size unchanged after rejected duplicate")); unique_desc_sl.set_unique(false); CHECK_EQ(bool, unique_desc_sl.add(3), true, W("83: Allow duplicate after set_unique(false)")); CHECK_EQ(int, unique_desc_sl.size(), 3, W("84: Size after allowing duplicate")); CHECK_EQ(int, unique_desc_sl[1], 3, W("85: Duplicate element at index 1")); SortedList<S, CaseInsensitive> unique_str_sl({ }, true, CaseInsensitive{}); CHECK_EQ(bool, unique_str_sl.add(W("Apple")), true, W("86: Add to unique string list")); CHECK_EQ(bool, unique_str_sl.add(W("apple")), false, W("87: Reject case-insensitive duplicate")); CHECK_EQ(int, unique_str_sl.size(), 1, W("88: Size after rejected string duplicate")); SortedList<int, Descending> empty_desc_sl({}, false, Descending{}); CHECK_EQ(int, empty_desc_sl.size(), 0, W("89: Empty initializer list size")); CHECK_EQ(bool, empty_desc_sl.is_unique(), false, W("90: Empty initializer list not unique")); SortedList<int, Descending> unique_init_sl({ 3, 1, 3, 1 }, true, Descending{}); CHECK_EQ(int, unique_init_sl.size(), 2, W("91: Unique initializer list size")); CHECK_EQ(int, unique_init_sl[0], 3, W("92: Unique initializer list first element")); CHECK_EQ(int, unique_init_sl[1], 1, W("93: Unique initializer list second element")); SortedList<S, CaseInsensitive> str_order_sl({ W("Cherry"), W("banana"), W("Apple"), W("date") }, false, CaseInsensitive{}); CHECK_EQ(S, str_order_sl[0], W("Apple"), W("94: Case-insensitive order first element")); CHECK_EQ(S, str_order_sl[1], W("banana"), W("95: Case-insensitive order second element")); CHECK_EQ(S, str_order_sl[2], W("Cherry"), W("96: Case-insensitive order third element")); CHECK_EQ(S, str_order_sl[3], W("date"), W("97: Case-insensitive order fourth element")); CHECK_EQ(S, str_sl.to_s(), W("[Apple, banana, Cherry, date]"), W("98: Full order string is not corrett.")); SortedList<S, CaseInsensitive> mixed_case_sl({ W("APPLE"), W("Banana"), W("cherry"), W("Date") }, false, CaseInsensitive{}); CHECK_EQ(S, mixed_case_sl[0], W("APPLE"), W("99: Mixed case order first element")); CHECK_EQ(S, mixed_case_sl[1], W("Banana"), W("100: Mixed case order second element")); CHECK_EQ(S, mixed_case_sl[2], W("cherry"), W("101: Mixed case order third element")); CHECK_EQ(S, mixed_case_sl[3], W("Date"), W("102: Mixed case order fourth element")); CaseInsensitive comp; CHECK(comp(W("Cherry"), W("date")), W("103: Error on comparing Cherry and date")); CHECK(!comp(W("date"), W("Cherry")), W("104: Error on comparing date and C")); TEST_END(SortedList) } } </DOCUMENT>
<DOCUMENT filename="test\stop_watch_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../../src/s.hpp" #include "../../src/stop_watch.hpp" #include "../../src/constraint.hpp" #include <thread> #include <chrono> namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(StopWatch, true) StopWatch<> sp; StopWatch<>::ELAPSED_TYPE T = 2 * StopWatch<>::MS; std::this_thread::sleep_for(std::chrono::nanoseconds(T)); sp.mark (); sp.stop (); StopWatch<>::ELAPSED_TYPE elapsed = sp.elapsed (); CHECK(elapsed >= T, W("0.")); StopWatch<>::ELAPSED_TYPE mark_elapsed = sp.elapsed_since_mark (); S elapsed_formatted = sp.elapsed_formatted (); S elapsed_since_mark_formatted = sp.elapsed_since_mark_formatted (); CHECK(mark_elapsed < elapsed, W("1. elapsed = ") + elapsed_formatted + W(" elapsed_since_mark = ") + elapsed_since_mark_formatted); TEST_END(StopWatch) /* TEST(Over1000msBug, true) const long long UmSegundo = 1000000000; const long long DoisSegundos = 2 * UmSegundo; StopWatch<> sw; sw.mark(); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); sw.stop(); StopWatch<>::ELAPSED_TYPE elapsed = sw.elapsed(); StopWatch<>::ELAPSED_TYPE mark_elapsed = sw.elapsed_since_mark(); S elapsed_formatted = sw.elapsed_formatted(); S elapsed_since_mark_formatted = sw.elapsed_since_mark_formatted(); CHECK(mark_elapsed < elapsed, W("1. elapsed = ") + elapsed_formatted + W(" elapsed_since_mark = ") + elapsed_since_mark_formatted); CHECK(elapsed >= UmSegundo, W("0. elapsed = ") + elapsed_formatted); CHECK(elapsed < DoisSegundos, W("2. elapsed = ") + elapsed_formatted); TEST_END(Over1000msBug) */ } } </DOCUMENT>
<DOCUMENT filename="test\string_util_test-bak.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #define BOOST_TEST_MODULE cpplib_test_module #include <boost/test/included/unit_test.hpp> #include <boost/lexical_cast.hpp> #include <vector> #include <string> #include <map> #include <set> #include <algorithm> #include "string_util.hpp" #include "my_boost.hpp" using namespace std; namespace cpp = pensar_digital::cpplib; namespace std { ostream& operator << (ostream& ostr, wstring const& str) { ostr << boost::lexical_cast<wstring>(str); return ostr; } } BOOST_AUTO_TEST_SUITE(string_util_suite) BOOST_AUTO_TEST_CASE(split_test) { typedef map<string, vector<string> > Map; vector<string> v0, v1, v2, v3; v0.push_back (""); v1.push_back ("blah"); v2.push_back ("a"); v2.push_back ("1"); v3.push_back ("2009"); v3.push_back ("10"); v3.push_back ("09"); vector<string> v4 = {"a", "b", "c", "d"}; Map map; map["" ] = v0; map["blah" ] = v1; map["a, 1" ] = v2; map["2009,10,09"] = v3; map["a,b,,c,,,d"] = v4; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; vector<string> v; cpp::split (s, ',', v); CHECK_EQUAL_COLLECTIONS(i->second, v); } for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; set<string> sset; cpp::split<set<string>> (s, ',', sset); vector<string> v (sset.size ()); std::copy (sset.begin(), sset.end (), v.begin ()); std::sort (v.begin (), v.end ()); std::sort (i->second.begin (), i->second.end ()); CHECK_EQUAL_COLLECTIONS(i->second, v); } v2[1] = " 1"; vector<string> v; cpp::split ("a, 1", ',', v, false); CHECK_EQUAL_COLLECTIONS (v2, v); } BOOST_AUTO_TEST_CASE(split_test2) { std::string s = "ESPN360 BRASIL, ESPN360"; vector<string> v; cpp::split (s, ',', v); BOOST_CHECK_EQUAL (2u, v.size ()); set<string> sset; cpp::split<set<string>> (s, ',', sset); BOOST_CHECK_EQUAL (2u, sset.size ()); } #ifdef UNICODE BOOST_AUTO_TEST_CASE(split_wstring_test) { typedef map<wstring, vector<wstring> > Map; vector<wstring> v0, v1, v2; v0.push_back (L""); v1.push_back (L"blah"); v2.push_back (L"a"); v2.push_back (L"1"); Map map; map[L"" ] = v0; map[L"blah"] = v1; map[L"a, 1"] = v2; for (Map::iterator i = map.begin (); i != map.end (); ++i) { wstring s = i->first; vector<wstring> v; cpp::split (s, ',', &v); CHECK_EQUAL_COLLECTIONS(i->second, v); cpp::WStringVectorPtr vp = cpp::split (s, ','); CHECK_EQUAL_COLLECTIONS(i->second, *vp); } v2[1] = L" 1"; vector<wstring> v; cpp::split (L"a, 1", L',', &v, false); CHECK_EQUAL_COLLECTIONS (v2, v); } #endif BOOST_AUTO_TEST_CASE(pad_copy_test) { string abc = "abc"; BOOST_CHECK_EQUAL ("abc ", cpp::pad_copy (abc, ' ', 6)); BOOST_CHECK_EQUAL ("abc ", cpp::pad_copy ("abc", ' ', 6)); BOOST_CHECK_EQUAL ("abc", cpp::pad_copy ("abc", ' ', 3)); BOOST_CHECK_EQUAL ("abc ", cpp::pad_copy ("abc", ' ', 4)); string empty = ""; BOOST_CHECK_EQUAL (" ", cpp::pad_copy (empty, ' ', 6)); BOOST_CHECK_EQUAL ("abc000", cpp::pad_copy ("abc", '0', 6)); BOOST_CHECK_EQUAL ("abc", cpp::pad_copy ("abc", '0', 3)); BOOST_CHECK_EQUAL ("abc0", cpp::pad_copy ("abc", '0', 4)); BOOST_CHECK_EQUAL ("000000", cpp::pad_copy (empty, '0', 6)); BOOST_CHECK_EQUAL ("000abc", cpp::pad_copy ("abc", '0', 6, cpp::PAD_LEFT)); } BOOST_AUTO_TEST_CASE(only_digits_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = ""; map["12 34a5"] = "12345"; map["123.607.834-07" ] = "12360783407"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::only_digits (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(only_alpha_numeric_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["12 34a5"] = "1234a5"; map["123.607.834-07" ] = "12360783407"; map["a-1,b;2"] = "a1b2"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::only_alpha_numeric (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(remove_blanks_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map[" blah " ] = "blah"; map["12 34 5" ] = "12345"; map["123 456\n\n789\t01"] = "12345678901"; map["á è î õ ü A É Í Ô Ü"] = "áèîõüAÉÍÔÜ"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string result = i->first; cpp::remove_blanks (result); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(remove_accents_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["José da Silva" ] = "Jose da Silva"; map["áàãäâ éèëê íìïî óòõöô úùüû ç"] = "aaaaa eeee iiii ooooo uuuu c"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::copy_remove_accents (s); BOOST_CHECK_EQUAL (result, i->second); } string a = "á"; string s = cpp::copy_remove_accents (a); BOOST_CHECK_EQUAL ("á", a); BOOST_CHECK_EQUAL ("a", s); } BOOST_AUTO_TEST_CASE(remove_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["AO VIVO José da Silva" ] = " José da Silva"; map["Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = "Campeonato Paulista: Palmeiras x Corinthians "; map["AO VIVO"] = ""; map["1 AO VIVO2"] = "1 2"; map["1 AO VIVO 2"] = "1 2"; map["1AO VIVO2"] = "12"; map["1AO VIVO234"] = "1234"; map["AO VIVO, José da Silva" ] = ", José da Silva"; map["AO VIVO1 José da Silva" ] = "1 José da Silva"; map["AO VIVO2 José da Silva" ] = "2 José da Silva"; map["1AO VIVO2 José da Silva" ] = "12 José da Silva"; map["---AO VIVO---"] = "------"; map["1AO VIVO2AO VIVO3"] = "123"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::copy_remove (string("AO VIVO"), s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(remove_delimiter_test) { typedef map<string, string, less<string> > Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["\"José da Silva\"" ] = "José da Silva"; map["\"áàãäâ éèëê íìïî óòõöô úùüû ç\""] = "áàãäâ éèëê íìïî óòõöô úùüû ç"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::remove_delimiters ('"', s); BOOST_CHECK_EQUAL (s, i->second); } } BOOST_AUTO_TEST_CASE(reverse_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "halb"; map["12 34a5"] = "5a43 21"; map["123.607.834-07" ] = "70-438.706.321"; map["a"] = "a"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; string result = cpp::reverse (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(wreverse_test) { typedef map<wstring, wstring> Map; Map map; map[L"" ] = L""; map[L"blah" ] = L"halb"; map[L"12 34a5"] = L"5a43 21"; map[L"123.607.834-07" ] = L"70-438.706.321"; map[L"a"] = L"a"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { wstring s = i->first; wstring result = cpp::reverse (s); BOOST_CHECK_EQUAL (result, i->second); } } BOOST_AUTO_TEST_CASE(to_lower_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["blah" ] = "blah"; map["AO VIVO JOSÉ"] = "ao vivo josé"; map["Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = "campeonato paulista: palmeiras x corinthians ao vivo"; map["1 AO VIVO2"] = "1 ao vivo2"; map["---"] = "---"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::to_lower (s); BOOST_CHECK_EQUAL (s, i->second); } } BOOST_AUTO_TEST_CASE(to_upper_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["BLAH" ] = "BLAH"; map["ao vivo josé"] = "AO VIVO JOSÉ"; map["Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = "CAMPEONATO PAULISTA: PALMEIRAS X CORINTHIANS AO VIVO"; map["1 ao vivo2"] = "1 AO VIVO2"; map["---"] = "---"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::to_upper (s); BOOST_CHECK_EQUAL (s, i->second); } } /* BOOST_AUTO_TEST_CASE(to_upperw_test) { typedef map<wstring, wstring> Map; Map map; map[L"" ] = L""; map[L"BLAH" ] = L"BLAH"; map[L"ao vivo josé"] = L"AO VIVO JOSÉ"; map[L"Campeonato Paulista: Palmeiras x Corinthians AO VIVO"] = L"CAMPEONATO PAULISTA: PALMEIRAS X CORINTHIANS AO VIVO"; map[L"1 ao vivo2"] = L"1 AO VIVO2"; map[L"---"] = L"---"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { wstring s = i->first; cpp::to_upper (s); BOOST_CHECK_EQUAL (s, i->second); } } */ BOOST_AUTO_TEST_CASE(replace_test) { typedef map<string, string> Map; Map map; map["" ] = ""; map["BLAH" ] = "BLAH"; map["ao orig jose"] = "ao replaced jose"; map["Palmeiras x orig"] = "Palmeiras x replaced"; map["orig2orig"] = "replaced2replaced"; map["orig"] = "replaced"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::replace_substr (s, std::string("orig"), std::string("replaced")); BOOST_CHECK_EQUAL (s, i->second); } std::string s = "a a"; BOOST_CHECK(cpp::replace_substr (s, " ", " ")); BOOST_CHECK_EQUAL(s, "a a"); s = "55 11 123-4567"; while (cpp::replace_substr (s, " ", " ")); BOOST_CHECK_EQUAL(s, "55 11 123-4567"); } BOOST_AUTO_TEST_CASE(to_string_unsigned_test) { typedef map<unsigned, string> Map; Map map; map[0 ] = "0"; map[1 ] = "1"; map[123 ] = "123"; map[1234 ] = "1,234"; map[12345 ] = "12,345"; map[123456 ] = "123,456"; map[1234567] = "1,234,567"; for (Map::iterator i = map.begin (); i != map.end (); ++i) { unsigned u = i->first; std::string s = cpp::to_string (u); BOOST_CHECK_EQUAL (s, i->second); } BOOST_CHECK_EQUAL ("1.234.567", cpp::to_string((unsigned)1234567, '.')); } BOOST_AUTO_TEST_CASE(to_string_int_test) { typedef map<int, string> Map; Map map; map[0 ] = "0"; map[-1 ] = "-1"; map[123 ] = "123"; map[-1234 ] = "-1,234"; map[12345 ] = "12,345"; map[-123456] = "-123,456"; map[1234567] = "1,234,567"; for (Map::iterator it = map.begin (); it != map.end (); ++it) { int i = it->first; std::string s = cpp::to_string ((int)i); BOOST_CHECK_EQUAL (s, it->second); } BOOST_CHECK_EQUAL ("1.234.567", cpp::to_string(1234567, '.')); } BOOST_AUTO_TEST_CASE(to_string_double_test) { typedef map<double, string> Map; Map map; map[0 ] = "0.00"; map[-1 ] = "-1.00"; map[123.01 ] = "123.01"; map[-1234.02 ] = "-1,234.02"; map[12345.123 ] = "12,345.12"; for (Map::iterator it = map.begin (); it != map.end (); ++it) { double d = it->first; std::string s = cpp::to_string (d); BOOST_CHECK_EQUAL (s, it->second); } std::string s = cpp::to_string (12345.123, 3); BOOST_CHECK_EQUAL(s, "12,345.123"); } BOOST_AUTO_TEST_CASE(remove_ext_test) { typedef map<string, string> Map; Map map; map["" ] = "" ; map["blah" ] = "blah" ; map["fname.txt" ] = "fname" ; map["fname.txt.txt" ] = "fname.txt"; map["fname.extension"] = "fname" ; map[".ext" ] = "" ; for (Map::iterator i = map.begin (); i != map.end (); ++i) { string s = i->first; cpp::remove_ext (s); BOOST_CHECK_EQUAL (s, i->second); } } BOOST_AUTO_TEST_SUITE_END() </DOCUMENT>
<DOCUMENT filename="test\s_test.cpp">
 #include "..\unit-test\test\test.hpp" #include "../cpplib/cpp/s.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(CS, true) static_assert(TriviallyCopyable<CS<10>>, W("S is not compliant with StdLayoutTriviallyCopyable concept.")); CS<> s; CS<> s1; CHECK_EQ(CS<>, s, s1, W("0")); s = W("abc"); CHECK_NOT_EQ(CS<>, s, s1, W("1")); CHECK_EQ(CS<>, s, W("abc"), W("2")); CHECK_EQ(size_t, s.length(), 3, W("3")); CHECK_EQ(size_t, s.size(), CS<>::MAX_SIZE, W("4")); CS<> s2 = W("abc"); CHECK_EQ(CS<>, s2.to_string(), W("abc"), W("5")); CHECK(s == s2, W("6")); s2 = W("def"); CHECK_EQ(CS<>, s2, W("def"), W("7")); static_assert (pd::OutputStreamable<CS<>>, "S is not OutputStreamable"); typedef CS<0, 20> WC; WC w = W("abc"); static_assert (pd::OutputStreamable<WC>, "W is not OutputStreamable"); S str = W("abc"); CS<> s3 = str; CHECK_EQ(CS<>, s3, W("abc"), W("9")); CS<> s4 = W("abc"); CS<> s5 = W("def"); CS<> s6 = s4 + s5; CHECK_EQ(CS<>, s6, W("abcdef"), W("11")); TEST_END(CS) } } </DOCUMENT>
<DOCUMENT filename="test\time_util_test.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <boost/test/unit_test.hpp> #include "time_util.h" namespace pd = pensar_digital::cpplib; BOOST_AUTO_TEST_SUITE(time_util_suite) BOOST_AUTO_TEST_CASE(stimestamp_test) { std::string s = "2009-10-09 20:40:22"; time_t t = pd::sdatetime2time_t (s); std::string s1 = pd::stimestamp (t); BOOST_CHECK_EQUAL (s, s1); std::string s2 = pd::stimestamp (); } BOOST_AUTO_TEST_CASE(today_test) { std::string stoday = pd::today (); std::string stoday2 = pd::today ("%m%y"); } BOOST_AUTO_TEST_SUITE_END () </DOCUMENT>
<DOCUMENT filename="test\version_test.cpp">
 #include "../../../unit_test/src/test.hpp" #include "../version.hpp" namespace pensar_digital { namespace test = pensar_digital::unit_test; using namespace pensar_digital::unit_test; namespace cpplib { TEST(Version, true) Version::Ptr v = Version::get(2, 3, 4); CHECK_EQ(Version, v->get_public(), 2, W("0. public != 2")); CHECK_EQ(Version, v->get_protected(), 3, W("1. protected != 3")); CHECK_EQ(Version, v->get_private(), 4, W("2. private != 4")); TEST_END(Version) TEST(VersionSerialization, true) Version::Ptr v = Version::get(2, 3, 4); MemoryBuffer::Ptr mb = v->bytes(); Version::Ptr v1 = Version::get(); CHECK_NOT_EQ(Version, *v, *v1, W("0. v == v1")); v1->assign(*mb); CHECK_EQ(Version, *v, *v1, W("1. v != v1")); CHECK_EQ(Version::Int, v->get_public(), 2, W("2. public != 2")); CHECK_EQ(Version::Int, v->get_protected(), 3, W("3. protected != 3")); CHECK_EQ(Version::Int, v->get_private(), 4, W("4. private != 4")); TEST_END(VersionSerialization) } } </DOCUMENT>
<DOCUMENT filename="test.cpp">
 #include "framework.h" #include "test.hpp" #include "../../cpplib/cpp/string_def.hpp" #include "../../cpplib/cpp/constant.hpp" namespace pensar_digital { namespace unit_test { Generator<CompositeTest> CompositeTest::generator = Generator<CompositeTest> (); Generator<Test> Test::generator = Generator<Test> (); CompositeTest& all_tests () { static CompositeTest* all = new CompositeTest(W("All tests")); return *all; } } } </DOCUMENT>
<DOCUMENT filename="test.hpp">
#ifndef TEST_HPP #define TEST_HPP #define _WINSOCKAPI_ #include <winsock2.h> #include "../../cpplib/cpp/constant.hpp" #include "../../cpplib/cpp/generator.hpp" #include "../../cpplib/cpp/macros.hpp" #include "../../cpplib/cpp/s.hpp" #include "../../cpplib/cpp/error.hpp" #include "../../cpplib/cpp/concept.hpp" #include "../../cpplib/cpp/stop_watch.hpp" #include "../../cpplib/cpp/path.hpp" #include "../../cpplib/cpp/stream_util.hpp" #include <string> #include <stdexcept> #include <sstream> #include <unordered_map> #include <queue> #include <iostream> #include <concepts> #include <span> namespace pensar_digital { namespace unit_test { using namespace cpplib; namespace pd = pensar_digital::cpplib; const int UNORDERED = -1; class Failure : Error { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); using Error::get_error_message; Failure (const Id id, const std::basic_string<C>& name, const std::basic_string<C>& err_msg, const std::basic_string<C>& afile, const unsigned aline): Error(err_msg, id), test_id (id), test_name (name), file (afile), line (aline) { SStream ss; ss << file << W(" line \t") << line << W("\ttest_id = ") << id << W("\ttest_name = ") << name << W("\terror = ") << err_msg; Error::set_error_message (ss.str ()); }; private: const Id test_id; const S& test_name; const S& file; const unsigned line; }; class Test : public Object { private: static Generator<Test> generator; int order; bool stop_on_failure; bool enabled; S name; public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); typedef Test T; Test(const S& test_name, const Id aid = NULL_ID, int aorder = UNORDERED, bool stop_on_fail = true, bool is_enabled = true) : name (test_name ), order (aorder ), stop_on_failure (stop_on_fail), enabled (is_enabled ) {} virtual ~Test() {} virtual bool run () = 0; S get_name () const { return name; } void set_name (const S& a_name) { name = a_name; } template <OutputStreamable T> void error(const T& actual, const T& expected, const S& error_message, const S& file, const unsigned line) const { if constexpr (std::is_same_v<T, std::string>) { S sactual; S sexpected; #ifdef WIDE_CHAR sactual = to_wstring(actual); sexpected = to_wstring(expected); out() << file << W(" line \t") << line << W("\t actual [") << sactual << W("] != [") << sexpected << W("] expected\t") << error_message << std::endl; #else sactual = actual; sexpected = expected; out() << file << W(" line \t") << line << W("\t actual [") << sactual << W("] != [") << sexpected << W("] expected\t") << error_message << std::endl; #endif } else { out() << file << W(" line \t") << line << W("\t actual [") << actual << W("] != [") << expected << W("] expected\t") << error_message << std::endl; } if (stop_on_failure) throw Failure (pd::Object::id(), get_name (), error_message, file, line); } bool check(bool expression, const S& error_message, const S& file, const unsigned line) const { if (!expression) { error<bool>(expression, true, error_message, file, line); } return expression; } template <OutputStreamable T> bool check_equal(const T& actual, const T& expected, const S& error_message, const S& file, const unsigned line) const { bool ok = (actual == expected); if (! ok) error<T>(actual, expected, error_message, file, line); return ok; }; bool check_equal(const char* actual, const char* expected, const S& error_message, const S& file, const unsigned line) const { bool ok = (strcmp(actual, expected) == 0); if (! ok) { std::string sactual(actual); std::string sexpected(expected); error(sactual, sexpected, error_message, file, line); } return ok; } /* bool check_equal(const wchar_t* actual, const wchar_t* expected, const S& error_message, const S& file, const unsigned line) const { bool ok = (wcscmp(actual, expected) == 0); if (! ok) { std::wstring sactual(actual); std::wstring sexpected(expected); error<std::wstring>(sactual, sexpected, error_message, file, line); } return ok; }*/ template <OutputStreamable T> bool check_not_equal(const T& actual, const T& expected, const S& error_message, const S& file, const unsigned line) const { bool ok = (actual != expected); if (!ok) error(actual, expected, error_message, file, line); return ok; }; bool check_not_equal(const char* actual, const char* expected, const S& error_message, const S& file, const unsigned line) const { bool ok = (strcmp(actual, expected) != 0); if (!ok) { std::string sactual(actual); std::string sexpected(expected); error<std::string>(sactual, sexpected, error_message, file, line); } return ok; } /*bool check_not_equal(const wchar_t* actual, const wchar_t* expected, const S& error_message, const S& file, const unsigned line) const { bool ok = (wcscmp(actual, expected) != 0); if (!ok) { std::wstring sactual(actual); std::wstring sexpected(expected); error(sactual, sexpected, error_message, file, line); } return ok; }*/ template <Container A, Container E> bool check_equal_collection(const A& actual, const E& expected, const S& error_message, const S& file, const unsigned line) const { bool ok = false; try { ok = (actual.size() == expected.size()); if (not ok) { out () << file << W(" line \t"); out () << line << W("\t actual size [") << actual.size(); out () << W("] != [") << expected.size() << W("] expected size\t") << error_message << std::endl; if (stop_on_failure) throw Failure (pd::Object::id (), get_name (), error_message, file, line); } if (ok) { for (size_t i = 0; i < actual.size(); i++) { S err = error_message + W(" at index "); err += pd::to_string<size_t, false>(i); typename E::value_type const expected_value = expected[i]; typename A::value_type const actual_value = actual[i]; ok = check_equal<typename A::value_type>(actual_value, expected_value, err, file, line); } } return ok; } catch (const Exception& e) { ok = false; if (stop_on_failure) throw Failure (pd::Object::id(), get_name (), error_message + e.what_error(), file, line); } return ok; }; int get_order () const { return order; } bool get_stop_on_failure() const { return stop_on_failure; } bool is_enabled () const { return enabled; } bool is_ordered () const { return order == UNORDERED;} Test& enable () { enabled = true ; return *this; } Test& disable() { enabled = false; return *this; } Test& set_stop_on_failure ( bool Stop ) { stop_on_failure = Stop; return *this; } bool operator== (const T& t) const { return pd::Object::id () == t.id ();} bool operator< (const T& t) const { return order < t.order; } bool operator!= (const T& t) const { return !(*this == t); } virtual std::istream& read (std::istream& is, const std::endian& byte_order = std::endian::native) { return is; } virtual std::ostream& write (std::ostream& os, const std::endian& byte_order = std::endian::native) const { return os; } }; class CompositeTest : public Test { public: inline static const VersionPtr VERSION = pd::Version::get (1, 1, 1); typedef Test T; typedef std::unordered_map<Id, T*> UnorderedTestMap; typedef std::priority_queue<T*> OrderedTestQueue; CompositeTest(const S& test_name = W(""), const Id aid = NULL_ID, int aorder = UNORDERED, bool stop_on_fail = true) : T(test_name, aid, aorder, stop_on_fail), unordered_tests(UnorderedTestMap()), ordered_tests (OrderedTestQueue ()) { set_id (generator.get_id ()); } void add (T& test) { test.set_stop_on_failure (Test::get_stop_on_failure ()); if (test.is_ordered ()) ordered_tests.push (&test); else unordered_tests.insert (std::pair<Id, T*> (test.get_order (), &test)); }; void add (T* test) { add (*test); }; virtual bool run () { namespace pd = pensar_digital::cpplib; bool ok = true; size_t count = CompositeTest::count (); StopWatch<> sw; try { for (UnorderedTestMap::value_type t: unordered_tests) { if (t.second->is_enabled()) { t.second->set_stop_on_failure(Test::get_stop_on_failure()); sw.mark (); ok = t.second->run(); out () << pd::pad_left0(--count) << W(" ") << pd::pad_copy (t.second->get_name (), W(' '), 25) << W(" ") << sw.elapsed_since_mark_formatted() << std::endl; } else { ok = true; out () << pd::pad_left0 (--count) << W(" ") << t.second->get_name () << W(" is disabled.") << std::endl; } if (!ok && Test::get_stop_on_failure ()) break; } if (ok) { while (! ordered_tests.empty ()) { T *t = ordered_tests.top(); if (t->is_enabled()) { t->set_stop_on_failure(Test::get_stop_on_failure()); sw.mark (); ok = t->run(); out () << pd::pad_copy (pd::to_string<size_t, false>(--count), W('0'), 4, PAD_LEFT) << W(" ") << pd::pad_copy(t->get_name (), W(' '), 30) << W(" ") << sw.elapsed_since_mark_formatted() << std::endl; } else { ok = true; out () << --count << W(" ") << t->get_name () << W(" is disabled.") << std::endl; } ordered_tests.pop (); if (!ok && Test::get_stop_on_failure ()) break; } } sw.stop(); if (ok) { out () << W("ok") << W(" ") << sw.elapsed_formatted (); } } catch (const Failure& f) { out () << f.get_error_message (); } return ok; } size_t count () { return ordered_tests.size () + unordered_tests.size ();} private: UnorderedTestMap unordered_tests; OrderedTestQueue ordered_tests; static Generator<CompositeTest> generator; }; extern CompositeTest& all_tests (); #define CHECK(bool_expression, error_message) \ check (bool_expression, \ error_message, \ sfile (), \ __LINE__); #define CHECK_EQ(T, actual, expected, error_message) \ check_equal<T> (actual, expected, \ error_message, \ sfile (), \ __LINE__); #define CHECK_EQ_STR(actual, expected, error_message) \ check_equal (actual, expected, \ error_message, \ sfile (), \ __LINE__); #define CHECK_NOT_EQ(T, actual, expected, error_message) \ check_not_equal<T> (actual, expected, \ error_message, \ sfile (), \ __LINE__); #define TEST_PREDICATE(name, bool_expression, error_message) \ class Test ## name : public Test\ { \ public: \ inline static const Version VERSION = Version (1, 1, 1); \ Test ## name () \ : Test (W(#name)){all_tests ().add(this);}; \ bool run () \ { \ CHECK(bool_expression, error_message) \ return true; \ } \ }; Test ## name test_ ## name; #define TEST(name, is_enabled) \ class Test##name : public Test \ { \ public: \ inline static const Version VERSION = Version (1, 1, 1); \ Test##name () \ : Test (W(#name)){is_enabled ? enable () : disable ();all_tests ().add(this);}; \ bool run () \ { #define TEST_END(name) \ return true; } \ }; Test ## name test_ ## name; #define WCHECK(bool_expression, error_message) \ check (bool_expression, \ error_message, \ sfile (), \ __LINE__); #define WCHECK_EQ(T, actual, expected, error_message) \ check_equal<T> (actual, expected, \ error_message, \ sfile (), \ __LINE__); #define WCHECK_NOT_EQ(T, actual, expected, error_message) \ check_not_equal<T> (actual, expected, \ error_message, \ sfile (), \ __LINE__); } } #endif </DOCUMENT>
<DOCUMENT filename="thread_block_alllocator.hpp">
#include <cstddef> #include <thread> #include <mutex> #include <vector> #include <atomic> #include <stdexcept> #include <memory> #include <filesystem> #include <iostream> #include <array> #include <cstring> #include <fstream> #if defined(_WIN64) #include <windows.h> #elif defined(__linux__) #include <sys/mman.h> #include <fcntl.h> #include <unistd.h> #elif defined(__APPLE__) #include <sys/mman.h> #include <fcntl.h> #include <unistd.h> #else #error "Unsupported platform" #endif namespace md5 { using MD5Digest = std::array<uint8_t, 16>; MD5Digest compute(const void* data, size_t size) { MD5Digest digest{}; for (size_t i = 0; i < 16; ++i) { digest[i] = static_cast<uint8_t>(i); } return digest; } bool verify(const void* data, size_t size, const MD5Digest& digest) { auto computed = compute(data, size); return std::equal(digest.begin(), digest.end(), computed.begin()); } void save_to_file(const std::filesystem::path& path, const MD5Digest& digest) { std::ofstream out(path, std::ios::binary); if (!out) { throw std::runtime_error("Failed to write MD5 file"); } out.write(reinterpret_cast<const char*>(digest.data()), digest.size()); } MD5Digest load_from_file(const std::filesystem::path& path) { std::ifstream in(path, std::ios::binary); if (!in) { throw std::runtime_error("Failed to read MD5 file"); } MD5Digest digest; in.read(reinterpret_cast<char*>(digest.data()), digest.size()); if (!in.good()) { throw std::runtime_error("Incomplete MD5 read"); } return digest; } } inline std::thread::id get_current_thread_id() { return std::this_thread::get_id(); } template<typename T> class ThreadBlockAllocator { private: struct MemoryBlock { void* memory; size_t size; size_t used; std::thread::id thread_id; std::filesystem::path file_path; bool is_mapped; MemoryBlock(size_t byte_size, std::thread::id tid, const std::filesystem::path& path) : memory(nullptr), size(byte_size), used(0), thread_id(tid), file_path(path), is_mapped(false) { map_memory(byte_size); } ~MemoryBlock() { if (is_mapped) { unmap_memory(); } else if (memory) { std::free(memory); } } void map_memory(size_t byte_size) { #if defined(_WIN64) HANDLE hFile = CreateFileA( file_path.string().c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { throw std::runtime_error("Failed to create file"); } HANDLE hMap = CreateFileMapping( hFile, NULL, PAGE_READWRITE, 0, static_cast<DWORD>(byte_size), NULL); CloseHandle(hFile); if (!hMap) { throw std::runtime_error("Failed to create file mapping"); } memory = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0, byte_size); CloseHandle(hMap); #elif defined(__linux__) || defined(__APPLE__) int fd = open(file_path.string().c_str(), O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR); if (fd == -1) { throw std::runtime_error("Failed to create file"); } if (ftruncate(fd, byte_size) == -1) { close(fd); throw std::runtime_error("Failed to set file size"); } memory = mmap(NULL, byte_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); close(fd); if (memory == MAP_FAILED) { throw std::runtime_error("Failed to map memory"); } #endif if (!memory) { throw std::bad_alloc(); } is_mapped = true; size = byte_size; } void unmap_memory() { if (!is_mapped || !memory) return; #if defined(_WIN64) UnmapViewOfFile(memory); #elif defined(__linux__) || defined(__APPLE__) munmap(memory, size); #endif } void save_checksum() { auto checksum = md5::compute(memory, used); auto md5_path = file_path; md5_path.replace_extension(".md5"); md5::save_to_file(md5_path, checksum); } bool verify_checksum() const { auto md5_path = file_path; md5_path.replace_extension(".md5"); if (!std::filesystem::exists(md5_path)) { return false; } auto stored_checksum = md5::load_from_file(md5_path); return md5::verify(memory, used, stored_checksum); } }; std::vector<std::unique_ptr<MemoryBlock>> blocks; std::mutex blocks_mutex; std::atomic<uint64_t> id_counter{0}; void save_win64(MemoryBlock& block) { block.save_checksum(); FlushViewOfFile(block.memory, block.used); } void save_linux(MemoryBlock& block) { block.save_checksum(); if (msync(block.memory, block.used, MS_SYNC) == -1) { throw std::runtime_error("Failed to sync memory to disk"); } } void save_ios(MemoryBlock& block) { block.save_checksum(); if (msync(block.memory, block.used, MS_SYNC) == -1) { throw std::runtime_error("Failed to sync memory to disk"); } } public: using value_type = T; using pointer = T*; using const_pointer = const T*; using reference = T&; using const_reference = const T&; using size_type = std::size_t; using difference_type = std::ptrdiff_t; template<typename U> struct rebind { using other = ThreadBlockAllocator<U>; }; ThreadBlockAllocator() noexcept = default; template<typename U> ThreadBlockAllocator(const ThreadBlockAllocator<U>&) noexcept {} void add_thread_block(size_t byte_size, const std::filesystem::path& path, std::thread::id thread_id = get_current_thread_id()) { std::lock_guard<std::mutex> lock(blocks_mutex); blocks.push_back(std::make_unique<MemoryBlock>(byte_size, thread_id, path)); } void load_block(const std::filesystem::path& path, std::thread::id thread_id = get_current_thread_id()) { std::lock_guard<std::mutex> lock(blocks_mutex); if (!std::filesystem::exists(path)) { throw std::runtime_error("Block file does not exist"); } size_t file_size = std::filesystem::file_size(path); auto block = std::make_unique<MemoryBlock>(file_size, thread_id, path); block->unmap_memory(); #if defined(_WIN64) HANDLE hFile = CreateFileA( path.string().c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL); void* temp = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, file_size); CloseHandle(hMap); CloseHandle(hFile); if (!block->verify_checksum()) { UnmapViewOfFile(temp); throw std::runtime_error("Checksum verification failed"); } UnmapViewOfFile(temp); block->map_memory(file_size); #elif defined(__linux__) || defined(__APPLE__) int fd = open(path.string().c_str(), O_RDONLY); void* temp = mmap(NULL, file_size, PROT_READ, MAP_SHARED, fd, 0); close(fd); if (!block->verify_checksum()) { munmap(temp, file_size); throw std::runtime_error("Checksum verification failed"); } munmap(temp, file_size); block->map_memory(file_size); #endif block->used = file_size; blocks.push_back(std::move(block)); } T* allocate(size_type n) { static_assert(std::is_trivially_copyable<T>::value, "ThreadBlockAllocator only supports trivially copyable types"); size_type bytes_needed = n * sizeof(T); std::thread::id current_thread = get_current_thread_id(); std::lock_guard<std::mutex> lock(blocks_mutex); for (auto& block : blocks) { if (block->thread_id == current_thread && block->used + bytes_needed <= block->size) { T* ptr = reinterpret_cast<T*>( static_cast<char*>(block->memory) + block->used); for (size_type i = 0; i < n; ++i) { new(&ptr[i]) T(); if constexpr (requires { ptr[i].id; }) { ptr[i].id = id_counter++; } } block->used += bytes_needed; return ptr; } } throw std::bad_alloc(); } void deallocate(T*, size_type) noexcept {} void save() { std::lock_guard<std::mutex> lock(blocks_mutex); for (auto& block : blocks) { #if defined(_WIN64) save_win64(*block); #elif defined(__linux__) save_linux(*block); #elif defined(__APPLE__) save_ios(*block); #endif } } size_type max_size() const noexcept { return std::numeric_limits<size_type>::max() / sizeof(T); } template<typename... Args> void construct(T* p, Args&&... args) { new(p) T(std::forward<Args>(args)...); if constexpr (requires { p->id; }) { p->id = id_counter++; } } void destroy(T* p) { p->~T(); } }; template<typename T, typename U> bool operator==(const ThreadBlockAllocator<T>&, const ThreadBlockAllocator<U>&) noexcept { return true; } template<typename T, typename U> bool operator!=(const ThreadBlockAllocator<T>& a, const ThreadBlockAllocator<U>& b) noexcept { return !(a == b); } struct MyObject { uint64_t id; int data; }; int main() { ThreadBlockAllocator<MyObject> alloc; std::filesystem::path path = "block1.dat"; alloc.add_thread_block(1024 * sizeof(MyObject), path); MyObject* objects = alloc.allocate(2); objects[0].data = 42; objects[1].data = 84; std::cout << "Object 1 ID: " << objects[0].id << "\n"; std::cout << "Object 2 ID: " << objects[1].id << "\n"; alloc.save(); ThreadBlockAllocator<MyObject> alloc2; alloc2.load_block(path); MyObject* loaded = reinterpret_cast<MyObject*>(alloc2.allocate(0)); std::cout << "Loaded Object 1 data: " << loaded[0].data << "\n"; std::cout << "Loaded Object 2 data: " << loaded[1].data << "\n"; return 0; } </DOCUMENT>
<DOCUMENT filename="time_util - Copy.cpp">
 #include "mg.hpp" #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <string> #include <iostream> #include <vector> #ifdef BORLAND #include <vcl.h> #endif #include "time_util.h" #include "string_util.hpp" #ifdef CODE_GEAR #pragma hdrstop #endif namespace pensar_digital { namespace cpplib { using namespace std; const char *diaSemana[] = {"Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"}; #ifdef BORLAND time_t today () { TDateTime date = TDateTime::CurrentDate(); AnsiString s = date.FormatString("dd/mm/YY"); return date2time_t (s.c_str()); } #endif time_t date2time_t (const std::string& data) { if ((&data == 0) || (data.size() == 0)) return 0; time_t t = time (&t); struct tm *date = gmtime (&t); std::vector<std::string> v; split (data, '/', v); try { date->tm_mday = std::stoi(v[0]); date->tm_mon = std::stoi(v[1]) - 1; date->tm_year = std::stoi(v[2]) + 100; date->tm_hour = 0; date->tm_min = 0; date->tm_sec = 0; } catch (exception& e) { cerr << "date2time_t - Bad cast: " << e.what( ) << endl; } t = mktime (date); return t; } time_t strdate2time_t (const std::string& data) { if ((&data == 0) || (data.size() == 0)) return 0; time_t t = time (&t); struct tm *date = gmtime (&t); std::vector<std::string> v; split (data, '-', v); try { date->tm_mday = stoi(v[2]); date->tm_mon = stoi(v[1]) - 1; date->tm_year = stoi(v[0]) - 1900; date->tm_hour = 0; date->tm_min = 0; date->tm_sec = 0; } catch (exception& e) { cerr << "strdate2time_t - Bad cast: " << e.what( ) << endl; } t = mktime (date); return t; } time_t sdatetime2time_t (const std::string& datahora) { if ((&datahora == 0) || (datahora.size() == 0)) return 0; time_t t = time (&t); struct tm *date = gmtime (&t); std::vector<std::string> v; split (datahora, ' ', v); std::stringstream err; err << "invalid argument: " << datahora; if (v.size () < 2) { err << " v.size = " << v.size (); throw err.str (); } std::vector<std::string> v1; split (v[0], '-', v1); if (v1.size () < 3) { err << " v1.size = " << v1.size (); throw err.str (); } std::vector<std::string> v2; split (v[1], ':', v2); if (v2.size () < 3) { err << " v2.size = " << v2.size (); throw err.str (); } try { date->tm_mday = std::stoi(v1[2]); date->tm_year = std::stoi(v1[0]) - 1900; date->tm_hour = std::stoi(v2[0]); date->tm_min = std::stoi(v2[1]); date->tm_sec = std::stoi(v2[2]); } catch (std::exception& e) { cerr << "sdatetime2time_t - Bad cast: " << e.what( ) << endl; } t = mktime (date); return t; } POSIX::ALT_FILETIME strdate2ALT_FILE_TIME (const string& date) { time_t t = strdate2time_t (date); POSIX::ALT_FILETIME aft; POSIX::TimeT_To_FILETIME (t, &aft); return aft; } time_t hour2time_t (const std::string& hora) { time_t t = time (&t); struct tm *timeinfo = localtime (&t); std::vector<std::string> v; split (hora, ':', v); try { timeinfo->tm_hour = stoi(v[0]); timeinfo->tm_min = stoi(v[1]); if (v.size () > 2) timeinfo->tm_sec = stoi(v[2]); else timeinfo->tm_sec = 0; } catch (std::exception& e) { cerr << "hora2time_t - Bad cast: " << e.what( ) << endl; } return mktime (timeinfo); } std::string time_t2hour (time_t time) { struct tm * timeinfo; char buffer [80]; timeinfo = localtime (&time); strftime (buffer, 80, "%H:%M", timeinfo); string s(buffer); return s; } std::string time_t2hhmmss (time_t time, const char* pattern) { struct tm * timeinfo; char buffer [80]; timeinfo = localtime (&time); strftime (buffer, 80, pattern, timeinfo); std::string s(buffer); return s; } std::string time_t2hhmmss (time_t time) { return time_t2hhmmss (time, "%H:%M:%S"); } const char* time_t2weekday (time_t t) { struct tm * timeinfo; timeinfo = localtime (&t); return diaSemana[timeinfo->tm_wday]; } string time_t2strdate (time_t time) { if (time == 0) return "1900-01-01"; struct tm * timeinfo; char buffer [80]; timeinfo = gmtime (&time); strftime (buffer, 11, "%Y-%m-%d", timeinfo); std::string s(buffer); return s; } std::string stimestamp (std::time_t t) { t = (t ? t : time (0)); return time_t2strdate (t) + " " + time_t2hhmmss (t); } std::string now () { time_t t = time (0); return time_t2strdate (t) + "_" + time_t2hhmmss (t, "%Hh%Mm%Ss"); } std::string time_t2date (time_t time, const char* pattern) { if (time == 0) return "01/01/1900"; struct tm * timeinfo; char buffer [80]; timeinfo = gmtime (&time); strftime (buffer, 11, pattern, timeinfo); std::string s(buffer); return s; } std::string time_t2date (time_t time) { return time_t2date (time, "%d/%m/%Y"); } std::string today (const char* pattern) { return time_t2date (time (0), pattern); } #ifdef CODE_GEAR ftime string2ftime (std::string date) { struct ftime t; std::vector<std::string> v; split (date, '-', &v); try { t.ft_year = stoi(v[0]) - 1980; t.ft_month = stoi(v[1]) - 1; t.ft_day = stoi(v[2]); t.ft_hour = 0; t.ft_min = 0; t.ft_tsec = 0; } catch (bad_lexical_cast& e) { cerr << "string2ftime - Bad cast: " << e.what( ) << endl; } return ftime(t); } #endif } } </DOCUMENT>
<DOCUMENT filename="time_util.cpp">
 #include "mg.hpp" #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #include <string> #include <iostream> #include <vector> #ifdef BORLAND #include <vcl.h> #endif #include "time_util.h" #include "string_util.hpp" #ifdef CODE_GEAR #pragma hdrstop #endif namespace pensar_digital { namespace cpplib { using namespace std; const char *diaSemana[] = {"Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"}; #ifdef BORLAND time_t today () { TDateTime date = TDateTime::CurrentDate(); AnsiString s = date.FormatString("dd/mm/YY"); return date2time_t (s.c_str()); } #endif time_t date2time_t (const std::string& data) { if ((&data == 0) || (data.size() == 0)) return 0; time_t t = time (&t); struct tm *date = gmtime (&t); std::vector<std::string> v; split (data, '/', v); try { date->tm_mday = std::stoi(v[0]); date->tm_mon = std::stoi(v[1]) - 1; date->tm_year = std::stoi(v[2]) + 100; date->tm_hour = 0; date->tm_min = 0; date->tm_sec = 0; } catch (exception& e) { cerr << "date2time_t - Bad cast: " << e.what( ) << endl; } t = mktime (date); return t; } time_t strdate2time_t (const std::string& data) { if ((&data == 0) || (data.size() == 0)) return 0; time_t t = time (&t); struct tm *date = gmtime (&t); std::vector<std::string> v; split (data, '-', v); try { date->tm_mday = stoi(v[2]); date->tm_mon = stoi(v[1]) - 1; date->tm_year = stoi(v[0]) - 1900; date->tm_hour = 0; date->tm_min = 0; date->tm_sec = 0; } catch (exception& e) { cerr << "strdate2time_t - Bad cast: " << e.what( ) << endl; } t = mktime (date); return t; } time_t sdatetime2time_t (const std::string& datahora) { if ((&datahora == 0) || (datahora.size() == 0)) return 0; time_t t = time (&t); struct tm *date = gmtime (&t); std::vector<std::string> v; split (datahora, ' ', v); std::stringstream err; err << "invalid argument: " << datahora; if (v.size () < 2) { err << " v.size = " << v.size (); throw err.str (); } std::vector<std::string> v1; split (v[0], '-', v1); if (v1.size () < 3) { err << " v1.size = " << v1.size (); throw err.str (); } std::vector<std::string> v2; split (v[1], ':', v2); if (v2.size () < 3) { err << " v2.size = " << v2.size (); throw err.str (); } try { date->tm_mday = std::stoi(v1[2]); date->tm_year = std::stoi(v1[0]) - 1900; date->tm_hour = std::stoi(v2[0]); date->tm_min = std::stoi(v2[1]); date->tm_sec = std::stoi(v2[2]); } catch (std::exception& e) { cerr << "sdatetime2time_t - Bad cast: " << e.what( ) << endl; } t = mktime (date); return t; } POSIX::ALT_FILETIME strdate2ALT_FILE_TIME (const string& date) { time_t t = strdate2time_t (date); POSIX::ALT_FILETIME aft; POSIX::TimeT_To_FILETIME (t, &aft); return aft; } time_t hour2time_t (const std::string& hora) { time_t t = time (&t); struct tm *timeinfo = localtime (&t); std::vector<std::string> v; split (hora, ':', v); try { timeinfo->tm_hour = stoi(v[0]); timeinfo->tm_min = stoi(v[1]); if (v.size () > 2) timeinfo->tm_sec = stoi(v[2]); else timeinfo->tm_sec = 0; } catch (std::exception& e) { cerr << "hora2time_t - Bad cast: " << e.what( ) << endl; } return mktime (timeinfo); } std::string time_t2hour (time_t time) { struct tm * timeinfo; char buffer [80]; timeinfo = localtime (&time); strftime (buffer, 80, "%H:%M", timeinfo); string s(buffer); return s; } std::string time_t2hhmmss (time_t time, const char* pattern) { struct tm * timeinfo; char buffer [80]; timeinfo = localtime (&time); strftime (buffer, 80, pattern, timeinfo); std::string s(buffer); return s; } std::string time_t2hhmmss (time_t time) { return time_t2hhmmss (time, "%H:%M:%S"); } const char* time_t2weekday (time_t t) { struct tm * timeinfo; timeinfo = localtime (&t); return diaSemana[timeinfo->tm_wday]; } string time_t2strdate (time_t time) { if (time == 0) return "1900-01-01"; struct tm * timeinfo; char buffer [80]; timeinfo = gmtime (&time); strftime (buffer, 11, "%Y-%m-%d", timeinfo); std::string s(buffer); return s; } std::string stimestamp (std::time_t t) { t = (t ? t : time (0)); return time_t2strdate (t) + " " + time_t2hhmmss (t); } std::string now () { time_t t = time (0); return time_t2strdate (t) + "_" + time_t2hhmmss (t, "%Hh%Mm%Ss"); } std::string time_t2date (time_t time, const char* pattern) { if (time == 0) return "01/01/1900"; struct tm * timeinfo; char buffer [80]; timeinfo = gmtime (&time); strftime (buffer, 11, pattern, timeinfo); std::string s(buffer); return s; } std::string time_t2date (time_t time) { return time_t2date (time, "%d/%m/%Y"); } std::string today (const char* pattern) { return time_t2date (time (0), pattern); } #ifdef CODE_GEAR ftime string2ftime (std::string date) { struct ftime t; std::vector<std::string> v; split (date, '-', &v); try { t.ft_year = stoi(v[0]) - 1980; t.ft_month = stoi(v[1]) - 1; t.ft_day = stoi(v[2]); t.ft_hour = 0; t.ft_min = 0; t.ft_tsec = 0; } catch (bad_lexical_cast& e) { cerr << "string2ftime - Bad cast: " << e.what( ) << endl; } return ftime(t); } #endif } } </DOCUMENT>
<DOCUMENT filename="transcoder - Copy.hpp">
#ifndef TRANSCODER_HPP_INCLUDED #define TRANSCODER_HPP_INCLUDED #include <unicode/ucnv.h> #include <iostream> #include <fstream> #include <sstream> #include "s.hpp" namespace pensar_digital { namespace cpplib { class Encoding { public: Encoding (const S& name) : name(name) {} operator S() const { return name; } const S& s() const noexcept { return name; } friend OutStream& operator<<(OutStream& os, const Encoding& encoding); static const Encoding UTF8; static const Encoding UTF16; static const Encoding ISO_8859_1; static const Encoding WINDOWS_1252; private: S name; }; inline OutStream& operator<<(OutStream& os, const Encoding& encoding) { os << encoding.s (); return os; } const Encoding Encoding::UTF8 (W("UTF-8" )); const Encoding Encoding::UTF16 (W("UTF-16" )); const Encoding Encoding::ISO_8859_1 (W("ISO-8859-1" )); const Encoding Encoding::WINDOWS_1252 (W("windows-1252")); #ifdef WIDE_CHAR const Encoding DefaultEncoding = Encoding::UTF16; #else const Encoding DefaultEncoding = Encoding::UTF8; #endif class Transcoder { public: Transcoder(const Encoding& in, const Encoding& out) : min(in), mout(out) {} void transcode(InStream& in_stream, OutStream& out_stream) { UErrorCode error = U_ZERO_ERROR; UConverter* in_converter = ucnv_open(min.s ().c_str (), &error); if (U_FAILURE(error)) { std::cerr << "Failed to open input converter for " << min << std::endl; return; } UConverter* out_converter = ucnv_open (mout.s ().c_str (), &error); if (U_FAILURE(error)) { std::cerr << "Failed to open output converter for " << mout << std::endl; return; } S line; while (std::getline (in_stream, line)) { const C* source = line.c_str(); const C* sourceLimit = source + line.length (); const size_t size = 1024; UChar target[size]; UChar* targetStart = target; ucnv_toUnicode (in_converter, &targetStart, &target[size - 1], &source, sourceLimit, NULL, true, &error); if (U_FAILURE (error)) { std::cerr << "Failed to convert line to Unicode" << std::endl; return; } C output[1024]; C* out_ptr = output; ucnv_fromUnicode(out_converter, &out_ptr, output + sizeof(output), (const UChar**)&target, targetStart, NULL, true, &error); if (U_FAILURE(error)) { std::cerr << "Failed to convert line from Unicode" << std::endl; return; } out_stream << output << std::endl; } ucnv_close (in_converter); ucnv_close (out_converter); } private: Encoding min; Encoding mout; }; } } #endif </DOCUMENT>
<DOCUMENT filename="transcoder.hpp">
#ifndef TRANSCODER_HPP_INCLUDED #define TRANSCODER_HPP_INCLUDED #include <unicode/ucnv.h> #include <iostream> #include <fstream> #include <sstream> #include "s.hpp" namespace pensar_digital { namespace cpplib { class Encoding { public: Encoding (const S& name) : name(name) {} operator S() const { return name; } const S& s() const noexcept { return name; } friend OutStream& operator<<(OutStream& os, const Encoding& encoding); static const Encoding UTF8; static const Encoding UTF16; static const Encoding ISO_8859_1; static const Encoding WINDOWS_1252; private: S name; }; inline OutStream& operator<<(OutStream& os, const Encoding& encoding) { os << encoding.s (); return os; } const Encoding Encoding::UTF8 (W("UTF-8" )); const Encoding Encoding::UTF16 (W("UTF-16" )); const Encoding Encoding::ISO_8859_1 (W("ISO-8859-1" )); const Encoding Encoding::WINDOWS_1252 (W("windows-1252")); #ifdef WIDE_CHAR const Encoding DefaultEncoding = Encoding::UTF16; #else const Encoding DefaultEncoding = Encoding::UTF8; #endif class Transcoder { public: Transcoder(const Encoding& in, const Encoding& out) : min(in), mout(out) {} void transcode(InStream& in_stream, OutStream& out_stream) { UErrorCode error = U_ZERO_ERROR; UConverter* in_converter = ucnv_open(min.s ().c_str (), &error); if (U_FAILURE(error)) { std::cerr << "Failed to open input converter for " << min << std::endl; return; } UConverter* out_converter = ucnv_open (mout.s ().c_str (), &error); if (U_FAILURE(error)) { std::cerr << "Failed to open output converter for " << mout << std::endl; return; } S line; while (std::getline (in_stream, line)) { const C* source = line.c_str(); const C* sourceLimit = source + line.length (); const size_t size = 1024; UChar target[size]; UChar* targetStart = target; ucnv_toUnicode (in_converter, &targetStart, &target[size - 1], &source, sourceLimit, NULL, true, &error); if (U_FAILURE (error)) { std::cerr << "Failed to convert line to Unicode" << std::endl; return; } C output[1024]; C* out_ptr = output; ucnv_fromUnicode(out_converter, &out_ptr, output + sizeof(output), (const UChar**)&target, targetStart, NULL, true, &error); if (U_FAILURE(error)) { std::cerr << "Failed to convert line from Unicode" << std::endl; return; } out_stream << output << std::endl; } ucnv_close (in_converter); ucnv_close (out_converter); } private: Encoding min; Encoding mout; }; } } #endif </DOCUMENT>
<DOCUMENT filename="trivially_persistable_memory_buffer.hpp">
 #ifndef TRIVIALLY_PERSISTABLE_MEMORY_BUFFER_HPP #define TRIVIALLY_PERSISTABLE_MEMORY_BUFFER_HPP #include "constant.hpp" #include "s.hpp" #include "bytes_util.hpp" #include "concept.hpp" #include "memory_buffer.hpp" #include <memory> #include <concepts> #include <exception> #include <string> #include <typeinfo> #include <string.h> #include <utility> #include <unordered_map> #include <functional> #include <typeindex> #include <span> namespace pd = pensar_digital::cpplib; namespace pensar_digital { namespace cpplib { template <TriviallyPersistable T> class TriviallyPersistableMemoryBuffer : public MemoryBuffer { public: void write_obj (const T& obj) noexcept { auto offset_it = this->mindex.find(obj.id()); if (offset_it != this->mindex.end()) { memcpy(this->mbuffer.data() + offset_it->second + sizeof(Id), (std::byte*)(obj.data()), obj.data_size()); } else { auto id = obj.id(); this->write((BytePtr)&id, sizeof(id)); this->write(obj.data_bytes(), obj.data_size()); } } template <typename... Args> requires FactoryConstructible<T, Args...> T::Factory::P write_obj (Args&&... args) noexcept { typename T::Factory::P p = T::get(std::forward<Args>(args)...); write_obj (*p); return p; } T::Factory::P write_obj () noexcept { typename T::Factory::P p = T::get(); T obj = *p; write_obj (obj); return p; } void read_obj (typename T::Factory::P* p) { if (*p != nullptr) { Id id = (*p)->id(); auto offset_it = this->mindex.find(id); if (offset_it != this->mindex.end()) { MemoryBuffer::read((BytePtr)((*p)->data()), offset_it->second + sizeof(Id), (*p)->data_size()); return; } } else { (*p) = T::get(); } Id id = NULL_ID; MemoryBuffer::read((BytePtr)(&id), this->mread_offset, sizeof(Id)); (*p)->set_id(id); MemoryBuffer::read((BytePtr)((*p)->data()), this->mread_offset, (*p)->data_size()); } template <typename... Args> requires FactoryConstructible<T, Args...> typename T::Factory::P read_obj (Args... args) { typename T::Factory::P p = T::get(args ...); read_obj (&p); return p; } typename T::Factory::P read_obj () { typename T::Factory::P p = T::get(); read_obj (&p); return p; } }; } } #endif </DOCUMENT>
<DOCUMENT filename="type_manipulation.hpp">
#ifndef TYPE_MANIPULATION_HPP_INCLUDED #define TYPE_MANIPULATION_HPP_INCLUDED namespace pensar_digital { template <int v> struct Int2Type { enum { value = v }; }; } #endif </DOCUMENT>
<DOCUMENT filename="type_util.hpp">
 #ifndef TYPE_UTIL_HPP_INCLUDED #define TYPE_UTIL_HPP_INCLUDED #include <typeinfo> #include "constant.hpp" #include "s.hpp" namespace pensar_digital { namespace cpplib { template <class T> S class_name() noexcept { std::string s = typeid(T).name(); s.erase(0, sizeof(W("class ")) - 1); #ifdef WIDE_CHAR return to_wstring (s); #else return s; #endif } } } #endif </DOCUMENT>
<DOCUMENT filename="validation.cpp">
 #ifdef VISUAL_STUDIO #include "stdafx.h" #endif #ifdef CODE_GEAR #pragma hdrstop #endif #include <vector> #include "validation.hpp" #include "string_util.hpp" namespace pensar_digital { namespace cpplib { #ifdef CODE_GEAR const AnsiString MSG_INVALID_DATE = "Por favor preencha uma data no formato dd/mm/yyyy."; const AnsiString MSG_INVALID_CPF_1 = "Número de dígitos do CPF está incorreto. Por favor redigite."; const AnsiString MSG_INVALID_CPF_2 = "CPF inválido. Por favor redigite."; const AnsiString MSG_INVALID_NAME = "Por favor preencha seu nome completo sem abreviações."; const AnsiString MSG_EMPTY = "Por favor preencha o campo acima."; const AnsiString MSG_INVALID_PHONE_NUMBER = "Número de telefone inválido, por favor redigite."; const int CPF_SIZE = 11; VALIDATION_RESULT is_valid_cpf (AnsiString cpf, void* somepointer, bool use_exception) throw (cpf_exception) { VALIDATION_RESULT vr; vr.ok = true; AnsiString d = only_digits (cpf); if (d.Length() != CPF_SIZE) { vr.err_msg = MSG_INVALID_CPF_1; vr.ok = false; if (use_exception) throw cpf_exception (vr.err_msg, somepointer); } else { int i; int j; int digit; int coeficient; int sum; int foundDv[] = { 0, 0 }; int dv1 = StrToInt (d[CPF_SIZE - 1]); int dv2 = StrToInt (d[CPF_SIZE]); for (j = 0; j < 2; j++) { sum = 0; coeficient = 2; for (i = CPF_SIZE - 2 + j; i >= 1; i--) { digit = StrToInt (d[i]); sum += digit * coeficient; coeficient++; } foundDv[j] = CPF_SIZE - sum % CPF_SIZE; if (foundDv[j] >= 10) foundDv[j] = 0; } if (! (dv1 == foundDv[0] && dv2 == foundDv[1])) { vr.ok = false; vr.err_msg = MSG_INVALID_CPF_2; if (use_exception) throw cpf_exception (vr.err_msg, somepointer); } } return vr; } VALIDATION_RESULT is_valid_cnpj (AnsiString cnpj, void* somepointer, bool use_exception) throw (cnpj_exception) { VALIDATION_RESULT vr; vr.ok = true; return vr; } VALIDATION_RESULT is_valid_complete_name (AnsiString name, void* somepointer, bool use_exception) throw (name_exception) { VALIDATION_RESULT vr; vr.ok = true; vector<string> v; split (name.c_str (), ' ', &v); if (v.size () < 2 || name.Pos(".") != 0) { vr.ok = false; vr.err_msg = MSG_INVALID_NAME; if (use_exception) throw name_exception (vr.err_msg, somepointer); } return vr; } VALIDATION_RESULT is_not_empty (AnsiString s, void* somepointer, bool use_exception) throw (validation_exception) { VALIDATION_RESULT vr; vr.ok = true; if (s == "") { vr.ok = false; vr.err_msg = MSG_EMPTY; if (use_exception) throw validation_exception (vr.err_msg, somepointer); } return vr; } VALIDATION_RESULT is_valid_date (AnsiString date, void* somepointer, bool use_exception) throw (date_exception) { VALIDATION_RESULT vr; vr.ok = true; try { StrToDate (date); } catch (EConvertError& e) { vr.ok = false; vr.err_msg = MSG_INVALID_DATE; if (use_exception) throw date_exception (vr.err_msg, somepointer); } return vr; } VALIDATION_RESULT is_valid_phone_number (AnsiString phone, void* somepointer, bool use_exception) throw (validation_exception) { VALIDATION_RESULT vr; vr.ok = true; static const int MIN_SIZE = 8; static const int MAX_SIZE = 13; AnsiString d = only_digits (phone); if (d.Length() < MIN_SIZE || d.Length () > MAX_SIZE) { vr.err_msg = MSG_INVALID_PHONE_NUMBER; vr.ok = false; if (use_exception) throw validation_exception (vr.err_msg, somepointer); } return vr; } AnsiString format_cpf (AnsiString cpf) { AnsiString d = only_digits (cpf); AnsiString result = d; int size = d.Length (); if (size == CPF_SIZE) { AnsiString n1 = d.SubString (0, 3); AnsiString n2 = d.SubString (4, 3); AnsiString n3 = d.SubString (7, 3); AnsiString dv = d.SubString (10, 2); result = n1 + "." + n2 + "." + n3 + "-" + dv; } return result; } #pragma package(smart_init) #endif } } </DOCUMENT>
<DOCUMENT filename="validation.hpp">
 #ifndef validationH #define validationH #endif #include <string> #include <locale> #include <iostream> #include <stdexcept> #include <sstream> namespace pensar_digital { namespace cpplib { static const bool USE_EXCEPTIONS = false; template <typename T, class String = std::string> bool min_check (T value, T min, String param_name = "", bool no_throw = true, std::locale loc = std::locale()) { bool ok = true; if (value < min) { std::stringstream ss; ss << param_name << " = " << value << " is less than min (" << min << ")." << std::endl; ok = false; if (no_throw) std::cerr << ss.str (); else throw std::invalid_argument (ss.str ()); } return ok; } template <typename T, class String = std::string> bool max_check (T value, T max, String param_name = "", bool no_throw = true, std::locale loc = std::locale()) { bool ok = true; if (value > max) { std::stringstream ss; ss << param_name << " = " << value << " is greater than max (" << max << ")." << std::endl; ok = false; if (no_throw) std::cerr << ss.str (); else throw std::invalid_argument (ss.str ()); } return ok; } template <typename T, class String = std::string> bool range_check (T value, T min, T max, String param_name = "", bool no_throw = true, std::locale loc = std::locale()) { bool ok = min_check (value, min, param_name, no_throw, loc); if (ok) ok = max_check (value, max, param_name, no_throw, loc); return ok; } #ifdef CODE_GEAR #include <vcl.h> extern const AnsiString MSG_INVALID_DATE; extern const AnsiString MSG_INVALID_CPF_1; extern const AnsiString MSG_INVALID_CPF_2; extern const AnsiString MSG_INVALID_NAME; extern const AnsiString MSG_EMPTY; extern const AnsiString MSG_INVALID_PHONE_NUMBER; extern const int CPF_SIZE; typedef struct vr { bool ok; AnsiString err_msg; operator bool () const { return ok; } operator std::string () const { AnsiString s = ok ? "true" + err_msg: "false, " + err_msg; std::string s1 = s.c_str (); return s1; } bool operator == (const struct vr& v) {return ok == v.ok && err_msg == v.err_msg;} } VALIDATION_RESULT; class validation_exception { private: int err_code; void* p; AnsiString err_msg; public: validation_exception (AnsiString err_message = "", void* somepointer = 0, int err = 0): err_msg(err_message), err_code(err), p(somepointer) {}; void* get_pointer () {return p;} AnsiString __fastcall what () { return err_msg; } int __fastcall get_err_code () { return err_code; } }; class cpf_exception : public validation_exception { public: cpf_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; class cnpj_exception : public validation_exception { public: cnpj_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; class date_exception : public validation_exception { public: date_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; class name_exception : public validation_exception { public: name_exception (AnsiString err_msg = "", void* somepointer = 0, int err = 0) : validation_exception (err_msg, somepointer, err) {}; }; extern VALIDATION_RESULT is_valid_cpf (AnsiString cpf, void* somepointer = 0, bool use_exception = true) throw (cpf_exception); extern VALIDATION_RESULT is_valid_cnpj (AnsiString cnpj, void* somepointer = 0, bool use_exception = true) throw (cnpj_exception); extern VALIDATION_RESULT is_valid_complete_name (AnsiString name, void* somepointer = 0, bool use_exception = true) throw (name_exception); extern VALIDATION_RESULT is_not_empty (AnsiString s, void* somepointer = 0, bool use_exception = true) throw (validation_exception); extern VALIDATION_RESULT is_valid_date (AnsiString date, void* somepointer = 0, bool use_exception = true) throw (date_exception); extern VALIDATION_RESULT is_valid_phone_number (AnsiString phone, void* somepointer = 0, bool use_exception = true) throw (validation_exception); #endif } } </DOCUMENT>
<DOCUMENT filename="version.cpp">
 #include "version.hpp" #include "type_util.hpp" #include "io_util.hpp" #include "concept.hpp" #include "s.hpp" #include <iostream> namespace pensar_digital { namespace cpplib { InStream& operator >> (InStream& is, Version& v) { VersionInt pub, pro, pri; return is >> pub >> pro >> pri; v.set_public (pub); v.set_protected (pro); v.set_private (pri); } OutStream& operator << (OutStream& os, const Version& v) { return os << v.get_public() << W(".") << v.get_protected() << W(".") << v.get_private(); } S Version::debug_string() const noexcept { return S(); } bool Version::equals(const Version& v) const noexcept { static_assert (Hashable<Version>); return (v.id () == id ()) && (v.mdata.mprivate == mdata.mprivate) && (v.mdata.mprotected == mdata.mprotected) && (v.mdata.mpublic == mdata.mpublic); } const Hash Version::get_hash() const noexcept { return Hash (897896785686); } std::istream& Version::binary_read (std::istream& is, const std::endian& byte_order) { return is.read((char*)(&mdata), DATA_SIZE); } std::ostream& Version::binary_write (std::ostream& os, const std::endian& byte_order) const { return os.write((const char*)(&mdata), DATA_SIZE); } } } </DOCUMENT>
<DOCUMENT filename="version.hpp">
 #ifndef VERSION_HPP_INCLUDED #define VERSION_HPP_INCLUDED #include "constant.hpp" #include "factory.hpp" #include "type_util.hpp" #include "memory_buffer.hpp" #include <iostream> #include <memory> #include <algorithm> #include <bit> namespace pensar_digital { namespace cpplib { class Version { public: using Int = int_fast16_t; using Ptr = std::shared_ptr<Version>; private: typedef Factory<Version, const Version::Int&, const Version::Int&, const Version::Int&, const Id&> VersionFactory; inline static VersionFactory mfactory = { 3, 10, 1, 1, 1, null_value<Id>() }; struct Data : public pd::Data { Id mid; Int mpublic; Int mprotected; Int mprivate; Data (const Int& pub = NULL_VERSION, const Int& prot = NULL_VERSION, const Int& priv = NULL_VERSION, const Id& aid = null_value<Id>()) : mpublic(pub), mprotected(prot), mprivate(priv), mid(aid == null_value<Id>() ? 0 : aid) {} }; Data mdata; public: inline static const Int NULL_VERSION = -1; typedef Data DataType; inline virtual const pd::Data* data() const noexcept { return &mdata; } inline static const size_t DATA_SIZE = sizeof(mdata); inline static const size_t SIZE = sizeof(mdata); inline const BytePtr version_data_bytes () const noexcept { return (BytePtr)&mdata; } inline virtual const BytePtr data_bytes() const noexcept { return (BytePtr)data(); } inline virtual size_t data_size () const noexcept { return sizeof(mdata); } inline virtual size_t size() const noexcept { return data_size(); } Version(const Int& pub = NULL_VERSION, const Int& prot = NULL_VERSION, const Int& priv = NULL_VERSION, const Id& id = null_value<Id>()) : mdata (pub, prot, priv, id) {} Version (MemoryBuffer& mb) noexcept { assign (mb); } inline static VersionFactory::P get(const Int& pub = pd::Version::NULL_VERSION, const Int& pro = Version::NULL_VERSION, const Int& pri = Version::NULL_VERSION, const Id& aid = null_value<Id>()) { return mfactory.get (pub, pro, pri, aid); }; inline virtual ~Version() noexcept = default; Version& assign (MemoryBuffer& mb) noexcept { mb.read_known_size (reinterpret_cast<BytePtr>(&mdata), DATA_SIZE); return *this; } inline virtual void write(MemoryBuffer& mb) { mb.write((BytePtr)(&mdata), DATA_SIZE); } /* inline virtual void bytes(std::vector<std::byte> v) const noexcept { size_t req_size = v.size() + data_size(); if (v.capacity() < req_size) v.resize(req_size); std::copy_n(reinterpret_cast<const std::byte*>(&mdata), data_size(), v.end() - data_size()); } */ inline virtual ByteSpan data_span() const noexcept { return ByteSpan (data_bytes(), data_size()); } inline virtual MemoryBuffer::Ptr bytes() const noexcept { MemoryBuffer::Ptr mb = std::make_unique<MemoryBuffer>(DATA_SIZE); mb->write ((BytePtr)&mdata, DATA_SIZE); return mb; } inline VersionFactory::P clone () const noexcept { return get (mdata.mpublic, mdata.mprotected, mdata.mprivate, mdata.mid); }; inline VersionFactory::P clone(const Ptr& ptr) { return ptr->clone (); } inline static VersionFactory& factory() noexcept { return mfactory; } virtual inline const Hash hash() const noexcept { return mdata.mid; }; inline Int get_public () const noexcept { return mdata.mpublic ; } inline Int get_protected () const noexcept { return mdata.mprotected; } inline Int get_private () const noexcept { return mdata.mprivate ; } inline void set_public(Int v) noexcept { mdata.mpublic = v; } inline void set_protected(Int v) noexcept { mdata.mprotected = v; } inline void set_private(Int v) noexcept { mdata.mprivate = v; } inline void set_id (const Id& id) noexcept { mdata.mid = id; } inline virtual bool initialize (const Int& pub = NULL_VERSION, const Int& prot = NULL_VERSION, const Int& priv = NULL_VERSION, const Id& aid = null_value<Id>()) noexcept { mdata.mpublic = pub ; mdata.mprotected = prot; mdata.mprivate = priv; mdata.mid = (aid == null_value<Id>() ? 0 : aid); return true; } inline S to_s (Int number)const noexcept { OutStringStream ss; ss << number; S s = ss.str(); if (number < 0) s.insert(s.begin(), W('-')); return s; } inline S to_string () const noexcept { return to_s (mdata.mpublic) + W(".") + to_s (mdata.mprotected) + W(".") + to_s (mdata.mprivate); } inline bool operator == (const Version& v) const { return ((mdata.mid == v.mdata.mid) && (mdata.mpublic == v.mdata.mpublic) && (mdata.mprotected == v.mdata.mprotected) && (mdata.mprivate == v.mdata.mprivate)); } inline bool operator != (const Version& v) const { return !(*this == v); } inline operator S() const noexcept { return to_string (); } inline friend std::istream& operator >> (std::istream& is, Version& v); inline S class_name() const { return pd::class_name<Version> (); } inline const Id id() const noexcept { return mdata.mid; } inline S debug_string() const noexcept { return S(); } inline bool equals(const Version& v) const noexcept { static_assert (Hashable<Version>); return (v.id() == id()) && (v.mdata.mprivate == mdata.mprivate) && (v.mdata.mprotected == mdata.mprotected) && (v.mdata.mpublic == mdata.mpublic); } inline const Hash get_hash() const noexcept { return Hash(897896785686); } inline std::istream& binary_read(std::istream& is, const std::endian& byte_order) { return is.read((char*)(&mdata), DATA_SIZE); } inline std::ostream& binary_write(std::ostream& os, const std::endian& byte_order) const { return os.write((const char*)(&mdata), DATA_SIZE); } }; template <typename T> concept Versionable = requires (T t) { { t.VERSION } noexcept -> std::convertible_to<Version::Ptr>; }; template <typename T> concept IdentifiableAndVersionable = Versionable<T> && Identifiable<T>; inline InStream& operator >> (InStream& is, Version& v) { Version::Int pub, pro, pri; return is >> pub >> pro >> pri; v.set_public(pub); v.set_protected(pro); v.set_private(pri); } inline OutStream& operator << (OutStream& os, const Version& v) { return os << v.get_public() << W(".") << v.get_protected() << W(".") << v.get_private(); } } } #endif </DOCUMENT>
<DOCUMENT filename="version_factory.hpp">
 #ifndef VERSION_FACTORY_HPP #define VERSION_FACTORY_HPP #include "factory.hpp" #include "version.hpp" namespace pensar_digital { namespace cpplib { typedef Factory<Version, const VersionInt&, const VersionInt&, const VersionInt&, const Id&> VersionFactoryBase; class VersionFactory2 : public VersionFactoryBase { public: VersionFactory2(const VersionInt& pub = Version::NULL_VERSION, const VersionInt& pro = Version::NULL_VERSION, const VersionInt& pri = Version::NULL_VERSION, const Id& aid = NULL_ID) : VersionFactoryBase (3, 10, pub, pro, pri, aid) { }; virtual ~VersionFactory2 () { }; using P = VersionFactoryBase::P; virtual P get (const VersionInt& pub = pd::Version::NULL_VERSION, const VersionInt& pro = Version::NULL_VERSION, const VersionInt& pri = Version::NULL_VERSION, const Id& aid = NULL_ID) { return VersionFactoryBase::get (pub, pro, pri, aid); }; P clone(const Version& aversion) { return get (aversion.get_public(), aversion.get_protected (), aversion.get_private (), aversion.get_id()); }; P clone (const VersionPtr& ptr) { return clone(*ptr); } P get (const Json& j) { Id vid = j["VERSION"]["id" ].get<VersionInt>(); VersionInt vpublic = j["VERSION"]["mpublic" ].get<VersionInt>(); VersionInt vprotected = j["VERSION"]["mprotected"].get<VersionInt>(); VersionInt vprivate = j["VERSION"]["mprivate" ].get<VersionInt>(); return get (vpublic, vprotected, vprivate, vid); }; P parse_json (const String& sjson) { Json j; P ptr = get(); std::stringstream ss(sjson); ss >> *ptr; return ptr; }; }; inline static VersionFactory2 versionf; } } #endif </DOCUMENT>
<DOCUMENT filename="windows\io_util_windows.hpp">
 #ifndef WINDOWS_IO_UTIL_HPP #define WINDOWS_IO_UTIL_HPP #include "../io_util.hpp" #include "../code_util.hpp" #include "../s.hpp" #include <string> #include <io.h> #include <windows.h> #include <filesystem> namespace pensar_digital { namespace cpplib { namespace fs = std::filesystem; using LINE_HANDLER = void(*)(const int64_t line_count, const S& line); inline Result<S> get_exe_full_path() { C buffer[MAX_PATH]; if (GetModuleFileNameA(NULL, buffer, MAX_PATH) == 0) { return Result<S>(W("Error getting executable path")); } S exe_path(buffer); Result<S> r = exe_path; return r; } inline S& read_file (const S& filename, S* s) { #ifdef WIDE_CHAR std::string fname = to_string(filename); HANDLE file = CreateFileA(fname.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); #else std::wstring fname = to_wstring(filename); HANDLE file = CreateFileW(fname.c_str (), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); #endif if (file == INVALID_HANDLE_VALUE) { } DWORD file_size = GetFileSize(file, NULL); #pragma warning(push) #pragma warning(disable: 6387) HANDLE file_mapping = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL); if (file_mapping == NULL) { log_and_throw("windows_read_file: Error mapping file: " + filename); } #pragma warning(pop) else { char* addr = static_cast<char*>(MapViewOfFile(file_mapping, FILE_MAP_READ, 0, 0, file_size)); if (addr == NULL) { log_and_throw("windows_read_file: Error mapping view of file: " + filename); } else { #ifdef WIDE_CHAR std::string* s2 = new std::string(addr, file_size); *s = to_wstring(*s2); #else s = new S(addr, file_size); #endif UnmapViewOfFile(addr); if (file_mapping != 0) CloseHandle(file_mapping); CloseHandle(file); return *s; } } } template <typename T> void binary_write(std::ostream& os, const T& t, const size_t& size, const std::endian& byte_order = std::endian::native) { os.write((char*)&size, sizeof(size)); os.write((char*)&t, size); /* if (byte_order == LITTLE_ENDIAN) { for (size_t i = 0; i < size; ++i) { os.put(static_cast<char>(t >> (i * 8))); } } else { for (size_t i = 0; i < size; ++i) { os.put(static_cast<char>(t >> ((size - i - 1) * 8))); } } */ } /* template <typename T> void binary_write(std::ostream& os, const T& t, const size_t& size) { os.write(reinterpret_cast<const char*>(&t), size); } */ template <Sizeofable T> void binary_write (std::ostream& os, const T& t, const std::endian& byte_order = std::endian::native) { os.write ((char*)&t, sizeof(t)); } template <typename CharType> void binary_write (std::ostream& os, const std::basic_string<CharType>& s, const std::endian& byte_order = std::endian::native) { binary_write<size_t> (os, s.size(), byte_order); for (auto&& c : s) { binary_write<CharType> (os, c, byte_order); } } inline void binary_write (std::ostream& os, const S& s, const std::endian& byte_order = std::endian::native) { binary_write<S::value_type> (os, s, byte_order); } template <typename T> void binary_read (std::istream& is, T& t, const size_t& size, const std::endian& byte_order = std::endian::native) { is.read ((char*)(&size), sizeof(size)); is.read ((char*)(&t), size); /* t = 0; if (bye_order == LITTLE_ENDIAN) { for (size_t i = 0; i < size; ++i) { t |= static_cast<T>(static_cast<uint8_t>(is.get())) << (i * 8); } } else { for (size_t i = 0; i < size; ++i) { t |= static_cast<T>(static_cast<uint8_t>(is.get())) << ((size - i - 1) * 8); } } */ } template <Sizeofable T> void binary_read (std::istream& is, T& t, const std::endian& byte_order = std::endian::native) { is.read ((char*)(&t), sizeof(t)); } inline void binary_read (std::istream& is, S& s, const std::endian& byte_order = std::endian::native) { size_t size; binary_read<size_t>(is, size, byte_order); s.clear(); s.reserve(size); is.read((char*)(&s), size); } template <typename DataType = uint8_t, typename CharType = S::value_type> std::basic_string<CharType>& binary_to_string (const std::vector<DataType>& data, std::basic_string<CharType>& out) { out.clear(); out.reserve(data.size() * sizeof(DataType) / sizeof(CharType)); for (auto&& byte : data) { for (size_t i = 0; i < sizeof(DataType); ++i) { out.push_back(static_cast<CharType>(byte >> (i * 8))); } } return out; } template <typename DataType = uint8_t, typename CharType = char> void string_to_binary (const std::basic_string<CharType>&in, std::vector<DataType>&out) { out.clear(); out.reserve(in.size() * sizeof(CharType) / sizeof(DataType)); for (size_t i = 0; i < in.size(); i += sizeof(DataType)) { DataType byte = 0; for (size_t j = 0; j < sizeof(DataType); ++j) { byte |= static_cast<DataType>(static_cast<uint8_t>(in[i + j])) << (j * 8); } out.push_back(byte); } } inline void create_empty_file(const C* file_full_path) { InFStream fs(file_full_path, std::ios::out); if (!fs.is_open()) { S serror = W("create_file: It was not possible to create file."); #ifdef WIDE_CHAR std::string serr = to_string(serror); S path = file_full_path; std::string full_path = to_string(path); throw std::runtime_error(serr + full_path); #else throw std::runtime_error(serror + file_full_path); #endif fs.close(); } } inline void handle_error(const char* msg) { perror(msg); exit(255); } inline uintmax_t read_file(const S& fname, LINE_HANDLER f) { InFStream fs(fname); S line; int line_count = 0; while (std::getline(fs, line)) { f(line_count++, line); } return line_count; } inline bool file_exists(const std::string& filename) { struct stat file_info; int intStat; intStat = stat(filename.c_str(), &file_info); if (intStat == 0) { return true; } else { return false; } } inline const int SAME_NAME = 0x01; inline const int SAME_SIZE = 0x02; inline const int SAME_TIME = 0x04; inline const int SAME_ALL = SAME_NAME | SAME_SIZE | SAME_TIME; #ifdef CODE_GEAR #pragma package(smart_init) inline bool operator == (const ftime& left, const ftime& right) { return left.ft_year == right.ft_year && left.ft_month == right.ft_month && left.ft_day == right.ft_day && left.ft_hour == right.ft_hour && left.ft_min == right.ft_min && left.ft_tsec == right.ft_tsec; } inline bool operator != (const ftime& left, const ftime& right) { return !(left == right); } inline bool operator < (const ftime& left, const ftime& right) { bool less = left.ft_year < right.ft_year; if (!less) { less = left.ft_month < right.ft_month; if (!less) { less = left.ft_day < right.ft_day; if (!less) { less = left.ft_hour < right.ft_hour; if (!less) { less = left.ft_min < right.ft_min; if (!less) { less = left.ft_tsec < right.ft_tsec; } } } } } return less; } inline ftime fileTimestamp(const char* gridFilePath) { FILE* fp; ftime ft; if ((fp = fopen(gridFilePath, "r")) != NULL) { getftime(fileno(fp), &ft); fclose(fp); } return ft; } inline std::string fileTimestampString(const char* gridFilePath) { FILE* fp; stringstream ss; if ((fp = fopen(gridFilePath, "r")) != NULL) { ftime ft; getftime(fileno(fp), &ft); ss << (ft.ft_year + 1980) << "-" << ft.ft_month << "-" << ft.ft_day << " " << ft.ft_hour << "h" << ft.ft_min; fclose(fp); } return ss.str(); } #endif #ifdef WINDOWS inline __int64 get_file_size(const S& file_name) { HANDLE hFile; #ifdef WIDE_CHAR hFile = CreateFile(file_name.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); #else hFile = CreateFile(to_wstring(file_name).c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); #endif if (hFile == INVALID_HANDLE_VALUE) { return -1; } LARGE_INTEGER file_size; BOOL ok = GetFileSizeEx(hFile, &file_size); CloseHandle(hFile); return ok ? file_size.QuadPart : -1; } #endif } } #endif </DOCUMENT>
<DOCUMENT filename="windows\memory_windows.hpp">
#ifndef MEMORY_WINDOWS_H_INCLUDED #define MEMORY_WINDOWS_H_INCLUDED /* * Author: David Robert Nadeau * Site: http: * License: Creative Commons Attribution 3.0 Unported License * http: */ #include "memory.hpp" #include <stdlib.h> #include <string.h> #include <assert.h> #include <iostream> #include <fstream> #include <sstream> #include <string> #if defined(_WIN32) #include <windows.h> #include <psapi.h> #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__)) #include <unistd.h> #include <sys/resource.h> #if defined(__APPLE__) && defined(__MACH__) #include <mach/mach.h> #elif (defined(_AIX) || defined(__TOS__AIX__)) || (defined(__sun__) || defined(__sun) || defined(sun) && (defined(__SVR4) || defined(__svr4__))) #include <fcntl.h> #include <procfs.h> #elif defined(__linux__) || defined(__linux) || defined(linux) || defined(__gnu_linux__) #include <stdio.h> #endif #else #error "Cannot define getPeakRSS( ) or getCurrentRSS( ) for an unknown OS." #endif namespace pensar_digital { namespace cpplib { /** * Returns the peak (maximum so far) resident set size (physical * memory use) measured in bytes, or zero if the value cannot be * determined on this OS. */ size_t getPeakRSS() { #if defined(_WIN32) PROCESS_MEMORY_COUNTERS info; GetProcessMemoryInfo(GetCurrentProcess(), &info, sizeof(info)); return (size_t)info.PeakWorkingSetSize; #elif (defined(_AIX) || defined(__TOS__AIX__)) || (defined(__sun__) || defined(__sun) || defined(sun) && (defined(__SVR4) || defined(__svr4__))) struct psinfo psinfo; int fd = -1; if ((fd = open("/proc/self/psinfo", O_RDONLY)) == -1) return (size_t)0L; if (read(fd, &psinfo, sizeof(psinfo)) != sizeof(psinfo)) { close(fd); return (size_t)0L; } close(fd); return (size_t)(psinfo.pr_rssize * 1024L); #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__)) struct rusage rusage; getrusage(RUSAGE_SELF, &rusage); #if defined(__APPLE__) && defined(__MACH__) return (size_t)rusage.ru_maxrss; #else return (size_t)(rusage.ru_maxrss * 1024L); #endif #else return (size_t)0L; #endif } size_t get_windows_available_memory() { MEMORYSTATUSEX status; status.dwLength = sizeof(status); GlobalMemoryStatusEx(&status); return status.ullAvailPhys; } template <bool UseExceptions = false> size_t get_unix_available_memory() { #if defined(_SC_AVPHYS_PAGES) return sysconf(_SC_AVPHYS_PAGES) * sysconf(_SC_PAGESIZE); #elif defined(_SC_PHYS_PAGES) return sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGESIZE); #else if (UseExceptions) { throw std::runtime_error("Failed to determine available memory."); } else return 0L; #endif } size_t get_linux_available_memory() { std::ifstream meminfo("/proc/meminfo"); std::string line; while (std::getline(meminfo, line)) { std::istringstream iss(line); std::string name; size_t value; if (iss >> name >> value) { if (name == "MemAvailable:") { return value * 1024; } } } return 0; } size_t get_available_memory() { #if defined(_WIN32) return get_windows_available_memory(); #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__)) return get_unix_available_memory<true>(); #elif defined(__linux__) || defined(__linux) || defined(linux) || defined(__gnu_linux__) return get_linux_available_memory(); #else #error "Cannot define get_available_memory () for an unknown OS." #endif } } } #endif MEMORY_WINDOWS_H_INCLUDED </DOCUMENT>
<DOCUMENT filename="wstring_stream_hack.hpp">
#ifndef WSTRING_STREAM_HACK_HPP_INCLUDED #define WSTRING_STREAM_HACK_HPP_INCLUDED namespace std { extern ostream& operator << (ostream& ostr, wstring const& str); } #endif </DOCUMENT>
<DOCUMENT filename="xml_util.hpp">
 #ifndef XML_UTIL_HPP_INCLUDED #define XML_UTIL_HPP_INCLUDED #include "constant.hpp" #include "s.hpp" #include "type_util.hpp" #include "header_lib/xmlParser.h" namespace pensar_digital { namespace cpplib { template <class T> concept Objectable = requires (T t) { { t.class_name() } -> std::convertible_to<S>; { t.id() } -> std::convertible_to<Id>; }; template<Objectable T> S ObjXMLPrefix (const T& o) noexcept { return "<object class_name = \"" + o.class_name() + "\" id = \"" + std::to_string (o.id ()) + "\""; } template <class T> XMLNode parse_object_tag (const S& sxml, Id* id_from_xml) { const char* xml = sxml.c_str (); XMLCSTR tag = W("object"); XMLResults* pResults = 0; XMLNode node = XMLNode::parseString (xml, tag, pResults); S xml_class_name = node.getAttribute (W("class_name")); if (xml_class_name == class_name<T> ()) { S sid = node.getAttribute (W("id")); *id_from_xml = std::stoi (sid); } else throw std::runtime_error (W("Invalid class name")); return node; } } } #endif </DOCUMENT>
